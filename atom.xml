<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宇信同行</title>
  <icon>https://www.gravatar.com/avatar/3ec75c9ca272d7160ff5a3c1b9bc0907</icon>
  <subtitle>Just Keep Sharing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yuxingxin.com/"/>
  <updated>2019-10-29T16:10:04.921Z</updated>
  <id>https://yuxingxin.com/</id>
  
  <author>
    <name>Sean Liu</name>
    <email>lx8909@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于Hacker News的内容热度推荐算法</title>
    <link href="https://yuxingxin.com/2019/03/10/RecommendationAlgorithm/"/>
    <id>https://yuxingxin.com/2019/03/10/RecommendationAlgorithm/</id>
    <published>2019-03-09T16:00:00.000Z</published>
    <updated>2019-10-29T16:10:04.921Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>近期公司产品需要做一个内容推荐的功能，但限于人员和能力有限，经过调研，确定了一个简单相对我们可以实现的方案。一篇文章产生，随着用户浏览、点赞、分享、收藏、评论，热度逐渐攀升，进入榜单到推荐页面，但随着时间的推移，这篇文章也不能永久的霸占榜单，让后面新产生的文章没有机会到推荐页，因此也就有了时间衰减的因素，从而可以让榜单能够动态的变化，除了上面基本的原理以外，还需要人为干预因素，通过加权或者降权的方式来影响排名。</p><h4 id="因子"><a href="#因子" class="headerlink" title="因子"></a>因子</h4><ol><li>用户活跃度（以积分的形式）</li><li>浏览量</li><li>点赞数</li><li>收藏数</li><li>评论数</li><li>分享数</li><li>时间衰减</li><li>平台编辑推荐（人为因素介入干预）</li></ol><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p><img src="https://pic1.zhimg.com/80/v2-5807f2036274e5d082dc5cb2b83742d4_hd.png" alt="img1"></p><h5 id="初始热度-Hinit"><a href="#初始热度-Hinit" class="headerlink" title="初始热度  Hinit"></a>初始热度  H<sub>init</sub></h5><p>与最后的推荐指数呈正相关（注意不是成正比），影响其的因素有：</p><ul><li>创作者：暂时以用户活跃度来界定</li><li>内容属性：以篇幅、类别来区分</li></ul><h5 id="互动热度-Hinteract"><a href="#互动热度-Hinteract" class="headerlink" title="互动热度  Hinteract"></a>互动热度  H<sub>interact</sub></h5><p>与最后的推荐指数呈正相关（注意不是成正比），用户行为数据是决定一篇文章是否热门的重要因素，通过对这些数据评级来进行调整行为分：</p><p>比如： 浏览+1分，点赞+3分，评论+8分，收藏+10分，分享+15分。 </p><h5 id="时间衰减-Htime"><a href="#时间衰减-Htime" class="headerlink" title="时间衰减 Htime"></a>时间衰减 H<sub>time</sub></h5><p>与最后的推荐指数呈负相关（注意不是成反比）</p><p>大部分内容属于一次性消费品，用户看过也就过了，若推荐榜单总是那么几条， 可能很快就觉得乏味 ，从而转向别的产品。所以我们自然希望内容能不断更新，而若只看初始热度+互动热度，那么后来者必定很难超越前者。 </p><p>所以还必须考虑一个因素就是时间衰减，通常这个也不是线性衰减，往往是一个指数函数：即过了一定时间后，持续衰减，热度直到无限趋于0</p><h5 id="权重-Hweight"><a href="#权重-Hweight" class="headerlink" title="权重 Hweight"></a>权重 H<sub>weight</sub></h5><p>运营或编辑人为干预来调整权重也很重要，毕竟算法是死的，人是活的，虽然大部分都遵循这样一个规律，但也不排除偶然或者极端情况，比如恶意刷榜，这时候就需要人为的干预</p><p>图形曲线：</p><p><img src="https://pic1.zhimg.com/80/v2-60770e14bf4cf2dd9748d91f77bf2b24_hd.jpg" alt="image-20191029102231667"></p><h4 id="总结公式"><a href="#总结公式" class="headerlink" title="总结公式"></a>总结公式</h4><p><img src="https://pic2.zhimg.com/80/v2-8ae6e823be2d4823be05d973e6aaaa0d_hd.jpg" alt="img2"></p><p>参数解释：</p><p><strong>H<sub>init</sub></strong> ： 初始热度值，可以以用户活跃度来衡量，比如以积分的形式，积分积累的途径有：</p><ol><li>发文章</li><li>发笔记</li><li>发动态</li><li>提问题</li><li>回答问题</li><li>评论</li><li>系统、平台编辑推荐</li></ol><p>在其他条件一定的情况下，初始热度越高，其最终热度也就越高</p><p><strong>H<sub>interact</sub></strong>：互动热度值，根据用户行为数据来衡量，参考点有以下几项：</p><ol><li>浏览量</li><li>点赞量</li><li>评论量</li><li>收藏量</li><li>分享量</li></ol><p>在其他条件一定的情况下，互动热度越高，其最终热度也就越高</p><p><strong>H<sub>time</sub></strong>：时间衰减因子， 加2是为了防止最新发表的会导致分母过小 ，这个值可调，在前期平台人数较少时调整大一些，在后期人数增长起来后，可以调整的小一些，比如，因为用户对平台资源有一个消化时间。并不是一发出来就有数据的。</p><p><strong>G</strong>：重力因子，它决定了热度随时间下降的速度，前期平台人员较少时，相对应得发的资源也会比较少，这时可以把G调小一点，减缓时间推移对热度下降的影响，后期平台人员增多时，相对应的资源也会增加，这时可以把G调大一点，加速时间推移对热度下降的影响。比如：1.2-1.8</p><p><strong>H<sub>weight</sub></strong>: 加减权重，初始值可以为0，在某些偶然或者极端情况下需要人为干预的时候，可以动态调整其值，使其能够及时的控制其热度。</p><h4 id="反作弊"><a href="#反作弊" class="headerlink" title="反作弊"></a>反作弊</h4><ol><li>可以通过权重来干预</li><li>可以制定社区规则来动态调整H<sub>init</sub></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://medium.com/hacking-and-gonzo/how-hacker-news-ranking-algorithm-works-1d9b0cf2c08d" target="_blank" rel="noopener">Hacker News 帖子热度排序算法</a></li><li><a href="https://juejin.im/post/5cc80ad7e51d45789161d0e1" target="_blank" rel="noopener">掘金文章内容热度排序算法</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;近期公司产品需要做一个内容推荐的功能，但限于人员和能力有限，经过调研，确定了一个简单相对我们可以实现的方案。一篇文章产生，随着用户浏览、点赞
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://yuxingxin.com/categories/Algorithm/"/>
    
    
      <category term="Recommendation algorithm" scheme="https://yuxingxin.com/tags/Recommendation-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>关于Code Review的一些思考总结</title>
    <link href="https://yuxingxin.com/2018/06/17/CodeReview/"/>
    <id>https://yuxingxin.com/2018/06/17/CodeReview/</id>
    <published>2018-06-16T16:00:00.000Z</published>
    <updated>2019-04-28T02:48:44.769Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Code-Review"><a href="#Code-Review" class="headerlink" title="Code Review"></a>Code Review</h2><ul><li>提高代码质量</li><li>提前发现bug</li><li>统一代码规范</li><li>提高团队成员代码技能</li></ul><p>总之，前期找问题（代码规范、潜在缺陷、BUG，代码设计等等），后期演变成开发者技术交流和员工成长</p><h3 id="如何开展"><a href="#如何开展" class="headerlink" title="如何开展"></a>如何开展</h3><ul><li>代码规范：<strong>明确Coding规则</strong></li><li>检视清单：<strong>结合业务特点，check重点</strong></li><li>总结优化：<strong>透明问题，持续优化</strong></li><li>激励措施：<strong>激发主观能动性</strong></li></ul><h3 id="开展方式"><a href="#开展方式" class="headerlink" title="开展方式"></a>开展方式</h3><ul><li><strong>强制&amp;非强制</strong></li><li><strong>线上交流（小组review）&amp;线下会议（团队review）</strong></li><li><strong>小片段&amp;大模块</strong></li><li><strong>发布前&amp;发布后</strong></li><li><strong>高频率&amp;低频率</strong></li></ul><h3 id="阻力因素"><a href="#阻力因素" class="headerlink" title="阻力因素"></a>阻力因素</h3><ol><li>领导或者团队骨干不认同</li><li>为了疲于应付</li><li>以<strong>需求多，没时间</strong>做为偷懒借口</li></ol><h3 id="组织类型"><a href="#组织类型" class="headerlink" title="组织类型"></a>组织类型</h3><ul><li>小组内review，通常是模块负责人或者项目负责人review，频率比较高，一天至少一次</li><li>团队review，通常是整个团队review代码，团队负责人牵头，频率可以低一点，鉴于公司情况一周至少1次吧</li></ul><h3 id="review内容"><a href="#review内容" class="headerlink" title="review内容"></a>review内容</h3><h4 id="统一团队代码风格和编程规范"><a href="#统一团队代码风格和编程规范" class="headerlink" title="统一团队代码风格和编程规范"></a>统一团队代码风格和编程规范</h4><p>  静态代码检查工具</p><ol><li><strong>Java类</strong>：Checkstyle、FindBugs、PMD、Infer等</li><li><strong>JavaScript类</strong>：JSLint、ESLint等</li><li><strong>Object-C类</strong>：OCLint、Clang Static Analyzer、Infer等</li><li><p><strong>C#</strong>类：StyleCode等</p><p>可以参考的一些编码规范(<a href="https://github.com/Kristories/awesome-guidelines" target="_blank" rel="noopener">https://github.com/Kristories/awesome-guidelines</a>)</p></li></ol><h4 id="发现『bad-smell』的代码以及bug"><a href="#发现『bad-smell』的代码以及bug" class="headerlink" title="发现『bad smell』的代码以及bug"></a>发现『bad smell』的代码以及bug</h4><p>  相关书籍：《重构-改善既有代码的设计》《代码整洁之道》</p><h4 id="团队成员好的经验"><a href="#团队成员好的经验" class="headerlink" title="团队成员好的经验"></a>团队成员好的经验</h4><ul><li>什么写法可能导致性能低下？</li><li>哪个接口要慎用？</li><li>哪些设计方式需要规避？</li><li>什么习惯容易引发内存泄漏？<br>……</li></ul><h4 id="开发者由于当初时间紧迫而觉得设计不合理的功能"><a href="#开发者由于当初时间紧迫而觉得设计不合理的功能" class="headerlink" title="开发者由于当初时间紧迫而觉得设计不合理的功能"></a>开发者由于当初时间紧迫而觉得设计不合理的功能</h4><ul><li>功能不完善</li><li>设计有欠缺</li><li>代码有更好实现方案</li><li>重视项目代码的可读性</li></ul><p>总之，代码是否符合团队约定的代码风格规范、代码是否切合它所实现的业务、代码是否安全、代码性能、对后续开发者是否友好，即是否容易维护等</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>GitLab可以设置master和develop分支保护，开发者不能向这两个分支push代码，只能通过PR/MR形式。</li><li>可以通过设置git pre-commit hook来check，从而使不符合规范的代码禁止提交仓库。</li><li>配合CI检查，作为build的第一步。</li><li>用户角色有：<strong>所有者/主程/开发者/报告者/访客</strong>，其中只有所有者和主程才有review代码和合并代码权限。</li><li>注意小组至少有两个人有权限review并合并代码，避免一个人请假或者不在，导致代码合不上去。</li><li>主程一定要注意，避免过多模块工作堆积在自己身上，一定要学会合理分配任务，因为你还需要有精力去review代码，这也是一部分额外任务。</li><li>提交的 feature 分支全部走 gitlab 的 MR ，<strong>develop分支不允许提交，只用来合并</strong>，并且只合并那些经过review过的代码，<strong>master分支不允许提交，也只用来合并</strong>，并且只合并来自develop分支的代码。</li><li>不一定职称越高，就更有可能比别人review代码，code review知识共享更受重视，通过review发现bug是有的，但不是最终目的，增进团队共识，保护团队一致性其实更重要。</li><li>尽量避免开发经验不足的开发者或者刚进公司对业务不熟悉的人员（哪怕高级工程师）review 代码。</li><li>如果可以尽可能写单元测试，不一定cover全面，如果时间紧迫可以只对关键模块做。</li><li>提交PR/MR，记得在IM上通知相关人员review，比如项目负责人或者模块负责人。</li><li>控制团队review的时间，半个小时到1个小时，最好不要超过1个小时，30-40分钟为宜，项目负责人具体把握。</li><li>根据公司情况团队review一周在至少一次比较合适。</li><li>review可能需要多次才被允许合入代码，这也就意味着，可能你的代码需要给多次修改才能改好。</li><li>避免代码堆积，造成一次review大量代码，一方面急于review，这样容易放水，同时也浪费时间，造成效果不理想。</li><li>建议由1人做好记录，把每次review的改进点以清单形式汇总列清楚发给所有参会人员。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由于工期紧、需求变更快，如果不想清楚为什么要做 Code Review ，遇到障碍会非常容易妥协，慢慢 Code Review 就会走样，最终流于形式。反之，在我们遇到障碍，review 代码不顺利时就会以积极的心态来解决问题。Code Review会影响开发效率，事实上追求高质量的代码本身就降低了局部的开发效率，但是放眼长远，这样写出来的代码更加健壮，不会或很少出现“诡异”的bug，降低了后期维护的成本。</p><p>所以Code Review本身没有问题，其实是人容易出问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Code-Review&quot;&gt;&lt;a href=&quot;#Code-Review&quot; class=&quot;headerlink&quot; title=&quot;Code Review&quot;&gt;&lt;/a&gt;Code Review&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;提高代码质量&lt;/li&gt;
&lt;li&gt;提前发现bug&lt;/li&gt;
      
    
    </summary>
    
      <category term="CodeStyle" scheme="https://yuxingxin.com/categories/CodeStyle/"/>
    
    
      <category term="CodeReview" scheme="https://yuxingxin.com/tags/CodeReview/"/>
    
  </entry>
  
  <entry>
    <title>关于fastlane已存在的证书复用问题</title>
    <link href="https://yuxingxin.com/2018/01/10/FastlaneReuseCerts/"/>
    <id>https://yuxingxin.com/2018/01/10/FastlaneReuseCerts/</id>
    <published>2018-01-09T16:00:00.000Z</published>
    <updated>2019-02-28T09:41:23.516Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>iOS开发在团队项目协作中，面临着许许多的挑战，除了被大家诟病的nib文件和故事板以外，还有就是今天要说的证书管理问题，相信做过iOS开发的用户对fastlane已经不陌生了，它提供了很多有用的功能来帮助开发者从繁琐的重复性劳动中解脱出来，这里列举出一些：<br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fnbcmq6spkj30to0sbtag.jpg" alt></p><ul><li>deliver: 上传截图, 元数据, app应用程序到App Store</li><li>supply: 上传Android app应用程序和元数据到Google Play</li><li>snapshot: 自动捕获iOS app应用程序本地截图</li><li>screengrab: 自动捕获Android app应用程序本地截图</li><li>frameit: 快速截屏并将截屏放入设备中</li><li>pem: 自动生成和更新推送通知配置文件</li><li>sigh: 开发证书和描述文件下载</li><li>produce: 使用命令行在iTunes Connect上创建新的app和开发入口</li><li>cert: 自动创建和配置iOS代码签名证书</li><li>spaceship: Ruby 库访问 Apple开发者中心和 iTunes Connect</li><li>pilot: 最好的方式管理你的TestFlight 测试人员和从终端构建</li><li>boarding: 最简单的方式邀请你的TestFlight beta测试人员</li><li>gym: iOS app打包签名自动化工具</li><li>match: 使用Git同步你的团队证书和配置文件</li><li>scan: 最简单方式测试你的 iOS 和 Mac apps</li></ul><p>今天说的其实是match，我们知道，苹果公司在个人开发者账号上面对于证书的生成是有严格的数量限制的，<code>development</code> 和 <code>distribution</code>证书类型只能生成2个，所以如果按照fastlane每次build不同的target或者不同的Bundle ID的话，它都会重新去生成一个新的证书并以此生成对应的描述文件，这样以来，我们也只能最多同时用该开发者账号签名两个App安装在真机上，想用第三个就必须revoke掉以前生成的证书，当然了，一旦把证书revoke掉了，这也就意味着我们用该证书签名的App也不能在真机上面使用了。所以就得考虑一下，该如果复用现有证书。</p><h4 id="1-拿到你想要复用证书的ID"><a href="#1-拿到你想要复用证书的ID" class="headerlink" title="1. 拿到你想要复用证书的ID"></a>1. 拿到你想要复用证书的ID</h4><p>关于这个证书ID，从钥匙串和openssl工具库中没有找到方法来取到，但是可以通过spaceship这个库来实现，下面是相关脚本：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'spaceship'</span></span><br><span class="line">Spaceship.login(<span class="string">'your@apple.id'</span>)</span><br><span class="line">Spaceship.select_team</span><br><span class="line">Spaceship.certificate.all.each <span class="keyword">do</span> <span class="params">|cert|</span> </span><br><span class="line">  cert_type = Spaceship::Portal::Certificate::CERTIFICATE_TYPE_IDS[cert.type_display_id].to_s.split(<span class="string">"::"</span>)[-<span class="number">1</span>]</span><br><span class="line">  puts <span class="string">"Cert id: <span class="subst">#&#123;cert.id&#125;</span>, name: <span class="subst">#&#123;cert.name&#125;</span>, expires: <span class="subst">#&#123;cert.expires.strftime(<span class="string">"%Y-%m-%d"</span>)&#125;</span>, type: <span class="subst">#&#123;cert_type&#125;</span>"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>执行上面代码，会输出所有证书的相应信息，你可以从中找到你想复用的那个证书的ID。</p><h4 id="2-创建远程仓库来保存证书。"><a href="#2-创建远程仓库来保存证书。" class="headerlink" title="2. 创建远程仓库来保存证书。"></a>2. 创建远程仓库来保存证书。</h4><p>建立一个远程仓库，并在该目录下创建<code>certs/distribution</code>和 <code>certs/development</code>目录，分别存放生产和开发环境下的相关证书文件。</p><h4 id="3-通过钥匙串导出你想要复用的那个证书"><a href="#3-通过钥匙串导出你想要复用的那个证书" class="headerlink" title="3. 通过钥匙串导出你想要复用的那个证书"></a>3. 通过钥匙串导出你想要复用的那个证书</h4><p>导出对应的cer文件和p12文件。</p><h4 id="4-执行下面命令，导出私钥文件"><a href="#4-执行下面命令，导出私钥文件" class="headerlink" title="4. 执行下面命令，导出私钥文件"></a>4. 执行下面命令，导出私钥文件</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -nocerts -nodes -out key<span class="selector-class">.pem</span> -<span class="keyword">in</span> certificate.p12</span><br></pre></td></tr></table></figure><h4 id="5-生成最后需要的证书"><a href="#5-生成最后需要的证书" class="headerlink" title="5. 生成最后需要的证书"></a>5. 生成最后需要的证书</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl aes-<span class="number">256</span>-cbc -k &lt;your_password&gt; -<span class="keyword">in</span> key<span class="selector-class">.pem</span> -out &lt;cert_id&gt;<span class="selector-class">.p12</span> -a</span><br><span class="line">openssl aes-<span class="number">256</span>-cbc -k &lt;your_password&gt; -<span class="keyword">in</span> certificate<span class="selector-class">.cer</span> -out &lt;cert_id&gt;<span class="selector-class">.cer</span> -a</span><br></pre></td></tr></table></figure><p>这里的cert_id是上面我们保存的证书id，其中执行完上述步骤后，就生成了fastlane match想要的证书，当执行fastlane match development/adhoc/appstore命令后，match就不会在Apple Development Center重新生成证书了，而是用现有的。<br>将证书分别放到对应的git仓库目录中，提交并推送到远程仓库。</p><h4 id="6-在开发者网站上面生成App-ID"><a href="#6-在开发者网站上面生成App-ID" class="headerlink" title="6. 在开发者网站上面生成App ID"></a>6. 在开发者网站上面生成App ID</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane produce -u &lt;your@apple.<span class="built_in">id</span>&gt; -a &lt;your_app_bundle_id&gt; <span class="comment">--skip_itc</span></span><br></pre></td></tr></table></figure><p>如果你的App需要在ITC（iTunes Connect）中创建，则移除<code>--skip_itc</code>选项。</p><h4 id="7-生成证书对应的描述文件"><a href="#7-生成证书对应的描述文件" class="headerlink" title="7. 生成证书对应的描述文件"></a>7. 生成证书对应的描述文件</h4><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane <span class="keyword">match</span> &lt;<span class="class"><span class="keyword">type</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中type有四种：development/adhoc/distribution/appstore<br>如果执行过程中，出现输入Git Repo密码后，密码错误导致的不能解密repo，可以尝试着用<code>fastlane match change_password</code>来重置密码。如果修改密码后，发现还是不行的话，可以在与distribution同级目录下创建一个txt文件：”match_version.txt”，内容为fastlane版本号即可，再重新执行。</p><blockquote><p>[22:57:23]: Cloning remote git repo…<br>[22:57:28]: Migrating to new match…<br>[22:57:28]: Enter the passphrase that should be used to encrypt/decrypt your certificates<br>[22:57:28]: This passphrase is specific per repository and will be stored in your local keychain<br>[22:57:28]: Make sure to remember the password, as you’ll need it when you run match on a different machine<br>Passphrase for Git Repo: <strong>**</strong><br>Type passphrase again: <strong>**</strong><br>[22:57:34]: 🔒 Successfully encrypted certificates repo<br>[22:57:34]: Cloning remote git repo…<br>[22:57:39]: Couldn’t decrypt the repo, please make sure you enter the right password!<br>version: 256<br>class: “inet”<br>：：：：<br>：：：：</p></blockquote><h3 id="关于注册新设备"><a href="#关于注册新设备" class="headerlink" title="关于注册新设备"></a>关于注册新设备</h3><p>在这之前我们都是通过开发者中心来添加和管理更新设备以及描述文件，有了fastlane提供的match命令则可以帮助我们做这些事情。<br><strong>注册新设备</strong><br><strong>我们可以</strong>通过添加action的方式<strong>更新Fastfile文件：</strong></p><p><strong>直接添加设备</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">register_devices(</span><br><span class="line">  devices: &#123;</span><br><span class="line">    <span class="string">"Luka iPhone 6"</span> =&gt; <span class="string">"1234567890123456789012345678901234567890"</span>,</span><br><span class="line">    <span class="string">"Felix iPad Air 2"</span> =&gt; <span class="string">"abcdefghijklmnopqrstvuwxyzabcdefghijklmn"</span></span><br><span class="line">  &#125;</span><br><span class="line">) <span class="comment"># Simply provide a list of devices as a Hash</span></span><br></pre></td></tr></table></figure></p><p><strong>通过文件添加设备</strong><br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">register_devices</span>(</span><br><span class="line">  <span class="attribute">devices_file</span>: <span class="string">"./devices.txt"</span></span><br><span class="line">) # <span class="selector-tag">Alternatively</span> <span class="selector-tag">provide</span> <span class="selector-tag">a</span> <span class="selector-tag">standard</span> <span class="selector-tag">UDID</span> <span class="selector-tag">export</span> <span class="selector-class">.txt</span> <span class="selector-tag">file</span>, <span class="selector-tag">see</span> <span class="selector-tag">the</span> <span class="selector-tag">Apple</span> <span class="selector-tag">Sample</span> (<span class="attribute">http</span>:<span class="comment">//devimages.apple.com/downloads/devices/Multiple-Upload-Samples.zip)</span></span><br></pre></td></tr></table></figure></p><p>文件格式参考demo：<a href="http://link.zhihu.com/?target=http%3A//devimages.apple.com/downloads/devices/Multiple-Upload-Samples.zip" target="_blank" rel="noopener">http://devimages.apple.com/downloads/devices/Multiple-Upload-Samples.zip</a></p><p>你也可以添加参数：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">register_devices(</span><br><span class="line">  devices_file: <span class="string">"./devices.txt"</span>, <span class="comment"># You must pass in either `devices_file` or `devices`.</span></span><br><span class="line">  team_id: <span class="string">"XXXXXXXXXX"</span>,         <span class="comment"># Optional, if you"re a member of multiple teams, then you need to pass the team ID here.</span></span><br><span class="line">  username: <span class="string">"luka@goonbee.com"</span>   <span class="comment"># Optional, lets you override the Apple Member Center username.</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p><strong>更新描述文件</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span>(<span class="class"><span class="keyword">type</span></span>: <span class="string">"adhoc"</span>, force_for_new_devices: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure></p><p>注意这里的type，对应我们前面提到的几种类型，除此之外，我们也可以通过命令行的方式来更新描述文件：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane <span class="built_in">match</span> adhoc <span class="comment">--force_for_new_devices</span></span><br></pre></td></tr></table></figure></p><p>这样以来，fastlane会重新更新描述文件并提交到我们的证书仓库。<br>后面我们需要做的就是，只需重新打包，然后将包通过Airport安装到新的设备上就可以了，经测试以前用该描述文件打的包也可以安装到新设备上面去。</p><h3 id="关于Apple-ID开启双重验证"><a href="#关于Apple-ID开启双重验证" class="headerlink" title="关于Apple ID开启双重验证"></a>关于Apple ID开启双重验证</h3><p>如果开启双重验证，默认苹果会在新设备登录时，需要手动输入验证码，这时候如果是在CI上面构建，就会带来问题，此时我们可以通过以下方式解决：</p><ol><li>访问<a href="https://appleid.apple.com/" target="_blank" rel="noopener">Apple ID网站</a>,找到 安全 - App 专用密码，生成一个专用密码</li><li><p>然后在构建服务器上面配置环境变量: vim ~/.bash_profile</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD</span>=&lt;YOUR_PASSWORD&gt;</span><br></pre></td></tr></table></figure></li><li><p>执行 fastlane spaceauth -u <your_apple_id> 按提示获取session信息</your_apple_id></p></li><li>复制session信息（很长一大段） 配置环境变量: vim ~/.bash_profile<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">FASTLANE_SESSION</span>=‘YOUR SESSION’</span><br></pre></td></tr></table></figure></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="http://macoscope.com/blog/simplify-your-life-with-fastlane-match/" target="_blank" rel="noopener">Simplify your life with fastlane match</a></li><li><a href="https://docs.fastlane.tools/actions/register_devices/" target="_blank" rel="noopener">register_devices - fastlane docs</a></li><li><a href="https://docs.fastlane.tools/actions/match/" target="_blank" rel="noopener">match - fastlane docs</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;iOS开发在团队项目协作中，面临着许许多的挑战，除了被大家诟病的nib文件和故事板以外，还有就是今天要说的证书管理问题，相信做过iOS开发的
      
    
    </summary>
    
      <category term="iOS" scheme="https://yuxingxin.com/categories/iOS/"/>
    
    
      <category term="fastlane" scheme="https://yuxingxin.com/tags/fastlane/"/>
    
  </entry>
  
  <entry>
    <title>Ruby相关环境配置</title>
    <link href="https://yuxingxin.com/2017/12/29/RubyVersionManage/"/>
    <id>https://yuxingxin.com/2017/12/29/RubyVersionManage/</id>
    <published>2017-12-28T16:00:00.000Z</published>
    <updated>2019-03-19T03:02:46.094Z</updated>
    
    <content type="html"><![CDATA[<p>最近在使用fastlane来实现项目的自动化，发现这套工具是用Ruby这门语言写的，为了了解Ruby的一些环境配置，这里做个笔记，来记录关于Ruby遇到的一些问题。</p><h4 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h4><h5 id="1-RVM"><a href="#1-RVM" class="headerlink" title="1. RVM"></a>1. RVM</h5><p><a href="https://rvm.io/" target="_blank" rel="noopener">RVM</a> ，顾名思义，Ruby Version Manager，用于管理Ruby环境，通常在多个项目中，不同的工程用的Ruby版本不一样，这时候我们就需要一个工具来帮助我们管理这些版本，另外还有一些依赖的三方插件都由它来管理</p><h5 id="2-Rails"><a href="#2-Rails" class="headerlink" title="2. Rails"></a>2. Rails</h5><p><a href="http://rubyonrails.org/" target="_blank" rel="noopener">Rails</a> ，顾名思义，Ruby on Rails，是一个使用Ruby语言写的开源Web应用框架，它是严格按照MVC结构开发的。它努力使自身保持简单，来使实际的应用开发时的代码更少，使用最少的配置。</p><h5 id="3-RubyGems"><a href="#3-RubyGems" class="headerlink" title="3. RubyGems"></a>3. RubyGems</h5><p>RubyGems是一个方便而强大的Ruby程序包管理器（ package manager），类似于RedHat的RPM.它将一个Ruby应用程序打包到一个gem里，作为一个安装单元。最新版本的Ruby已经包含它了。</p><h5 id="4-Gem"><a href="#4-Gem" class="headerlink" title="4. Gem"></a>4. Gem</h5><p>Gem是封装起来的Ruby应用程序或代码库，在终端使用的gem命令，是指通过RubyGems管理Gem包。</p><h5 id="5-Gemfile"><a href="#5-Gemfile" class="headerlink" title="5. Gemfile"></a>5. Gemfile</h5><p>一个定义你的项目都依赖哪些第三方库的文件，bundle会根据这个文件的配置去找这些依赖包。</p><h5 id="6-Rake"><a href="#6-Rake" class="headerlink" title="6. Rake"></a>6. Rake</h5><p><a href="https://ruby.github.io/rake/" target="_blank" rel="noopener">Rake</a>是一门构建语言，和make类似。Rake是用Ruby写的，它支持自己的DSL用来处理和维护Ruby程序。 Rails就是用rake扩展来完成多种不容任务，如数据库初始化、更新等。</p><h5 id="7-Rakefile"><a href="#7-Rakefile" class="headerlink" title="7. Rakefile"></a>7. Rakefile</h5><p>Rakefile是由Ruby编写，Rake的命令执行就是由Rakefile文件定义。</p><h5 id="8-Bundler"><a href="#8-Bundler" class="headerlink" title="8. Bundler"></a>8. Bundler</h5><p><a href="http://bundler.io/" target="_blank" rel="noopener">Bundler</a>相当于多个RubyGems批处理运行，在配置文件Gemfile里指定你的应用依赖哪些第三方包，它会自动帮你下载安装这些包，并且会下载这些包依赖的包。</p><h4 id="Ruby版本管理"><a href="#Ruby版本管理" class="headerlink" title="Ruby版本管理"></a>Ruby版本管理</h4><h5 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h5><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> gpg --keyserver hkp:<span class="comment">//keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB</span></span><br><span class="line"><span class="symbol">$</span> \curl -sSL https:<span class="comment">//get.rvm.io | bash -s stable</span></span><br></pre></td></tr></table></figure><p>由于国内Ruby服务器访问速度太慢，建议使用Ruby China的<a href="https://gems.ruby-china.org/" target="_blank" rel="noopener">镜像服务器</a>,这样就可以提高依赖包的下载速度。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources --<span class="built_in">add</span> http<span class="variable">s:</span>//gems.<span class="keyword">ruby</span>-china.org/ --<span class="built_in">remove</span> http<span class="variable">s:</span>//rubygems.org/</span><br><span class="line">$ gem sources -<span class="keyword">l</span></span><br><span class="line">http<span class="variable">s:</span>//gems.<span class="keyword">ruby</span>-china.org</span><br><span class="line"># 确保只有 gems.<span class="keyword">ruby</span>-china.org</span><br></pre></td></tr></table></figure></p><p>如果你使用 Gemfile 和 Bundler (例如：Rails 项目)<br>你可以用 Bundler 的 Gem 源代码镜像命令:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bundle config mirror<span class="selector-class">.https</span>:<span class="comment">//rubygems.org https://gems.ruby-china.org</span></span><br></pre></td></tr></table></figure></p><p>这样你不用改你的 Gemfile 的 source:<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">source</span> <span class="string">'https://rubygems.org/'</span></span><br><span class="line">gem <span class="string">'rails'</span>, <span class="string">'4.2.5'</span></span><br><span class="line"><span class="keyword">...</span></span><br></pre></td></tr></table></figure></p><h5 id="2-列出已知的-Ruby-版本"><a href="#2-列出已知的-Ruby-版本" class="headerlink" title="2. 列出已知的 Ruby 版本"></a>2. 列出已知的 Ruby 版本</h5><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rvm <span class="built_in">list</span> known</span><br></pre></td></tr></table></figure><h5 id="3-安装一个-Ruby-版本"><a href="#3-安装一个-Ruby-版本" class="headerlink" title="3. 安装一个 Ruby 版本"></a>3. 安装一个 Ruby 版本</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rvm <span class="keyword">install</span> &lt;ruby-<span class="keyword">version</span>&gt;</span><br></pre></td></tr></table></figure><h5 id="4-切换-Ruby-版本"><a href="#4-切换-Ruby-版本" class="headerlink" title="4. 切换 Ruby 版本"></a>4. 切换 Ruby 版本</h5><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rvm <span class="meta"><span class="meta-keyword">use</span> &lt;ruby-version&gt;</span></span><br></pre></td></tr></table></figure><h5 id="5-设为默认版本"><a href="#5-设为默认版本" class="headerlink" title="5. 设为默认版本"></a>5. 设为默认版本</h5><p>如果想设置为默认版本，这样一来以后新打开的控制台默认的 Ruby 就是这个版本<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rvm <span class="keyword">use</span> &lt;ruby-<span class="keyword">version</span>&gt; <span class="comment">--default</span></span><br></pre></td></tr></table></figure></p><h5 id="6-查询已经安装的Ruby"><a href="#6-查询已经安装的Ruby" class="headerlink" title="6. 查询已经安装的Ruby"></a>6. 查询已经安装的Ruby</h5><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rvm <span class="built_in">list</span></span><br></pre></td></tr></table></figure><h5 id="7-卸载一个已安装版本"><a href="#7-卸载一个已安装版本" class="headerlink" title="7. 卸载一个已安装版本"></a>7. 卸载一个已安装版本</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rvm <span class="builtin-name">remove</span> &lt;ruby-version&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在使用fastlane来实现项目的自动化，发现这套工具是用Ruby这门语言写的，为了了解Ruby的一些环境配置，这里做个笔记，来记录关于Ruby遇到的一些问题。&lt;/p&gt;
&lt;h4 id=&quot;一些基本概念&quot;&gt;&lt;a href=&quot;#一些基本概念&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="Others" scheme="https://yuxingxin.com/categories/Others/"/>
    
    
      <category term="Ruby" scheme="https://yuxingxin.com/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>Git使用过程中的一些常见场景问题总结</title>
    <link href="https://yuxingxin.com/2017/12/11/GitScenes/"/>
    <id>https://yuxingxin.com/2017/12/11/GitScenes/</id>
    <published>2017-12-10T16:00:00.000Z</published>
    <updated>2019-06-10T03:05:25.439Z</updated>
    
    <content type="html"><![CDATA[<p>之前在公司内部推Git，写了一份<a href="https://devops.yuxingxin.com" target="_blank" rel="noopener">git使用教程</a>，后来又在团队内部做了一次分享，内容是关于Git使用过程中经常会遇到的一些场景，并有了这份总结。</p><h3 id="git基础"><a href="#git基础" class="headerlink" title="git基础"></a>git基础</h3><p>基于feature的工作流</p><ul><li>添加忽略文件   .gitignore (<a href="http://gitignore.io/" target="_blank" rel="noopener">http://gitignore.io/</a>)</li><li>基于develop分支开发：feature分支   bugfix分支   版本节点tag</li><li>问题排查: diff 、log  、reflog、blame</li><li>撤销操作: checkout  、reset、revert、commit –amend</li><li>删除操作: rm  clean</li><li>储藏操作: stash</li><li>分支操作：创建、删除（注意远程分支的删除）、切换、合并（–no-ff 、rebase）</li><li>标签操作</li></ul><p>更多详细查看上面教程链接</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><h4 id="1-本地已经存在的项目-分支与如何远程仓库关联"><a href="#1-本地已经存在的项目-分支与如何远程仓库关联" class="headerlink" title="1. 本地已经存在的项目/分支与如何远程仓库关联"></a>1. 本地已经存在的项目/分支与如何远程仓库关联</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> origin &lt;your-repo-git-url&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-刚刚提交了的commit-log发现错了，想修改"><a href="#2-刚刚提交了的commit-log发现错了，想修改" class="headerlink" title="2. 刚刚提交了的commit log发现错了，想修改"></a>2. 刚刚提交了的commit log发现错了，想修改</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">commit</span> <span class="comment">--amend -m "your new log"</span></span><br></pre></td></tr></table></figure><h4 id="3-查看某次提交的日志和ID"><a href="#3-查看某次提交的日志和ID" class="headerlink" title="3. 查看某次提交的日志和ID"></a>3. 查看某次提交的日志和ID</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git reflog</span></span><br></pre></td></tr></table></figure><h4 id="4-查看某次提交的内容"><a href="#4-查看某次提交的内容" class="headerlink" title="4. 查看某次提交的内容"></a>4. 查看某次提交的内容</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show <span class="tag">&lt;<span class="name">commit_id</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-只是修改了工作区的文件，想恢复到原来修改前的样子"><a href="#5-只是修改了工作区的文件，想恢复到原来修改前的样子" class="headerlink" title="5. 只是修改了工作区的文件，想恢复到原来修改前的样子"></a>5. 只是修改了工作区的文件，想恢复到原来修改前的样子</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">reset</span> <span class="comment">--hard HEAD</span></span><br><span class="line">git checkout <span class="comment">-- &lt;file_name&gt;</span></span><br></pre></td></tr></table></figure><h4 id="6-被修改的文件已经添加到了暂存区，想撤销添加"><a href="#6-被修改的文件已经添加到了暂存区，想撤销添加" class="headerlink" title="6. 被修改的文件已经添加到了暂存区，想撤销添加"></a>6. 被修改的文件已经添加到了暂存区，想撤销添加</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">reset</span> <span class="comment">--mixed HEAD</span></span><br></pre></td></tr></table></figure><h4 id="7-被修改的文件已经commit提交，想撤销提交"><a href="#7-被修改的文件已经commit提交，想撤销提交" class="headerlink" title="7. 被修改的文件已经commit提交，想撤销提交"></a>7. 被修改的文件已经commit提交，想撤销提交</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">reset</span> <span class="comment">--soft HEAD^</span></span><br></pre></td></tr></table></figure><h4 id="8-已经提交到远程主机的文件，想撤销"><a href="#8-已经提交到远程主机的文件，想撤销" class="headerlink" title="8. 已经提交到远程主机的文件，想撤销"></a>8. 已经提交到远程主机的文件，想撤销</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">revert </span>&lt;commit_id&gt;</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">revert </span>HEAD</span><br></pre></td></tr></table></figure><h4 id="9-已经开发一半的功能，但是没有开发完，这时候有个bug要紧急处理，需要放下手头的功能，赶去修改BUG"><a href="#9-已经开发一半的功能，但是没有开发完，这时候有个bug要紧急处理，需要放下手头的功能，赶去修改BUG" class="headerlink" title="9. 已经开发一半的功能，但是没有开发完，这时候有个bug要紧急处理，需要放下手头的功能，赶去修改BUG"></a>9. 已经开发一半的功能，但是没有开发完，这时候有个bug要紧急处理，需要放下手头的功能，赶去修改BUG</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存现场</span></span><br><span class="line">git stash  </span><br><span class="line"><span class="comment">// 恢复现场</span></span><br><span class="line">git stash <span class="keyword">pop</span></span><br></pre></td></tr></table></figure><h4 id="10-加入过历史版本的文件，因某些原因被删除了想恢复"><a href="#10-加入过历史版本的文件，因某些原因被删除了想恢复" class="headerlink" title="10. 加入过历史版本的文件，因某些原因被删除了想恢复"></a>10. 加入过历史版本的文件，因某些原因被删除了想恢复</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="tag">&lt;<span class="name">commit_id</span>&gt;</span> -- <span class="tag">&lt;<span class="name">file_name</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外你也可以用reset命令来完成</p><h4 id="11-需要单独把多次提交中的某一次提交从你的分支迁移到另外一个分支上，即跨分支应用commit"><a href="#11-需要单独把多次提交中的某一次提交从你的分支迁移到另外一个分支上，即跨分支应用commit" class="headerlink" title="11. 需要单独把多次提交中的某一次提交从你的分支迁移到另外一个分支上，即跨分支应用commit"></a>11. 需要单独把多次提交中的某一次提交从你的分支迁移到另外一个分支上，即跨分支应用commit</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick <span class="tag">&lt;<span class="name">commit_id</span>&gt;</span></span><br></pre></td></tr></table></figure><p>比如：我想把以下分支<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A-B  <span class="literal">master</span></span><br><span class="line">   \</span><br><span class="line">    C-D-E-F-G develop</span><br></pre></td></tr></table></figure></p><p>中的D，F 两次提交移动到master分支，而保持其他commit不变，结果就像这样<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A-B-D-F  <span class="literal">master</span></span><br><span class="line">       \</span><br><span class="line">        C-E-G develop</span><br></pre></td></tr></table></figure></p><p>那么，思路是将D，F 用cherry-pick应用到master分支上，然后将develop分支对master分支变基。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master  </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git cherry-pick D  </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git cherry-pick F  </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout develop  </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rebase master</span></span><br></pre></td></tr></table></figure></p><p>注意有些情况下使用cherry-pick会存在冲突，解决方法和我们平时合并分支遇到冲突一样。</p><h4 id="12-遇到文件冲突，可以手动解决，或者用你配置的工具解决，记得把文件标位resolved：add-rm"><a href="#12-遇到文件冲突，可以手动解决，或者用你配置的工具解决，记得把文件标位resolved：add-rm" class="headerlink" title="12. 遇到文件冲突，可以手动解决，或者用你配置的工具解决，记得把文件标位resolved：add/rm"></a>12. 遇到文件冲突，可以手动解决，或者用你配置的工具解决，记得把文件标位resolved：add/rm</h4><p>如：常见的拉取同事的代码合并引起冲突<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 手动处理冲突</span><br><span class="line"><span class="number">2.</span> 文件标志位置为resolved：git <span class="built_in">add</span> &lt;file_name&gt;</span><br><span class="line"><span class="number">3.</span> 继续合并  git <span class="built_in">merge</span> <span class="comment">--continue</span></span><br><span class="line">当然也可以选择放弃合并：git <span class="built_in">merge</span> <span class="comment">--abort</span></span><br></pre></td></tr></table></figure></p><h4 id="13-让自己本地分支上面的每一次提交日志变得更有意义，有时候需要我们选择有意义的提交日志信息合并上去"><a href="#13-让自己本地分支上面的每一次提交日志变得更有意义，有时候需要我们选择有意义的提交日志信息合并上去" class="headerlink" title="13. 让自己本地分支上面的每一次提交日志变得更有意义，有时候需要我们选择有意义的提交日志信息合并上去"></a>13. 让自己本地分支上面的每一次提交日志变得更有意义，有时候需要我们选择有意义的提交日志信息合并上去</h4><p>比如我们在bugfix分支上面由于修改bug提交了很多次，修复好了之后，我们想把这些提交合并入我们的master分支<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="literal">master</span></span><br><span class="line">git merge --squash bugfix</span><br><span class="line">git commit -m <span class="string">"bug fixed"</span></span><br></pre></td></tr></table></figure></p><p>上面操作会将bugfix分支上的所有commit都合并为一个commit，并把它并入我们的master分支上去。这里还有一点需要注意的是：–squash含义代表的是本地内容与不使用该选项的合并结果相同，但是不提交，不移动HEAD指针，所以我们要另外多一条语句来移动我们的HEAD指针，即最后的commit。</p><h4 id="14-有时候需要整理我们本地的commits，可以使用Squash"><a href="#14-有时候需要整理我们本地的commits，可以使用Squash" class="headerlink" title="14. 有时候需要整理我们本地的commits，可以使用Squash"></a>14. 有时候需要整理我们本地的commits，可以使用Squash</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -<span class="selector-tag">i</span> &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~<span class="number">5</span></span><br><span class="line"></span><br><span class="line">执行完后，Git会把所有commit列出来，让你进行一些修改，修改完成之后会根据你的修改来rebase。HEAD-5的意思是只修改最近的<span class="number">5</span>个commit。</span><br><span class="line"></span><br><span class="line">pick <span class="number">033</span>beb4 <span class="keyword">b1</span></span><br><span class="line"><span class="keyword">pick </span><span class="keyword">b426a8a </span><span class="keyword">b2</span></span><br><span class="line"><span class="keyword">pick </span>c216era <span class="keyword">b3</span></span><br><span class="line"><span class="keyword">pick </span>d627c9a <span class="keyword">b4</span></span><br><span class="line"><span class="keyword">pick </span>e416c<span class="number">8b</span> <span class="keyword">b5</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"># </span>Rebase <span class="number">033</span>beb4..e416c<span class="number">8b</span> onto <span class="number">033</span>beb4</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment">#  p, pick = use commit</span></span><br><span class="line"><span class="comment">#  r, reword = use commit, but edit the commit message</span></span><br><span class="line"><span class="comment">#  e, edit = use commit, but stop for amending</span></span><br><span class="line"><span class="comment">#  s, squash = use commit, but meld into previous commit</span></span><br><span class="line"><span class="comment">#  f, fixup = like "squash", but discard this commit's log message</span></span><br><span class="line"><span class="comment">#  x, exec = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="line"><span class="comment"># However, if you remove everything, the rebase will be aborted.</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure><p>上面pick是要执行的commit指令，另外还有reword、edit、squash、fixup、exec这5个，具体的含义可以看上面的注释解释，比较简单，这里就不说了。<br>我们要合并就需要修改前面的pick指令：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">pick</span> <span class="number">033</span>beb4 <span class="keyword">b1</span></span><br><span class="line"><span class="keyword">squash </span><span class="keyword">b426a8a </span><span class="keyword">b2</span></span><br><span class="line"><span class="keyword">squash </span>c216era <span class="keyword">b3</span></span><br><span class="line"><span class="keyword">squash </span>d627c9a <span class="keyword">b4</span></span><br><span class="line"><span class="keyword">squash </span>e416c8b <span class="keyword">b5</span></span><br></pre></td></tr></table></figure><p>也就是下面这4个提交合并到最前面的那个提交里面，按esc，打上:wq提交保存离开。<br>接着是输入新的commit message</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">b</span><br><span class="line"><span class="meta">#</span><span class="bash"> This is a combination of 2 commits.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The first commit<span class="string">'s message is:</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> b1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is the 2nd commit message:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> b2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is the 3rd commit message:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> b3</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is the 4th commit message:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> b4</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is the 5th commit message:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> b5</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Please enter the commit message <span class="keyword">for</span> your changes. Lines starting</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> with <span class="string">'#'</span> will be ignored, and an empty message aborts the commit.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Not currently on any branch.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> modified:   a.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>其中第一行的b就是需要我们输入的新信息，同样编辑完保存，出现类似下面的信息：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Successfully rebased <span class="keyword">and</span> updated refs/heads/develop.</span><br></pre></td></tr></table></figure><p>最后可以用git log指令来验证commits是不是我们要变成的样子。</p><h4 id="15-多人协作开发项目，想知道某个文件的当前改动情况"><a href="#15-多人协作开发项目，想知道某个文件的当前改动情况" class="headerlink" title="15. 多人协作开发项目，想知道某个文件的当前改动情况"></a>15. 多人协作开发项目，想知道某个文件的当前改动情况</h4><p>通常查问题时想知道某个文件的某部分代码是谁改动的，那么git blame 就派上用场了。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">blame </span>&lt;file_name&gt;</span><br></pre></td></tr></table></figure></p><p>你也可以具体指定到某一行或者某几行代码<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame -L <span class="tag">&lt;<span class="name">start_line</span>&gt;</span>,<span class="tag">&lt;<span class="name">end_line</span>&gt;</span> <span class="tag">&lt;<span class="name">file_name</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="16-执行push命令向多个仓库同时提交代码"><a href="#16-执行push命令向多个仓库同时提交代码" class="headerlink" title="16. 执行push命令向多个仓库同时提交代码"></a>16. 执行push命令向多个仓库同时提交代码</h4><p>有时候会做代码备份，将代码保存在几个不同的Git代码管理平台，这时候就需要用到了</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">修改本地仓库目录下.git/config文件</span><br><span class="line"></span><br><span class="line">[core]</span><br><span class="line"><span class="attr">repositoryformatversion</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">filemode</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">bare</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">logallrefupdates</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">ignorecase</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">precomposeunicode</span> = <span class="literal">true</span></span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line"><span class="attr">url</span> = git@github.com:yuxingxin/blog.git</span><br><span class="line">    <span class="attr">url</span> = ……</span><br><span class="line">    <span class="attr">url</span> = ……</span><br><span class="line"><span class="attr">fetch</span> = +refs/heads<span class="comment">/*:refs/remotes/origin/*</span></span><br></pre></td></tr></table></figure><p>如上 在remote处可以添加多个远程地址。</p><h4 id="17-从多次提交中快速定位某一次提交的bug"><a href="#17-从多次提交中快速定位某一次提交的bug" class="headerlink" title="17. 从多次提交中快速定位某一次提交的bug"></a>17. 从多次提交中快速定位某一次提交的bug</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开始 bisect</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git bisect start</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 录入正确的 commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git bisect good xxxxxx</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 录入出错的 commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git bisect bad xxxxxx</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后 git 开始在出错的 commit 与正确的 commit 之间开始二分查找，这个过程中你需要不断的验证你的应用是否正常</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git bisect bad</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git bisect good</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git bisect good</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直到定位到出错的 commit，退出 bisect</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git bisect reset</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当然了，git的一些常见场景，还远不止这些，限于本人能力有限，如果你在平时的工作中遇到一些很实用的命令，也欢迎反馈给我，我好一并学习。更多的详细可以参考之前总结的一系列文档: <a href="https://devops.yuxingxin.com。" target="_blank" rel="noopener">https://devops.yuxingxin.com。</a> 学习git命令是一件很有意思的事情，我想它能帮助使用git命令的人更好的理解这一代码管理工具，从而不至于犯一些低级错误，MobDevGroup网站上面也分享过几个学习命令的网站，可以供参考：<a href="https://mobdevgroup.com/tools/assistant" target="_blank" rel="noopener">https://mobdevgroup.com/tools/assistant</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在公司内部推Git，写了一份&lt;a href=&quot;https://devops.yuxingxin.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git使用教程&lt;/a&gt;，后来又在团队内部做了一次分享，内容是关于Git使用过程中经常会遇到的一些场景，
      
    
    </summary>
    
      <category term="Tools" scheme="https://yuxingxin.com/categories/Tools/"/>
    
    
      <category term="Git" scheme="https://yuxingxin.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>西安GDG上关于Architecture Components的Codelab</title>
    <link href="https://yuxingxin.com/2017/11/10/ArchitectureComponentsCodelab/"/>
    <id>https://yuxingxin.com/2017/11/10/ArchitectureComponentsCodelab/</id>
    <published>2017-11-09T16:00:00.000Z</published>
    <updated>2019-06-06T07:09:43.462Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><h4 id="为什么要学习Architecture-Components？"><a href="#为什么要学习Architecture-Components？" class="headerlink" title="为什么要学习Architecture Components？"></a>为什么要学习Architecture Components？</h4><p>Architecture Components是一组构建可健壮的，可测试的，并可维护的Android库，另外，这里也有一份<a href="https://developer.android.com/topic/libraries/architecture/guide.html" target="_blank" rel="noopener">App架构指南</a>，介绍了使用Architecture Components构建App的一套方法。</p><p>通过学习使用Architecture Components，你应用将会写更少的模板代码，并且你也会看到处理与生命周期以及持久化相关的诡异问题的策略方法。</p><h4 id="要做什么？"><a href="#要做什么？" class="headerlink" title="要做什么？"></a>要做什么？</h4><p>在这次的codelab中你将使用不同的组件来构建一个叫做Sunshine的天气应用，它从远程获取数据，存储到本地，并展示给用户。</p><h4 id="构建App的注意事项"><a href="#构建App的注意事项" class="headerlink" title="构建App的注意事项"></a>构建App的注意事项</h4><ul><li>遵循<a href="https://developer.android.com/topic/libraries/architecture/guide.html" target="_blank" rel="noopener">App 架构指南</a>的原则</li><li>使用包含<a href="https://developer.android.com/topic/libraries/architecture/livedata.html" target="_blank" rel="noopener">LiveData</a>和<a href="https://developer.android.com/topic/libraries/architecture/viewmodel.html" target="_blank" rel="noopener">ViewModel</a>的Lifecycle库</li><li>使用<a href="https://developer.android.com/topic/libraries/architecture/room.html" target="_blank" rel="noopener">Room持久化库</a></li><li>从远程获取数据，存储到本地，并以响应式UI的方式展示给用户</li></ul><h4 id="你需要具备的条件"><a href="#你需要具备的条件" class="headerlink" title="你需要具备的条件"></a>你需要具备的条件</h4><ul><li>Android Studio 3.0或更新版本</li><li>熟悉如何构建Android App以及avtivity 生命周期</li><li>基本的SQLite，例如，能够写select语句和where从句</li><li>熟悉线程并会处理Android的异步任务</li></ul><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><h4 id="获取代码"><a href="#获取代码" class="headerlink" title="获取代码"></a>获取代码</h4><ul><li>从<a href="https://drive.google.com/drive/folders/0B3MhUM7KgEEBQXptdF9IYld6Rkk" target="_blank" rel="noopener">这里</a>下载代码</li><li>解压到文件夹</li><li>导入Android Studio 3.0，这可能需要花费几分钟</li></ul><h3 id="介绍Sunshine"><a href="#介绍Sunshine" class="headerlink" title="介绍Sunshine"></a>介绍Sunshine</h3><p>Sunshine是使用Google在优达学城上面的<a href="https://www.udacity.com/course/new-android-fundamentals--ud851" target="_blank" rel="noopener">开发Android应用</a>课程实现的天气应用，在这次的codelab中，你将会学到App代码的骨架，加上Architecture Components库以及<a href="https://developer.android.com/topic/libraries/architecture/guide.html" target="_blank" rel="noopener">App架构指南</a>的架构模式。</p><p>需要注意的地方：</p><ul><li>App应该模块化，每个类负责一个定义好的功能</li><li>不应该有<strong>上帝对象</strong>，即内部引用其他许多类，后者被划分了许多的责任。</li><li>App应该是可测试的。</li></ul><p>我们的App有两屏，一屏展示了14天的天气预报，另外一屏给出某一天详细的天气预报情况</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1flcq5ugu6aj31320wydrb.jpg" alt></p><h4 id="App架构指南"><a href="#App架构指南" class="headerlink" title="App架构指南"></a>App架构指南</h4><p>遵循<a href="https://developer.android.com/topic/libraries/architecture/guide.html" target="_blank" rel="noopener">这里</a>推荐的App架构方式，下面是会涉及到各个类的一张表，如果之前你不熟悉这些组件也不用担心，在这次的codelab中你将会了解它。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fld3nhjibnj30f30d3dgp.jpg" alt></p><p>下面是对上图中不同的类做一个概述：</p><p><strong>UI Controllers</strong>：UI Controllers是activities或者fragments，它的唯一任务是知道如何展示数据以及传递UI事件，例如用户按了一个按钮，UI Controllers既不包含UI数据，也不直接操作数据。</p><p><strong>ViewModels 和 LiveData</strong>：这些类代表着所有需要展示在UI上的数据，你将在这次的codelab中学到如何将这两个类结合在一起。</p><p><strong>Repository</strong>：这个类是我们数据唯一的真实来源，它在和UI交互中扮演着API的角色。ViewModels从repository中请求数据，他们不用关心repository是数据从磁盘加载的还是从网络加载的，再或者如何以及什么时候持久化这些数据，而是repository管理这些。作为这项责任的一部分，repository是不同数据源的一个中介者，当你在这些的codelab中做完一个后你就会学到更多。</p><p><strong>Remote Network Data Source</strong>：管理来自远程的数据，例如网络。</p><p><strong>Model </strong>：管理存储在本地数据库的数据。</p><h3 id="Sunshine之旅"><a href="#Sunshine之旅" class="headerlink" title="Sunshine之旅"></a>Sunshine之旅</h3><p>开始的代码包含两个activity，<code>MainActivity</code>和<code>DetailActivity</code></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1flcqjqee22j31320wuaj3.jpg" alt></p><p><code>DetailActivity</code>是我们要做的第一个Activity，所有需要恰当的展示列表条目属性的UI代码以及图片资源都在起始的工程里面，app还没有连接数据源。</p><p>也可以在<a href="https://github.com/googlecodelabs/android-build-an-app-architecture-components" target="_blank" rel="noopener">README</a>看到找出更多App中的类。</p><h4 id="Sunshine：架构"><a href="#Sunshine：架构" class="headerlink" title="Sunshine：架构"></a>Sunshine：架构</h4><p>快速过一下最终App的架构：</p><p>两个activity（<code>MainActivity</code> 和 <code>DetailActivity</code>），各自的 <a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener"><code>ViewModel</code></a>（<code>MainActivityViewModel</code> 和 <code>DetailActivityViewModel</code>）以及相关的LiveData，他们将会使用一个repository类（SunshineRepository），来管理SQLite数据库和网络数据源之间的通信。<code>WeatherNetworkDataSource</code>使用两个service（<code>SunshineSyncIntentService</code> 和 <code>SunshineFirebaseJobService</code>）从 <a href="https://andfun-weather.udacity.com/weather" target="_blank" rel="noopener">mock weather server</a>请求天气数据，<code>mock weather server</code>返回随机的JSON数据。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fld3o2g5o1j30hw0bl75j.jpg" alt></p><p>上面绿色圈住的是我们需要完成的，让我们先以应用程序的数据库部分开始，并了解ROOM，它是一个针对Android的SQLite对象映射库。</p><h3 id="介绍ROOM"><a href="#介绍ROOM" class="headerlink" title="介绍ROOM"></a>介绍ROOM</h3><h4 id="为什么需要缓存天气数据"><a href="#为什么需要缓存天气数据" class="headerlink" title="为什么需要缓存天气数据"></a>为什么需要缓存天气数据</h4><p>大多数情况下，并不是所有，App都和数据打交道，在Sunshine中，你拥有<code>WeatherEntry</code>对象，表示天气预报的数据，你可以决定每次从Sunshine中创建一个activity，从服务器下载最新的数据，这种方式保证了每个用户都可以看到最新更新的天气，但是效率极低，每次你切屏或者旋转手机，它将会重新请求天气数据，并且大多数次这些数据是不会变化的。另外，如果用户离线了，那么他们就没办法使用你的应用改了。</p><p>这也是大多数App为什么将数据保存在手机的本地数据缓存中的原因，Android提供了本地SQLite 全部支持，所以，SQLite用来做缓存的一种常见的数据库。</p><h4 id="介绍ROOM-1"><a href="#介绍ROOM-1" class="headerlink" title="介绍ROOM"></a>介绍ROOM</h4><h5 id="ROOM的好处"><a href="#ROOM的好处" class="headerlink" title="ROOM的好处"></a>ROOM的好处</h5><p>和SQLite打交道，意味着使用像 <a href="https://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html" target="_blank" rel="noopener"><code>SQLiteOpenHelper</code></a>, <a href="https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html" target="_blank" rel="noopener"><code>SQLiteDatabase</code></a> and <a href="https://developer.android.com/reference/android/database/sqlite/SQLiteQueryBuilder.html" target="_blank" rel="noopener"><code>SQLiteQueryBuilder</code></a>这样的API，尽管他们很强大，但是也仍面临许多开发阶段的挑战，这包含了许多模板代码，无法在编译期间校验SQLite语句的合法性。</p><p>对于Sunshine，你应使用新的SQLite对象映射库， <a href="https://developer.android.com/reference/android/arch/persistence/room/package-summary.html" target="_blank" rel="noopener">Room</a>. <code>Room</code>相比内置的API有许多优点，包含：</p><ul><li>和内置API相比减少了模板代码，尤其是，它将数据库对象映射为Java对象，这意味着你不需要使用<a href="https://developer.android.com/reference/android/content/ContentValues.html" target="_blank" rel="noopener"><code>ContentValues</code></a> or <a href="https://developer.android.com/reference/android/database/Cursor.html" target="_blank" rel="noopener"><code>Cursor</code></a></li><li>编译期间的SQL查询验证，因此不正确的SQL语句将会在编译期间被发现，而不是运行期间。</li><li>通过 <a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html" target="_blank" rel="noopener"><code>LiveData</code></a>(这次codelab你会了解) and <a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a>来允许数据的监听。</li></ul><h5 id="ROOM组件"><a href="#ROOM组件" class="headerlink" title="ROOM组件"></a>ROOM组件</h5><p>Room使用注解来定义数据库结构，它有三大主要组件：</p><ul><li><a href="https://developer.android.com/reference/android/arch/persistence/room/Entity.html" target="_blank" rel="noopener"><strong>@Entity</strong></a>：定义了数据库表结构，Model对象可以容易的转换为Entity对象</li><li><a href="https://developer.android.com/reference/android/arch/persistence/room/Dao.html" target="_blank" rel="noopener"><strong>@DAO</strong></a>：表示一个可以作为数据库访问对象（DAO）的类或者接口，DAO负责定义访问数据库的方法，它们提供读写数据库中数据的API</li><li><a href="https://developer.android.com/reference/android/arch/persistence/room/Database.html" target="_blank" rel="noopener"><strong>@Database</strong></a>：表示数据库持有者，这个类中定义一系列数据库相关的实体和DAO方法，然后你可以使用这个类创建一个新的数据库或者在运行期获取一个数据库连接。</li></ul><h4 id="轮到你了：添加ROOM到Sunshine"><a href="#轮到你了：添加ROOM到Sunshine" class="headerlink" title="轮到你了：添加ROOM到Sunshine"></a>轮到你了：添加ROOM到Sunshine</h4><p>添加ROOM到你的工程</p><ol><li><p>打开项目的<code>build.gradle</code>文件（不是app或者module的），添加如下：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123; url <span class="string">'https://maven.google.com'</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>打开app或者module的<code>build.gradle</code>文件，添加下面依赖：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">implementation</span> "<span class="selector-tag">android</span><span class="selector-class">.arch</span><span class="selector-class">.persistence</span><span class="selector-class">.room</span><span class="selector-pseudo">:runtime</span><span class="selector-pseudo">:1.0.0"</span></span><br><span class="line"><span class="selector-tag">annotationProcessor</span> "<span class="selector-tag">android</span><span class="selector-class">.arch</span><span class="selector-class">.persistence</span><span class="selector-class">.room</span><span class="selector-pseudo">:compiler</span><span class="selector-pseudo">:1.0.0"</span></span><br></pre></td></tr></table></figure></li><li><p>同步gradle</p></li></ol><p>这些依赖提供Room和注解处理器，你将通过它们来创建一个<code>Entity</code>。</p><h3 id="创建一个Entity"><a href="#创建一个Entity" class="headerlink" title="创建一个Entity"></a>创建一个Entity</h3><h4 id="如何创建实例"><a href="#如何创建实例" class="headerlink" title="如何创建实例"></a>如何创建实例</h4><p>要理解如何创建实例，先看一下<a href="https://developer.android.com/topic/libraries/architecture/room.html" target="_blank" rel="noopener">Room documentation</a>的例子，然后将其应用到Sunshine中。</p><p>Room使用注解来为生成的表定义表结构和列约束，假设你想创建下面一张user表：</p><table><thead><tr><th><strong>id </strong>(Primary Key for table)</th><th><strong>firstName</strong></th><th><strong>lastName</strong></th></tr></thead><tbody><tr><td>1</td><td>Florina</td><td>Muntenescu</td></tr><tr><td>2</td><td>Lyla</td><td>Fujiwara</td></tr><tr><td>3</td><td>Yigit</td><td>Boyar</td></tr></tbody></table><p>这是创建表的代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creates a table named users. </span></span><br><span class="line"><span class="comment">// tableName is the property name, users is the value</span></span><br><span class="line"><span class="meta">@Entity</span>(tableName = <span class="string">"users"</span>) </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> &#123;</span></span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="comment">// Denotes id as the primary key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line">    <span class="keyword">public</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Ignore</span> <span class="comment">// Tells Room to ignore this field</span></span><br><span class="line">    Bitmap picture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子中有这样几样东西是需要有的：</p><ul><li>必须使用注解<code>@Entity</code>定义类</li><li>至少有一个字段来作为主键，用<code>@PrimaryKey</code>来标识</li><li>Room需要能访问所有字段，有两种方法可以做到，声明public或者提供getters 和 setters.</li><li>字段需要有某种方法可以转换为能够存储在SQLite中的值，Room为原生和包装替代者提供内置支持，你将在后面了解到 <a href="https://developer.android.com/reference/android/arch/persistence/room/TypeConverter.html" target="_blank" rel="noopener"><code>TypeConverters</code></a>，如果你有不存储到数据库的数据，例如例子中的Bitmap，你可以使用<code>@Ignore</code>注解，来告诉Room来忽略字段或者方法。</li></ul><p>默认情况下，表名会以class名来命名，列名会以字段名来命名，Room也提供了其他的注解和属性来支持，在这个例子中，你可以看到<code>@Entity</code>注解有属性<code>tableName</code>，代表着用<code>users</code>来代替<code>user</code>（类名）作为表名。</p><h4 id="轮到你了：为某一天的天气预报创建实体"><a href="#轮到你了：为某一天的天气预报创建实体" class="headerlink" title="轮到你了：为某一天的天气预报创建实体"></a>轮到你了：为某一天的天气预报创建实体</h4><p>我们的数据库用一张表来存储天气数据：</p><table><thead><tr><th><strong>id </strong>(Primary Key)</th><th><strong>weatherIconId</strong></th><th><strong>date</strong></th><th><strong>min</strong></th><th><strong>max</strong></th><th><strong>humidity</strong></th><th><strong>pressure</strong></th><th><strong>wind</strong></th><th><strong>degrees</strong></th></tr></thead><tbody><tr><td>1</td><td>500</td><td>1502668800000</td><td>13.32</td><td>18.27</td><td>96</td><td>996.68</td><td>1.2</td><td>0</td></tr><tr><td>2</td><td>501</td><td>1502755200000</td><td>12.66</td><td>17.34</td><td>97</td><td>996.12</td><td>4.8</td><td>45</td></tr><tr><td>3</td><td>800</td><td>1502841600000</td><td>12.07</td><td>16.48</td><td>90</td><td>995.7</td><td>8.2</td><td>90</td></tr></tbody></table><p>开始，你需要创建一个对象来存储在表中，starter开始的应用中已经有一个model类<code>WeatherEntry</code>，来看下：</p><p>让<code>data.database.WeatherEntry</code> model转换为Room中的实体：</p><ol><li><p><strong>将<code>WeatherEntry</code>用<code>@Entity</code>注解，并改表名为”weather”</strong>：在WeatherEntry类的正上方，添加<code>@Entity</code>注解，添加<code>tableName</code>属性并设置值为<code>weather</code>，没有这个的话，表名将会是<code>weatherentry</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">Entity</span>(<span class="keyword">tableName</span> = <span class="string">"weather"</span>)</span><br></pre></td></tr></table></figure><p>​</p></li><li><p><strong>定义id为自增主键</strong>：在<code>id</code>字段的上方，添加<code>@PrimaryKey</code>注解，Sunshine代码针对每个<code>WeatherEntry</code>没有一个独一无二的数据库id，因为服务器那边没返回，因此可以让Room帮你做这个，在<code>@PrimaryKey</code>中添加<code>autoGenerate</code>属性并设置其值为<code>true</code></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PrimaryKey</span>(autoGenerate = <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>date字段应该是独一无二的</strong>：因为我们队一个位置只存储天气，因此一天不可能有两个天气预报数据，在<code>@Entity</code>中添加<code>indices</code>属性，值为<code>date</code>列，并且<code>unique</code>应该设置为<code>true</code></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Entity</span>(tableName = <span class="string">"weather"</span>, indices = &#123;<span class="variable">@Index</span>(value = &#123;<span class="string">"date"</span>&#125;, unique = true)&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>让Room可以访问字段</strong>：这种情况，让 <code>WeatherEntry</code> 类只读，Sunshine只下载并展示天气数据，不应该修改天气数据。</p><p>为了实现这个，让字段声明为private，并提供getter方法，另外需要<strong>创建一个额外的构造器</strong>，来允许Room为每一个单独的 <code>WeatherEntry</code>字段设置值，这让Room来构造<code>WeatherEntity</code>，并保护这些已经构造好的字段免于被修改成为了可能。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> WeatherEntry(<span class="built_in">int</span> id, <span class="built_in">int</span> weatherIconId, Date date, <span class="keyword">double</span> <span class="built_in">min</span>, <span class="keyword">double</span> <span class="built_in">max</span>, <span class="keyword">double</span> humidity, <span class="keyword">double</span> pressure, <span class="keyword">double</span> wind, <span class="keyword">double</span> <span class="built_in">degrees</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.weatherIconId = weatherIconId;</span><br><span class="line">    <span class="keyword">this</span>.date = date;</span><br><span class="line">    <span class="keyword">this</span>.<span class="built_in">min</span> = <span class="built_in">min</span>;</span><br><span class="line">    <span class="keyword">this</span>.<span class="built_in">max</span> = <span class="built_in">max</span>;</span><br><span class="line">    <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">    <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">    <span class="keyword">this</span>.wind = wind;</span><br><span class="line">    <span class="keyword">this</span>.<span class="built_in">degrees</span> = <span class="built_in">degrees</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p><strong>只有一个构造器应该暴露给Room</strong>：Room不能用两个构造器编译一个实体，因为他不知道该用哪个，由于Room不需要没有<code>int id</code>的构造器，因此你可以使用<code>@Ignore</code>来让它对Room不可见。</p></li></ol><h3 id="创建一个数据库访问对象"><a href="#创建一个数据库访问对象" class="headerlink" title="创建一个数据库访问对象"></a>创建一个数据库访问对象</h3><h4 id="如何创建一个DAO（数据库访问对象）"><a href="#如何创建一个DAO（数据库访问对象）" class="headerlink" title="如何创建一个DAO（数据库访问对象）"></a>如何创建一个DAO（数据库访问对象）</h4><p>接下来，你将为<code>WeatherEntry</code> 创建一个<code>@Dao</code>，数据库访问对象的简写，DAO可以是定义读写数据库数据操作的抽象类或者接口，看下面这个例子：<code>User.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span> <span class="comment">// Required annotation for Dao to be recognized by Room</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Returns a list of all users in the database</span></span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inserts multiple users</span></span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertAll</span><span class="params">(User... users)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deletes a single user</span></span><br><span class="line">    <span class="meta">@Delete</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DAO需要一个<code>@Dao</code>注解，为了让DAO起作用，你需要声明方法并添加 <code>@Insert</code>,<code>@Delete</code>, <code>@Update</code>和<code>@Query</code>. <code>@Insert</code>, <code>@Delete</code> and <code>@Update</code> 顾名思义，是为创建方法提供方便的注解。</p><p> 例子中的<code>void insertAll(User... users);</code>展示了如何插入多个Users，这个方法接受多个User对象或者数组来插入数据库。</p><p>正如你看到的，你可以传递User实体对象作为一个参数或者从一个Dao方法中返回一个User实体 对象，你可以用任何实体类做这个。</p><h4 id="带参的-Query"><a href="#带参的-Query" class="headerlink" title="带参的@Query"></a>带参的@Query</h4><p>如果你想做的事情在上面的三个方便的注解里面没有，那就使用<code>@Query</code>, <code>@Query</code> 让你写SQLite来读写数据库操作，尤其是，你可以通过在查询字符串中添加冒号<code>：</code>使用注解将参数传递到方法里，例如：你定义一个方法是通过名字查用户的，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Query("<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> first_name <span class="keyword">LIKE</span> :<span class="keyword">first</span> <span class="keyword">AND</span> <span class="string">"</span></span><br><span class="line"><span class="string">           + "</span>last_name <span class="keyword">LIKE</span> :<span class="keyword">last</span> <span class="keyword">LIMIT</span> <span class="number">1</span><span class="string">")</span></span><br><span class="line"><span class="string">User findByName(String first, String last);</span></span><br></pre></td></tr></table></figure><p>第一个和最后一个参数作为<code>:first</code>和<code>:last</code>被包含在查询字符串中，因此你可以这样调用方法：<code>findByName(&quot;Jane&quot;, &quot;Doe&quot;)</code>,查询语句会被调用<code>SELECT * FROM user WHERE first_name LIKE Jane AND last_name LIKE Doe LIMIT 1</code>并返回自动转成User对象的一列数据。</p><h4 id="轮到你了：为WeatherEntry创建DAO"><a href="#轮到你了：为WeatherEntry创建DAO" class="headerlink" title="轮到你了：为WeatherEntry创建DAO"></a>轮到你了：为WeatherEntry创建DAO</h4><p>创建一个叫做<code>WeatherDao</code>的DAO类，步骤如下：</p><ol><li><p><code>data.database</code>包下（包同 <code>WeatherEntry</code>)，新建一个叫做<code>WeatherDao.java</code>的接口</p></li><li><p>给接口<code>WeatherDao</code>添加 <code>@Dao</code>注解</p></li><li><p>定义<code>bulkInsert</code>方法，它可以插入多个<code>WeatherEntry</code>对象，当App从服务器接收到数据时，它会用这个方法将接收到的数据插入数据库</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bulkInsert</span><span class="params">(WeatherEntry... weather)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>另外,对于 <code>bulkInsert</code>,你应使用 <a href="https://developer.android.com/reference/android/arch/persistence/room/OnConflictStrategy.html#REPLACE" target="_blank" rel="noopener"><strong>OnConflictStrategy.REPLACE</strong></a> ，以至于当Sunshine重新下载天气数据时，旧的数据可以被新的数据替代，你可以使用一个注解的属性来做这个：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">Insert</span>(<span class="keyword">onConflict</span> = OnConflictStrategy.REPLACE)</span><br></pre></td></tr></table></figure></li><li><p>定义<code>getWeatherByDate</code>方法，传递<code>Java.util.Date</code>参数并返回天气数据，出于查询的目的，<code>Date</code>不能转换成字符串<code>String</code>值，接下来你将了解到类型转换，现在知道有一种方法让Room自动将<code>Date</code>转成<code>long</code>，假设你可以使用<code>Date</code>参数作为<code>long</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Query("<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> weather <span class="keyword">WHERE</span> <span class="built_in">date</span> = :<span class="built_in">date</span><span class="string">")</span></span><br><span class="line"><span class="string">WeatherEntry getWeatherByDate(Date date);</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><h4 id="如何创建一个数据库"><a href="#如何创建一个数据库" class="headerlink" title="如何创建一个数据库"></a>如何创建一个数据库</h4><p>你已经有了<code>@Entity</code>和<code>@Dao</code>，现在是时候创建<code>@Database</code>类了，下面这个例子使用User实体：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database</span>(entities = &#123;<span class="type">User</span>.<span class="keyword">class</span>&#125;, version = <span class="number">1</span>) <span class="comment">//Entities listed here</span></span><br><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AppDatabase</span> <span class="keyword">extends</span> <span class="title">RoomDatabase</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">abstract</span> <span class="type">UserDao</span> userDao(); <span class="comment">//Getters for Dao</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要创建数据库，你需要：</p><ul><li>继承<strong>RoomDatabase</strong>类</li><li>添加<code>@Database</code>注解，并使用<code>entities</code> 和 <code>version</code>属性，<code>entities</code> 需要列出你所有的实体类， <code>version</code>是数据库版本号</li><li>针对每一个Dao定义一个方法返回Dao对象：用这种方式来暴露你的Dao,来处理app数据库中的数据。</li></ul><p>生成数据库的代码如下：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">AppDatabase database</span> = Room.databaseBuilder(getApplicationContext(),</span><br><span class="line">        AppDatabase.class, <span class="string">"database-name"</span>).build();</span><br></pre></td></tr></table></figure><p>有多个数据库实例容易引起数据一致性问题，例如，你可以在用一个实例读数据库的同时，并用另外一个实例来写数据库，为了保证只创建一个<code>RoomDatabase</code>实例，你的数据库类应该被设计成单例。</p><p>为了在数据库上执行查询，你将通过调用<code>RoomDatabase</code>的子类里的方法来访问DAO：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List<span class="variable">&lt;User&gt;</span> <span class="literal">all</span>Users = database.<span class="keyword">user</span>Dao().getAll();</span><br></pre></td></tr></table></figure><h4 id="轮到你了：创建Sunshine数据库"><a href="#轮到你了：创建Sunshine数据库" class="headerlink" title="轮到你了：创建Sunshine数据库"></a>轮到你了：创建Sunshine数据库</h4><p>要创建Sunshine数据库需要完成下面步骤：</p><ol><li><p>在<code>data.database</code>包下新建<code>SunshineDatabase.java</code>类。</p></li><li><p>让<code>SunshineDatabase</code>声明为抽象类，并继承<code>RoomDatabase</code>。</p></li><li><p>用<code>@Database</code>来注解。</p></li><li><p>添加属性<code>entities</code> 和 <code>version</code>到注解<code>@Database</code>上，并将<code>WeatherEntry.class</code>作为属性<code>entities</code> 的值，属性 <code>version</code>的值设为1。</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@Database</span>(entities = &#123;WeatherEntry.<span class="keyword">class</span>&#125;, <span class="keyword">version</span> = <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>给WeatherDao添加抽象方法：定义一个名为weatherDao的方法并返回一个<code>WeatherDao</code>的实例。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function">WeatherDao <span class="title">weatherDao</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>让<code>SunshineDatabase</code>实现为单例模式：你可以查看<code>WeatherNetworkDataSource</code> 这个类中的实现，它是另外一个只允许一个实例运行的类，创建一个<code>SunshineDatabase</code> 类型的静态变量，叫做<code>sInstance</code>，另外还有一个锁对象来保证线程安全，创建一个叫做<code>getInstance</code>的实例方法，返回<code>sInstance</code>，如果存在就返回，不存在就创建，代码如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> DATABASE_NAME = <span class="string">"weather"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For Singleton instantiation</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Object</span> LOCK = <span class="keyword">new</span> <span class="keyword">Object</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SunshineDatabase sInstance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SunshineDatabase getInstance(Context context) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">           <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sInstance = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class="line">                    SunshineDatabase.class, SunshineDatabase.DATABASE_NAME).build();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据库是一个抽象类，继承于<strong>RoomDatabase</strong>，注解为 <strong>@Database</strong>, 定义了<strong>entities</strong>.,并且为每个DAO提供了抽象的getter方法，当然它也是一个单例。</p></li></ol><h4 id="TypeConverters"><a href="#TypeConverters" class="headerlink" title="TypeConverters"></a>TypeConverters</h4><p> <code>WeatherEntry</code> 类有一个 <code>java.util.Date</code>对象，但是你不能将其存储在数据库中，那是因为<a href="https://sqlite.org/datatype3.html" target="_blank" rel="noopener">SQLite没有Date这样一个数据类型</a>,要将其转换为能存储到库中的类型，你需要一个TypeConverter.</p><p>要完成Java类型和SQLite支持的类型转换，你需要通过注解定一个方法：</p><ul><li>新建一个包含TypeConverter的类</li><li>在这个类中，将方法用 <code>@TypeConverter</code>注解</li><li>用转换类添加注解 <code>@TypeConverters</code> 到你的数据库类中</li></ul><h4 id="轮到你了：实现一个TypeConverter"><a href="#轮到你了：实现一个TypeConverter" class="headerlink" title="轮到你了：实现一个TypeConverter"></a>轮到你了：实现一个TypeConverter</h4><ol><li><p>去掉<code>data.database.DateConverter.java</code>类的注释,代码已经在类中写好了，它包含两个注解有 <code>@TypeConverter</code>的方法，来实现Date类型到long类型和long类型到Date类型的转换</p></li><li><p>添加 <code>@TypeConverters</code>到<code>SunshineDatebase</code>类中:你需要让<code>SunshineDatebase</code>知道转换类，如下:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database</span>(entities = &#123;<span class="type">WeatherEntry</span>.<span class="keyword">class</span>&#125;, version = <span class="number">1</span>)</span><br><span class="line"><span class="meta">@TypeConverters</span>(<span class="type">DateConverter</span>.<span class="keyword">class</span>)</span><br><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SunshineDatabase</span> <span class="keyword">extends</span> <span class="title">RoomDatabase</span> </span>&#123; ...</span><br></pre></td></tr></table></figure></li><li><p>运行代码保证没有错误</p></li></ol><h4 id="轮到你了：Room编译期验证"><a href="#轮到你了：Room编译期验证" class="headerlink" title="轮到你了：Room编译期验证"></a>轮到你了：Room编译期验证</h4><p>现在你已经把DAO加入到数据库中了，你可以看到Room一个强大的功能：编译期对SQLite代码的验证。</p><ol><li><p>修改<code>WeatherDAO</code>中的<code>getWeatherByDate</code>方法，刻意的造成一个拼写错误，将<code>date = :date</code>写成</p><p><code>date = :data</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Query("<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> weather <span class="keyword">WHERE</span> <span class="keyword">data</span> = :<span class="built_in">date</span><span class="string">")</span></span><br><span class="line"><span class="string">WeatherEntry getWeatherByDate(Date date);</span></span><br></pre></td></tr></table></figure></li><li><p>运行你的代码：App跑不起来，你将会看到下面一条错误的帮助信息：</p><p><img src="https://codelabs.developers.google.com/codelabs/build-app-with-arch-components/img/29ad49e42863c706.png" alt></p></li></ol><h3 id="介绍LiveData和ViewModels"><a href="#介绍LiveData和ViewModels" class="headerlink" title="介绍LiveData和ViewModels"></a>介绍LiveData和ViewModels</h3><h3 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来</h3><p>你已经创建了一个数据库以及DAO来访问该库，现在要做的是创建<code>DetailActivityViewModel</code> and <code>LiveData</code>.</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fld3ok40atj30ia0bnmyd.jpg" alt></p><h4 id="ViewModels"><a href="#ViewModels" class="headerlink" title="ViewModels"></a>ViewModels</h4><p>ViewModel是设计用来以生命周期的方式来持有和管理和UI相关的数据。这允许数据在屏幕旋转等配置更改中依然可以保存。通过从UI controllers中分离出UI数据，你可以实现责任的分离：ViewModels处理提供，操作和存储UI状态，而UI Controllers处理状态的展示。</p><p>ViewModels通常与给他们提供的数据的UI控制器相关联，通过使用 <a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner.html" target="_blank" rel="noopener">LifecycleOwner</a>和 <a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.html" target="_blank" rel="noopener">Lifecycle</a> 类来实现:</p><ul><li><a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.html" target="_blank" rel="noopener">Lifecycle</a> - 定义Android生命周期的对象</li><li><a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner.html" target="_blank" rel="noopener">LifecycleOwner</a> - 拥有生命周期的对象，如UI Controller </li></ul><p>当你获得一个ViewModel时，你需要用<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner.html" target="_blank" rel="noopener"><code>LifecycleOwner</code></a>提供一个组件，它通常是activity或者fragment，通过提供<code>LifecycleOwner</code>，你建立了ViewModel和LifecycleOwner之前的联系。</p><h4 id="ViewModel生命周期"><a href="#ViewModel生命周期" class="headerlink" title="ViewModel生命周期"></a>ViewModel生命周期</h4><p>ViewModel和它相关的UI 控制器有着不同的生命周期作用域。这是因为UI控制器会在配置发生变化时销毁和重建，而ViewModels并不会。</p><p>下图展示了当activity创建，旋转，然后销毁掉时，ViewModel生命周期和activity声明周期做的对比。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fld3oubuwkj30b50e7gms.jpg" alt></p><p>ViewModel一直会存在直到activity销毁掉，想更进一步的讨论和了解ViewModel，可以参考在<a href="https://medium.com/google-developers/viewmodels-a-simple-example-ed5ac416317e" target="_blank" rel="noopener">这篇博文</a></p><p>ViewModels通常包含LiveData对象，稍后我们会讨论它。</p><h4 id="该你了：DetailActivityViewModel"><a href="#该你了：DetailActivityViewModel" class="headerlink" title="该你了：DetailActivityViewModel"></a>该你了：DetailActivityViewModel</h4><p>这个部分通过去掉注释和拷贝代码来看下<code>ViewModel</code>，<code>activity</code>，以及<code>LiveData</code>之间是如何工作的。</p><p><code>DetailActivity</code>展示了一天的天气预报，这有一个与它相关联的UI状态数据：<code>WeatherEntry</code></p><ol><li><p>打开app或module的<code>build.gradle</code>文件，添加下面依赖：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">implementation</span> "<span class="selector-tag">android</span><span class="selector-class">.arch</span><span class="selector-class">.lifecycle</span><span class="selector-pseudo">:runtime</span><span class="selector-pseudo">:1.0.3"</span></span><br><span class="line"><span class="selector-tag">implementation</span> "<span class="selector-tag">android</span><span class="selector-class">.arch</span><span class="selector-class">.lifecycle</span><span class="selector-pseudo">:extensions</span><span class="selector-pseudo">:1.0.0"</span></span><br><span class="line"><span class="selector-tag">annotationProcessor</span> "<span class="selector-tag">android</span><span class="selector-class">.arch</span><span class="selector-class">.lifecycle</span><span class="selector-pseudo">:compiler</span><span class="selector-pseudo">:1.0.0"</span></span><br></pre></td></tr></table></figure></li><li><p>同步gradle</p></li><li><p>打开<code>ui.detail.DetailActivityViewModel</code>去掉整个文件的注释，如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DetailActivityViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Weather forecast the user is looking at</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">WeatherEntry</span> mWeather;</span><br><span class="line"></span><br><span class="line">   public <span class="type">DetailActivityViewModel</span>() &#123;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public <span class="type">WeatherEntry</span> getWeather() &#123;</span><br><span class="line">       <span class="keyword">return</span> mWeather;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void setWeather(<span class="type">WeatherEntry</span> weatherEntry) &#123;</span><br><span class="line">       mWeather = weatherEntry;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类继承自ViewModel，来给到ViewModel的生命周期作用域。单个<code>WeatherEntry</code>对象包含了所有需要在<code>DetailActivity</code>中展示的数据。</p></li><li><p>打开<code>ui.detail.DetailActivity</code>，让其继承于<code>AppCompatActivity.</code>  </p><blockquote><p>1.0.0稳定版本，已经将Lifecycle组件移入support库，我们可以直接继承v7包中的AppCompatActivity</p></blockquote></li><li><p><code>DetailActivity</code> 中添加一个类型为<code>DetailActivityViewModel</code>，变量名为 <code>mViewModel</code>的变量</p></li><li><p>添加下面代码到<code>DetailActivity</code>的<code>onCreate</code>方法中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mViewModel = ViewModelProviders.of(<span class="keyword">this</span>).<span class="keyword">get</span>(DetailActivityViewModel.<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注意这里在后面引入Repository后有变化</p></blockquote><p>通过在<code>onCreate</code>方法中调用 <a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModelProviders.html#of%28android.support.v4.app.Fragment%29" target="_blank" rel="noopener"><code>ViewModelProviders.of</code></a>来创建一个<code>DetailActivityViewModel</code>实例。</p><p>然后当配置发生变化时，activity重建， <a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModelProviders.html#of%28android.support.v4.app.Fragment%29" target="_blank" rel="noopener"><code>ViewModelProviders.of</code></a>再次被<code>onCreate</code>调用,这次它返回之前存在的和<code>DetailActivity</code>相关联的<code>ViewModel</code>实例</p><p>你这时候可以调用<code>mViewModel.getWeather()</code>来访问数据，无论配置如何变化都会将其保存起来。</p><p>当你将ViewModels和LiveData结合起来会得到更多好处。</p></li></ol><h4 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h4><p><code>LiveData</code>是一个生命周期感知的数据持有类，它持有值并让其可以被监听。</p><p>说它可以持有数据，如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MutableLiveData&lt;<span class="keyword">String</span>&gt; name = <span class="keyword">new</span> <span class="type">MutableLiveData</span>&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">name.setValue(<span class="string">"Lyla"</span>);</span><br></pre></td></tr></table></figure><p>这是一个持有<code>String</code>类型的<code>LiveData</code>实例，当前值为<code>Lyla</code></p><p><strong>Observation</strong>参考自观察者模式，也叫主体，有一系列相关联的对象，叫做观察者，当主题的状态发生变化时，它会通知所有的观察者，通常是调用他们的方法。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fld3p4hyk5j30ft093jru.jpg" alt></p><p>上面这种情况，主体是<code>LiveData</code>，观察者是<a href="https://developer.android.com/reference/android/arch/lifecycle/Observer.html" target="_blank" rel="noopener"><code>Observer</code></a>的子类，无论何时<code>setValue</code>方法被调用，主体状态发生了改变，都会触发<code>Observers</code>。</p><p>LiveData持有一系列相关的观察者和<code>LifecycleOwner</code>s,<code>LifecycleOwner</code>s通常是activity或者fragment，大部分情况下，与他们相关联的<code>LifecycleOwner</code>只要在当前屏幕下，这些<code>Observers</code>就被认为是处于活跃状态，即<code>STARTED</code>或者是<code>RESUMED</code>状态。LiveData追踪<code>LifecycleOwner</code>s这样的一个事实也是<code>LiveData</code>被称作感知生命周期的原因。</p><p>为<code>LiveData</code>创建一个<code>Observers</code>的一般方法是：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name.observe(&lt;LIFECYCLE OWNER&gt;, <span class="keyword">new</span><span class="type">Name</span> -&gt; &#123;</span><br><span class="line">   <span class="comment">// Do something when the observer is triggered; usually updating the UI</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> <code>LifecycleOwner</code>被传进observe方法，这也是与<code>Observer</code>相关联的 <code>LifecycleOwner</code></p><h4 id="轮到你了：添加LiveData"><a href="#轮到你了：添加LiveData" class="headerlink" title="轮到你了：添加LiveData"></a>轮到你了：添加LiveData</h4><p><code>DetailActivity</code>将监听一个<code>MutableLiveData</code>，这个<code>MutableLiveData</code>将会持有<code>WeatherEntry</code>对象，当MutableLiveData通过<code>postValue()</code>方法更新时，<code>DetailActivity</code>的<code>Observer</code>将会被通知到.然后<code>DetailActivity</code>将会更新UI</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fld3pcw1uuj30cv0bt0tf.jpg" alt></p><p>创建你的第一个<code>LiveData</code></p><ol><li><p>在<code>DetailActivityViewModel</code>文件中，修改<code>mWeather</code>,将其从<code>WeatherEntry</code>类型变为<code>MutableLiveData&lt;WeatherEntry&gt;</code>，Mutable LiveData会改变。</p></li><li><p>在<code>DetailActivityViewModel</code>文件中，在构造器初始化你新建的<code>MutableLiveData&lt;WeatherEntry&gt;</code>对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DetailActivityViewModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mWeather = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>DetailActivityViewModel</code>文件中，更新<code>mWeather</code>的getter方法，让其返回新的<code>MutableLiveData</code>对象</p></li><li><p>在<code>DetailActivityViewModel</code>文件中，修改<code>setWeather()</code>方法体为<code>mWeather.postValue(weatherEntry);</code></p></li><li><p>在<code>DetailActivity</code>的<code>onCreate</code>方法中，监听<code>LiveData</code></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mViewModel</span><span class="selector-class">.getWeather</span>()<span class="selector-class">.observe</span>(this, weatherEntry -&gt; &#123;</span><br><span class="line">   <span class="comment">// Update the UI</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>在新的观察者中，更新不同的UI元素，这有一个<code>bindWeatherToUI()</code>方法通过传入<code>WeatherEntry</code>来做这件事情</p><p>最后一步意思是无论何时<code>mViewModel.setWeather()</code>被调用，<code>MutableLiveData</code>的<code>postValue</code>方法也会被调用，<code>postValue</code>触发所有的观察者监听LiveData，这种情况下，只有一个观察者监听LiveData，也是你刚刚创建的用来更新<code>DetailActivity</code>UI 那一个。</p><p>简而言之，当<code>DetailActivityViewModel</code>的<code>setValue</code>方法被调用后，它将会触发UI更新。</p><blockquote><p>注意LiveData和它的子类都包含一个<code>setValue</code>方法和一个<code>postValue()</code>方法，不同是<code>setValue</code>方法只能用在主线程中，而<code>postValue()</code>则不用，它可以在子线程中使用</p></blockquote></li></ol><h3 id="介绍Repositories"><a href="#介绍Repositories" class="headerlink" title="介绍Repositories"></a>介绍Repositories</h3><p>我们已经介绍了Room,ViewModel,LiveData,但是还没有看到他们如何协同工作。UI是完全与刚刚创建的网络和数据库相隔离的，现在我们要做的是如何将网络与数据库数据暴露给UI，这就是<strong>repository</strong>的工作。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fld3plaug1j30i90begmt.jpg" alt></p><h4 id="Repository类"><a href="#Repository类" class="headerlink" title="Repository类"></a><strong>Repository</strong>类</h4><p><strong>Repository</strong>负责处理数据操作。他们为应用提供简洁的rest API ，知道数据是从哪里来的并且当数据更新时也知道该调用什么接口。他们是不同数据源的中介器（持久化model，web服务，缓存等等）</p><p>不像Room,LiveData或者ViewModels，Repository类不继承或实现任何一个Architecture Components库的组件。这是一种在你的App中组织数据的简单方式，可以看<a href="https://developer.android.com/topic/libraries/architecture/guide.html" target="_blank" rel="noopener">这里</a>的介绍.</p><p>在这种情况下，Repository类将会管理你新建的<code>WeatherDao</code>之间的通信，这些DAO可以访问数据库的所有东西， <code>WeatherNetworkDataSource</code>通过控制Service类来从我们的mock server上拉取数据。</p><p>Repository类是唯一与数据库和网络包通信的类，数据和网络包将不与他们各自包外的类通信。因此Repository类将会是获取数据来展示屏幕上的UI API。</p><h4 id="惯用思路"><a href="#惯用思路" class="headerlink" title="惯用思路"></a>惯用思路</h4><p>通过下载天气数据并保存在数据库中，将涉及的几个类一起协同工作，每个执行不同的功能：</p><p><strong>SunshineRepository</strong>： 协调所有与数据相关的指令，代理给<code>WeatherNetworkDataSource</code>和<code>WeatherDao</code>，监听<code>WeatherNetworkDataSource</code>，当它获取完数据时，就知道该更新数据库了。</p><p><strong>WeatherNetworkDataSource</strong>：执行所有的网络操作。为最近下载的网络数据提供最真实的数据。通过包含存储有最新下载的数据的LiveData对象，无论何时成功请求到数据，它都会被更新。</p><p><strong>SunshineSyncIntentService</strong>：使用<code>IntentService</code>来执行同步操作，以至于应用关闭时，服务器有额外的时间来下载完数据并保存在数据库中。</p><p><strong>WeatherDao</strong>：用来在weather表中执行所有的数据库操作。</p><p>下面是网络同步被触发的四个部分：</p><p><strong>Observation</strong></p><ol><li><p><strong>SunshineRepository</strong>:监听<code>WeatherNetworkDataSource</code>提供的LiveData对象。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fld3pycwesj30g806ot92.jpg" alt></p></li></ol><p><strong>开启服务</strong></p><ol><li><p><strong>SunshineRepository</strong>：检查是否有足够的数据</p></li><li><p><strong>WeatherNetworkDataSource</strong>：创建并立即执行<code>SunshineSyncIntentService</code></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fld3q5ccmzj30i005a0t0.jpg" alt></p></li></ol><p><strong>请求数据</strong></p><ol><li><p><strong>SunshineSyncIntentService</strong>：获取<code>WeatherNetworkDataSource</code>实例，并用它来开启数据请求。</p></li><li><p><strong>WeatherNetworkDataSource</strong>：获取数据后传递给<code>OpenWeatherJsonParser</code> 和 <code>NetworkUtils</code>. 一旦完成，将更新的数据传递给存储最新数据的LiveData</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fld3qedmqqj30in07474q.jpg" alt></p></li></ol><p><strong>保存数据库</strong></p><ol><li><p>最后由于<strong>SunshineRepository</strong>是一直在监听<code>LiveData</code>,因此<code>SunshineRepository</code> 将会更新数据库</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fld3qlj4yqj30iy06z3z0.jpg" alt></p></li></ol><h3 id="创建Repository来获取并存储数据"><a href="#创建Repository来获取并存储数据" class="headerlink" title="创建Repository来获取并存储数据"></a>创建Repository来获取并存储数据</h3><h4 id="轮到你了：创建Repository"><a href="#轮到你了：创建Repository" class="headerlink" title="轮到你了：创建Repository"></a>轮到你了：创建Repository</h4><ol><li><p>你无须拷贝和粘贴，这里已经有了一个<code>SunshineRepository.java</code>文件，去掉代码注释，它包含有：</p><p>一个<code>getInstance()</code>的构造器方法，就像SunshineDatabase一样，<code>SunshineRepository</code> 也是一个单例。</p><p>几个空方法：<code>initializeData(), deleteOldData(), isFetchNeeded()</code> 和 <code>startFetchWeatherService()</code></p></li></ol><h4 id="轮到你了：创建LiveData"><a href="#轮到你了：创建LiveData" class="headerlink" title="轮到你了：创建LiveData"></a>轮到你了：创建LiveData</h4><p>你将使用LiveData来存储最新在网络上下载的数据。</p><ol><li><p>在<code>WeatherNetworkDataSource</code>文件中，创建一个 <code>MutableLiveData</code>的成员变量，叫做<code>mDownloadedWeatherForecasts</code>. 它应该被声明为private，存储一个<code>WeatherEntry</code> 类型的数组对象，这也是数据同步操作返回的。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LiveData storing the latest downloaded weather forecasts</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MutableLiveData&lt;WeatherEntry[]&gt; mDownloadedWeatherForecasts;</span><br></pre></td></tr></table></figure></li><li><p>在<code>WeatherNetworkDataSource</code>构造器中，初始化<code>mDownloadedWeatherForecasts</code></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mDownloadedWeatherForecasts</span> = new MutableLiveData&lt;WeatherEntry[]&gt;()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>WeatherNetworkDataSource</code>文件中,为<code>mDownloadedWeatherForecasts</code>创建一个getter方法，叫做<code>getCurrentWeatherForecasts</code>.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> LiveData&lt;WeatherEntry[]&gt; getCurrentWeatherForecasts() &#123;</span><br><span class="line">    <span class="keyword">return</span> mDownloadedWeatherForecasts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="轮到你了：开启服务"><a href="#轮到你了：开启服务" class="headerlink" title="轮到你了：开启服务"></a>轮到你了：开启服务</h4><p>现在是时候开启<code>IntentService</code>了：</p><ol><li><p>在<code>SunshineRepository</code>中，完成<code>startFetchWeatherService()</code>方法，让它调用<code>WeatherNetworkDataSource</code>中的<code>startFetchWeatherService()</code>方法，并创建开启<code>IntentService</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startFetchWeatherService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mWeatherNetworkDataSource.startFetchWeatherService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>SunshineRepository</code>中,添加<code>initalizeData()</code>方法。当 <code>ViewModel</code>获取数据时<code>initalizeData()</code>方法会被调用。现在，调用<code>startFetchWeatherService()</code>方法。在将来你还需要添加是否有必要开启同步的验证。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">initializeData</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only perform initialization once per app lifetime. If initialization has already been</span></span><br><span class="line">    <span class="comment">// performed, we have nothing to do in this method.</span></span><br><span class="line">    <span class="keyword">if</span> (mInitialized) <span class="keyword">return</span>;</span><br><span class="line">    mInitialized = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    startFetchWeatherService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="轮到你了：完成获取数据的逻辑"><a href="#轮到你了：完成获取数据的逻辑" class="headerlink" title="轮到你了：完成获取数据的逻辑"></a>轮到你了：完成获取数据的逻辑</h4><p>现在你有一个service在跑，让其获取数据并存储在<code>mDownloadedWeatherForecasts</code>中</p><ol><li><p>在<code>InjectorUtils</code>中，去掉<code>provideRepository()</code>和<code>provideNetworkDataSource()</code>的注释，<code>InjectorUtils</code>的目的是提供依赖注入的静态方法。</p></li><li><p>在<code>SunshineSyncIntentService</code>文件中，方法 <code>onHandleIntent()</code>中调用 <code>InjectorUtils.provideNetworkDataSource()</code>来得到<code>WeatherNetworkDataSource</code>的引用</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    Log.d(LOG_TAG, <span class="string">"Intent service started"</span>);</span><br><span class="line">    WeatherNetworkDataSource networkDataSource = InjectorUtils.provideNetworkDataSource(<span class="keyword">this</span>.getApplicationContext());</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>SunshineSyncIntentService</code>文件中，方法 <code>onHandleIntent()</code>中调用 <code>InjectorUtils.fetchWeather()</code>方法：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">networkDataSource.fetchWeather()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>在 <code>WeatherNetworkDataSource</code>调用方法 <code>fetchWeather()</code>的结尾处，用最新的天气数据来更新<code>mDownloadedWeatherForecasts</code> 持有的值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mDownloadedWeatherForecasts</span><span class="selector-class">.postValue</span>(<span class="selector-tag">response</span><span class="selector-class">.getWeatherForecast</span>());</span><br></pre></td></tr></table></figure></li></ol><p>轮到你了：监听LiveData</p><p>当<code>initalizeData()</code>被调用后，它开启一系列连锁事件，执行<code>SunshineSyncIntentService</code>来保存结果数据到<code>mDownloadedWeatherForecasts</code> 中，最后一步是让<code>SunshineRepository</code> 监听<code>mDownloadedWeatherForecasts</code>并更新数据库。</p><ol><li><p>在<code>SunshineRepository</code>类的构造函数中获取到<code>mDownloadedWeatherForecasts</code>,用你之前写的 <code>getCurrentWeatherForecasts</code> 方法获取，这个和在activity中用getter来从ViewModel中获取一个LiveData很像。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LiveData&lt;WeatherEntry[]&gt; networkData = mWeatherNetworkDataSource.getCurrentWeatherForecasts()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>SunshineRepository</code>类中监听<code>mDownloadedWeatherForecasts</code>。在<code>SunshineRepository</code>类的构造函数中使用<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html#observeForever(android.arch.lifecycle.Observer%3CT%3E" target="_blank" rel="noopener"><code>observeForever</code></a>) 方法来监听 <code>mDownloadedWeatherForecasts</code>.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">networkData</span><span class="selector-class">.observeForever</span>(<span class="selector-tag">newForecastsFromNetwork</span> <span class="selector-tag">-</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>当<code>mDownloadedWeatherForecasts</code>发生改变时，触发数据库保存数据。在<code>SunshineRepository</code>的观察者中调用 <code>WeatherDao</code>‘s <code>bulkInsert()</code>方法。注意数据库操作不要在主线程操作。使用<code>AppExecutor</code>‘的disk I/O来提供合适的线程。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">networkData.observeForever(<span class="keyword">new</span><span class="type">ForecastsFromNetwork</span> -&gt; &#123;</span><br><span class="line">        mExecutors.diskIO().execute(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// Insert our new weather data into Sunshine's database</span></span><br><span class="line">            mWeatherDao.bulkInsert(<span class="keyword">new</span><span class="type">ForecastsFromNetwork</span>);</span><br><span class="line">            Log.d(LOG_TAG, <span class="string">"New values inserted"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果你这时候想运行代码，在 <code>DetailActivity</code>‘s <code>onCreate</code>:中调用：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// THIS IS JUST TO RUN THE CODE; REPOSITORY SHOULD NEVER BE CREATED IN</span></span><br><span class="line"><span class="comment">// DETAILACTIVITY</span></span><br><span class="line">InjectorUtils.provideRepository(this).initializeData();</span><br></pre></td></tr></table></figure><p>当第一次运行时你会看到下面输出的日志：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fld3qwnyqqj30ha07btdf.jpg" alt></p><p>注意<code>DetailActivity</code>并不是一个和 <code>SunshineRepository</code>打交道的地方。activity和其他UI控制器都不应该直接和repository交互，那是ViewModel的工作。接下来你会看到。</p><blockquote><p>为什么使用<code>observeForever()</code>?</p><p><code>observeForever()</code>和observe很像，一个主要的区别是。他总是被认为处于活跃状态，因为，它不携带有生命周期 的对象。那么为什么在这使用它呢？<code>SunshineRepository</code> 在一直监听 <code>WeatherNetworkDataSource</code>，这些都和UI控制的声明周期无关，而且，他们存在于整个app的声明周期中，因此，你可以安全的使用<code>observeForever()</code></p></blockquote></li></ol><h3 id="展示数据"><a href="#展示数据" class="headerlink" title="展示数据"></a>展示数据</h3><p>当你与服务器同步，由于监听的作用，你的repository会自动的更新你的数据库，现在你需要将你的ViewModel从repository中获取天气数据。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fld3r3f2xej30ih0bimyf.jpg" alt></p><h4 id="轮到你了：通过日期来暴露出WeatherEntry"><a href="#轮到你了：通过日期来暴露出WeatherEntry" class="headerlink" title="轮到你了：通过日期来暴露出WeatherEntry"></a>轮到你了：通过日期来暴露出WeatherEntry</h4><p> <code>DetailActivityViewModel</code> 需要来自数据库的数据，顾名思义，它需要一天的天气信息来作为LiveData对象，在<code>WeatherDao</code>中，你有一个返回<code>WeatherEntry</code>对象的方法<code>getWeatherByDate()</code>.这样几乎是完美的。</p><p>Room里有一个非常方便的功能，当你想有一个和数据库保持同步的livedata对象，Room可以返回livedata包装对象。数据库数据改变时，LiveData可以触发它的观察者，在子线程中加载数据库的数据。</p><p>从Room获取LiveData:</p><ol><li><p>在<code>WeatherDao</code>中，更新<strong>getWeatherbyDate()</strong>让其返回<strong>LiveData<weatherentry>.</weatherentry></strong></p><p>原本可以让 <code>DetailActivityViewModel</code>直接与 <code>WeahterDao</code>.通信，但是这违背了之前说的让repository作为其唯一数据来源，因此<code>DetailActivityViewModel</code>应该从<code>SunshineRepository</code>.中获取数据，<code>SunshineRepository</code>反过来调用<code>WeatherDao</code>来获取<code>LiveData</code></p></li><li><p>在<code>SunshineRepository</code>中，添加<strong>getWeatherbyDate()</strong>方法，该方法需穿进去Date对象，返回一个<code>LiveData&lt;WeatherEntry&gt;</code>.它将用存储在<code>SunshineRepository</code>中的<code>WeatherDao</code>对象来获取LiveData对象。</p></li><li><p>在<code>SunshineRepository</code>的<code>getWeatherByDate</code>方法中调用<code>initializeData()</code>,您将对数据进行“懒”实例化。即当</p></li></ol><p>被请求时，才会从网络中加载，这也展示了repository中有用的一面：由于它是所有数据请求的API。你要保证每次请求 <code>getWeatherByDate()</code>方法，数据初始化都会被触发。如果你能直接访问<code>WeatherDao</code>，这将是不可能的。</p><p>你可以更改 <code>initalizeData()</code>方法的修饰符为<code>private</code>，这是因为它只在repository中使用。</p><h4 id="ViewModelProvider-Factories"><a href="#ViewModelProvider-Factories" class="headerlink" title="ViewModelProvider Factories"></a>ViewModelProvider Factories</h4><p>接下来你需要使用repository来获取数据。这有一个问题，<code>ViewModel</code>还没有<code>SunshineRepository</code>的引用</p><p>一种可测试的代码设计方法是传递一个<code>SunshineRepository</code>的实例到<code>DetailActivityViewModel</code> 中，这将会在你测试view model的时候让你很容易的mock repository。</p><p>被 <code>ViewModelProvider</code>自动调用的构造器是默认的那一个，他没有参数，如果你想为View model创建一个不同的构造器，你需要创建一个View model provider factory。去掉<code>DetailViewModelFactory</code>中的代码注释：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DetailViewModelFactory</span> <span class="keyword">extends</span> <span class="title">ViewModelProvider</span>.<span class="title">NewInstanceFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">SunshineRepository</span> mRepository;</span><br><span class="line"></span><br><span class="line">   public <span class="type">DetailViewModelFactory</span>(<span class="type">SunshineRepository</span> repository) &#123;</span><br><span class="line">       <span class="keyword">this</span>.mRepository = repository;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   public &lt;<span class="type">T</span> <span class="keyword">extends</span> <span class="type">ViewModel</span>&gt; <span class="type">T</span> create(<span class="type">Class</span>&lt;<span class="type">T</span>&gt; modelClass) &#123;</span><br><span class="line">       <span class="comment">//noinspection unchecked</span></span><br><span class="line">       <span class="keyword">return</span> (<span class="type">T</span>) <span class="keyword">new</span> <span class="type">DetailActivityViewModel</span>(mRepository);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要创建一个View model provider factory，你需要：</p><ol><li>继承 <code>ViewModelProvider.NewInstanceFactory</code></li><li>将你想要的参数传进<code>DetailViewModelFactory</code>中，当前是传Repository</li><li>重写<code>create()</code>方法，来调用你自定义的view model构造器</li></ol><p>然后使用factory：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the ViewModel from the factory</span></span><br><span class="line">DetailViewModelFactory <span class="keyword">factory</span> = <span class="keyword">new</span> DetailViewModelFactory(repository);</span><br><span class="line"></span><br><span class="line">mViewModel = ViewModelProviders.of(<span class="keyword">this</span>, <span class="keyword">factory</span>).<span class="keyword">get</span>(DetailActivityViewModel.<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure><h4 id="轮到你了：创建DetailViewModelFactory"><a href="#轮到你了：创建DetailViewModelFactory" class="headerlink" title="轮到你了：创建DetailViewModelFactory"></a>轮到你了：创建DetailViewModelFactory</h4><p>写完了<code>DetailViewModelFactory</code>,使用 <code>InjectorUtils</code> 来创建它。骨架代码已经给你了，但你还需要将Date和repository一起传递进去。</p><ol><li><p>在 <code>DetailActivityViewModel</code>中修改构造器，让其传递两个参数：<code>SunshineRepository</code> 和<code>java.util.Date</code>:</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DetailActivityViewModel(SunshineRepository repository, <span class="built_in">Date</span> <span class="built_in">date</span>)</span><br></pre></td></tr></table></figure></li><li><p>如果你还没有做的话，去掉 <code>DetailViewModelFactory</code>骨干代码的注释</p></li><li><p>在 <code>DetailViewModelFactory</code>中，添加向构造函数传递日期的能力。使用你在repository中传递的作为其引用。</p></li><li><p>在 <code>InjectorUtils</code>中，去掉注释 <code>provideDetailViewModelFactory</code>，构造器的声明需要与新添加的参数匹配</p></li><li><p>在 <code>DetailActivity</code> ‘s <code>onCreate()</code>中用下面代码创建今天日期：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Date</span> <span class="keyword">date</span> = SunshineDateUtils.getNormalizedUtcDateForToday();</span><br></pre></td></tr></table></figure></li><li><p>在 <code>DetailActivity</code>中使用<code>InjectorUtils.provideDetailViewModelFactory()</code>获取 <code>DetailViewModelFactory</code>的引用。</p></li><li><p><code>DetailActivity</code>中，使用 <code>DetailViewModelFactory</code> 来获取View model</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ViewModelProviders.of(<span class="keyword">this</span>, <span class="keyword">factory</span>).<span class="keyword">get</span>(DetailActivityViewModel.<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure></li></ol><h4 id="轮到你了：通过日期获取WeatherEntry"><a href="#轮到你了：通过日期获取WeatherEntry" class="headerlink" title="轮到你了：通过日期获取WeatherEntry"></a>轮到你了：通过日期获取WeatherEntry</h4><p>现在你可以访问<code>Date</code>和 <code>SunshineRepository</code>了:</p><ol><li>在 <code>DetailActivityViewModel</code>中，使用date从repository中获取weather entry LiveData,</li><li>清理代码，需要做的几件事情：<ul><li>第一，view model中的LiveDate将不再被app所修改，因此将<code>MutableLiveData</code>改为<code>`LiveData</code>.</li><li>同样，移除setWeather方法，你已经不再需要它了</li><li>在<code>DetailActivity</code>中，移除模拟网络请求的代码<code>thread.sleep()</code></li><li>如果在activity中仍旧有 <code>initalizeData</code>的调用或者直接和<code>SunshineRepository</code>,的通信，则移除它。</li></ul></li><li>运行你的代码你将会看到随机的天气数据</li></ol><h3 id="正确的获取"><a href="#正确的获取" class="headerlink" title="正确的获取"></a>正确的获取</h3><p>Sunshine现在已经完成了从网络中加载数据，保存在数据库，并展示它。在开始下一个新功能前先解决两个低效的问题：</p><ol><li><code>DetailActivityViewModel</code>每次创建时都会重新查询网络，在你开启<code>SunshineSyncIntentService</code>之前，你应该检测本地缓存中是否有，毕竟，本地缓存的目的是避免不必要地重新下载数据。这也展示了sunshinerepository是如何协调应用程序中的数据流-一个完整的同步包括检查DAO是否有数据，如果没有，执行网络同步，然后更新DAO。</li><li>该应用程序不是用来显示历史气象数据的，只有未来的天气数据。是的，这里还没有删除旧数据的过程！如果你的用户喜欢Sunshine并使用它一年了，那么将有365个的无用的历史气象数据存储在用户的手机上。</li></ol><h4 id="轮到你了：需要时再获取"><a href="#轮到你了：需要时再获取" class="headerlink" title="轮到你了：需要时再获取"></a>轮到你了：需要时再获取</h4><p>这有许多不同的方法来决定是否要下载数据，对于Sunshine，如下：</p><ol><li>计算数据库中当前日期过去的天数</li><li>如果少于两周（14天），则下载更多的数据</li></ol><p>我们使用两周的原因是两周是我们想展示在 <code>MainActivity</code>中的数量，这是接下来主要做的事情，为了实现它：</p><ol><li><p>在WeatherDao中，声明方法<code>countAllFutureWeather</code>，这是一个使用 <code>SQL COUNTd</code>的查询方法，来获取一张未来天气日期的列表清单。</p></li><li><p>在<code>SunshineRepository</code>中完成<code>isFetchNeeded()</code>方法，这里应该检查是否至少有14天，如果少于14天就返回true</p></li><li><p>在<code>SunshineRepository</code>中<code>nitalizeData()</code>方法中，使用<code>isFetchNeeded()</code>方法来决定是否开启<code>SunshineSyncIntentService</code> ,你将会在disk I/O线程中这样做：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mExecutors.diskIO().execute(<span class="function"><span class="params">()</span> -&gt;</span> &#123;<span class="regexp">//</span>CODE ON DISK I/O THREAD HERE&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>您现在应该注意到，当您第一次运行该应用程序后重新打开该应用程序时，它将不会捕获新的随机气象数据。</p><h4 id="轮到你了：删除旧数据"><a href="#轮到你了：删除旧数据" class="headerlink" title="轮到你了：删除旧数据"></a>轮到你了：删除旧数据</h4><p>现在删除过时的数据：</p><ol><li><p>在weatherDao中，声明方法<code>deleteOldData()</code>,这个方法应该删除所有给定日期之前的日期，虽然名称包含“删除”，但仍希望使用<code>@Query</code>注解，而不是<code>@Delete</code>注解，这是因为你需要写SQL语句来定义where从句</p></li><li><p>在<code>SunshineRepository</code>中，完善<code>deleteOldData()</code>方法，你需要为<code>deleteOldData()</code>获取到当前日期，你可以 使用<code>isFetchNeeded()</code>中相同的代码：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Date today</span> = SunshineDateUtils.getNormalizedUtcDateForToday();</span><br></pre></td></tr></table></figure></li><li><p>在<code>SunshineRepository</code>网络数据观察者中，在插入新的数据之前调用 <code>deleteOldData()</code>删除旧的天气数据。</p></li></ol><p>这将在您保存到数据库时删除所有旧数据。因为App使用 <code>OnConflictReplace</code>策略来保证日期的唯一。如果它获得新的天气信息，它也会更新数据库中已有的信息。</p><h3 id="接下来我们可以按照同样的方法来完善MainActivity模块，这个留给大家做了。"><a href="#接下来我们可以按照同样的方法来完善MainActivity模块，这个留给大家做了。" class="headerlink" title="接下来我们可以按照同样的方法来完善MainActivity模块，这个留给大家做了。"></a>接下来我们可以按照同样的方法来完善MainActivity模块，这个留给大家做了。</h3><h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><ol><li>起始工程：<a href="https://github.com/yuxingxin/Architecture-Components-App" target="_blank" rel="noopener">https://github.com/yuxingxin/Architecture-Components-App</a></li><li>完整代码参考：<a href="https://github.com/yuxingxin/Architecture-Component-App-Finished" target="_blank" rel="noopener">https://github.com/yuxingxin/Architecture-Component-App-Finished</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h3&gt;&lt;h4 id=&quot;为什么要学习Architecture-Components？&quot;&gt;&lt;a href=&quot;#为什么要学习Architecture-Comp
      
    
    </summary>
    
      <category term="Android" scheme="https://yuxingxin.com/categories/Android/"/>
    
    
      <category term="Architecture Components" scheme="https://yuxingxin.com/tags/Architecture-Components/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio 和Gradle Plugin 3.0 迁移不完全指南</title>
    <link href="https://yuxingxin.com/2017/11/03/Migrate-Android-Studio-3-guide/"/>
    <id>https://yuxingxin.com/2017/11/03/Migrate-Android-Studio-3-guide/</id>
    <published>2017-11-02T16:00:00.000Z</published>
    <updated>2019-03-15T03:44:41.635Z</updated>
    
    <content type="html"><![CDATA[<p>Android Studio 3.0 默认Gradle版本为4.1，如果你需要手动升级版本的话，记得修改gradle/wrapper/gradle-wrapper.properties文件的URL地址：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distributionUrl=https\<span class="symbol">://services</span>.gradle.org/distributions/gradle-<span class="number">4.1</span>-all.zip</span><br></pre></td></tr></table></figure><p>对应的Gradle插件版本为3.0.0，手动修改的话，需要修改项目级的build.gradle文件：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// You need to add the following repository to download the</span></span><br><span class="line">        <span class="comment">// new plugin.</span></span><br><span class="line">        google()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">'com.android.tools.build:gradle:3.0.0'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面记得添加google这个repository，某些官方依赖需要下载</p><p>对应我们的构建工具buildToolsVersion版本为26.0.2，对应Module级项目build.gradle文件：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">26</span></span><br><span class="line">    ...</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用变体感知（variant-aware）依赖管理机制"><a href="#使用变体感知（variant-aware）依赖管理机制" class="headerlink" title="使用变体感知（variant-aware）依赖管理机制"></a>使用变体感知（variant-aware）依赖管理机制</h2><p>Android 3.0的插件使用一种新的依赖机制，这种机制能自动的匹配我们项目中依赖库的变体，即app变体debug会自动消费它所依赖的library的debug变体。当然了，我们在给产品定制不同的风味时，它依然能够适用。所以呢为了保证能够准确的匹配这些变体，我们需要为所有的产品风味声明风味维度（flavor dimensions），以及不可能直接匹配的需要我们提供matching fallbacks（PS：不知道怎么翻译了…）</p><p>好了，上面说了那么多”废话”，其实只是想说明一点，如果你项目中用了build type 或者product flavor一种或一种以上， 那么你就需要注意了，这里可能需要做相应的适配：</p><h3 id="添加风味维度的声明"><a href="#添加风味维度的声明" class="headerlink" title="添加风味维度的声明"></a>添加风味维度的声明</h3><p>当我们在配置文件中配置产品风味的时候，现在需要声明风味维度，然后在每个产品风味中指定你前面所声明的某一个风味维度，如下：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//定义两个风味维度</span><br><span class="line">flavorDimensions <span class="string">"api"</span>, <span class="string">"mode"</span></span><br><span class="line"></span><br><span class="line">productFlavors &#123;</span><br><span class="line">    demo &#123;</span><br><span class="line">        //指定风味维度</span><br><span class="line">        dimension <span class="string">"mode"</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    full &#123;</span><br><span class="line">        dimension <span class="string">"mode"</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    minApi24 &#123;</span><br><span class="line">        dimension <span class="string">"api"</span></span><br><span class="line">        minSDKVersion <span class="string">'24'</span></span><br><span class="line">        versionNameSuffix <span class="string">"-minApi24"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    minApi23 &#123;</span><br><span class="line">        dimension <span class="string">"api"</span></span><br><span class="line">        minSDKVersion <span class="string">'23'</span></span><br><span class="line">        versionNameSuffix <span class="string">"-minApi23"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    minApi21 &#123;</span><br><span class="line">        dimension <span class="string">"api"</span></span><br><span class="line">        minSDKVersion <span class="string">'21'</span></span><br><span class="line">        versionNameSuffix <span class="string">"-minApi21"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，配置完后，Gradle创建的构建变体数量等于每个风味维度中的风味数量与你配置的构建类型数量的乘积，在 Gradle 为每个构建变体或对应 APK 命名时，属于较高优先级风味维度的产品风味首先显示，之后是较低优先级维度的产品风味，再之后是构建类型。以上面的构建配置为例，Gradle 可以使用以下命名方案创建总共 12 个构建变体：<br>构建变体：[minApi24, minApi23, minApi21][Demo, Full][Debug, Release]<br>对应 APK：app-[minApi24, minApi23, minApi21]-[demo, full]-[debug, release].apk<br>例如构建变体：minApi24DemoDebug，对应 APK：app-minApi24-demo-debug.apk<br>当然如果有些特定的变体不是你需要的，你也可以过滤：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">    <span class="function"><span class="title">variantFilter</span> &#123; variant -&gt;</span></span><br><span class="line">        def names = variant.flavors*.<span class="keyword">name</span></span><br><span class="line">        <span class="comment">// To check for a certain build type, use variant.buildType.name == "&lt;buildType&gt;"</span></span><br><span class="line">        <span class="keyword">if</span> (names.<span class="built_in">contains</span>(<span class="string">"minApi21"</span>) &amp;&amp; names.<span class="built_in">contains</span>(<span class="string">"demo"</span>)) &#123;</span><br><span class="line">        <span class="comment">// Gradle ignores any variants that satisfy the conditions above.</span></span><br><span class="line">        setIgnore(<span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果组合多个产品风味，产品风味之间的优先级将由它们所属的风味维度决定。上面所列示的第一个风味维度中的产品风味比第二个维度中的产品风味拥有更高的优先级，以此类推。此外，与属于各个产品风味的源集相比，你为产品风味组合创建的源集拥有更高的优先级。</p><p>如果不同源集包含同一文件的不同版本，Gradle 将按以下优先顺序决定使用哪一个文件（左侧源集替换右侧源集的文件和设置）：</p><p>构建变体 &gt; 构建类型 &gt; 产品风味 &gt; 主源集 &gt; 库依赖项</p><p>如以下优先级顺序：</p><ul><li>src/demoDebug/（构建变体源集）</li><li>src/debug/（构建类型源集）</li><li>src/demo/（产品风味源集）</li><li>src/main/（主源集）</li></ul><p>这里说下源集的概念，Android Studio 按逻辑关系将每个模块的源代码和资源分组称为源集，默认情况下，Android Studio 会创建 main/源集和目录，用于存储要在所有构建变体之间共享的一切资源。然而，我们也可以创建新的源集来控制 Gradle 要为特定的构建类型、产品风味（以及使用风味维度时的产品风味组合）和构建变体编译和打包的确切文件。例如，可以在 main/ 源集中定义基本的功能，使用产品风味源集针对不同的客户更改应用的品牌，或者仅针对使用调试构建类型的构建变体包含特殊的权限和日志记录功能等。</p><ul><li><code>src/main/</code>：此源集包括所有构建变体共用的代码和资源。</li><li><code>src/&lt;buildType&gt;/</code>：创建此源集可加入特定构建类型专用的代码和资源。</li><li><code>src/&lt;productFlavor&gt;/</code>：创建此源集可加入特定产品风味专用的代码和资源。</li><li><code>src/&lt;productFlavorBuildType&gt;/</code>：创建此源集可加入特定构建变体专用的代码和资源。</li></ul><p>配置完后我们可以通过Android Studio窗口右侧Gradle，导航至YourApplication&gt;Tasks&gt;android下双击sourceSets，在Android Studio底部右下角 Gradle Console处查看项目是如何组织源集的</p><h3 id="关于构建类型的配置"><a href="#关于构建类型的配置" class="headerlink" title="关于构建类型的配置"></a>关于构建类型的配置</h3><p>假设App中配置了一个叫做”jniDebug”的构建类型，但是该App所依赖的库中没有配置，这时候当我们构建”jniDebug”的时候，插件就不知道库该使用什么构建类型，这时候就会给报出下面的错误：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Error:</span>Failed to <span class="string">resolve:</span> Could not resolve <span class="string">project :</span>mylibrary.</span><br><span class="line">Required <span class="string">by:</span><span class="string">project :</span>app</span><br></pre></td></tr></table></figure><p>这类问题就是由于上面的依赖管理机制变化导致的，我们可以下面的几种情况来分别解决：</p><h4 id="你的-Module-App-包含了它所依赖的库没有的构建类型"><a href="#你的-Module-App-包含了它所依赖的库没有的构建类型" class="headerlink" title="你的 Module App 包含了它所依赖的库没有的构建类型"></a>你的 Module App 包含了它所依赖的库没有的构建类型</h4><p>例如，我们的App包含了一个jniDebug的构建类型，但是它所依赖的库中没有这个，而是有debug和release这两个构建类型，这时候我们就可以在Module App的build.gradle文件中使用matchingFallbacks 来指定可以替换的匹配项，如下：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        debug &#123;&#125;</span><br><span class="line">        release &#123;&#125;</span><br><span class="line">        jniDebug &#123;</span><br><span class="line">            <span class="comment">// Specifies a sorted list of fallback build types that the</span></span><br><span class="line">            <span class="comment">// plugin should try to use when a dependency does not include a</span></span><br><span class="line">            <span class="comment">// "jniDebug" build type. You may specify as many fallbacks as you</span></span><br><span class="line">            <span class="comment">// like, and the plugin selects the first build type that's</span></span><br><span class="line">            <span class="comment">// available in the dependency.</span></span><br><span class="line">            matchingFallbacks = ['debug', 'release']</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提的是插件会选择matchingFallbacks列表中第一个可用的构建类型来替换匹配项。</p><blockquote><p>注意当依赖的库中包含了Module App没有的构建类型，则不会出现上述问题。</p></blockquote><h4 id="对于一个给定的存在于App和它所依赖的库中的风味维度，我们的主Module-App包含了库中没有的风味"><a href="#对于一个给定的存在于App和它所依赖的库中的风味维度，我们的主Module-App包含了库中没有的风味" class="headerlink" title="对于一个给定的存在于App和它所依赖的库中的风味维度，我们的主Module App包含了库中没有的风味"></a>对于一个给定的存在于App和它所依赖的库中的风味维度，我们的主Module App包含了库中没有的风味</h4><p>例如，主Module App和库中都包含了一个mode的风味维度，我们的App中指定mode维度的是free和paid风味，而库中指定mode维度的是demo和paid风味，这时候我们就可以用`matchingFallbacks 来为App中的free指定可以替换的匹配项。如下：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig&#123;</span><br><span class="line">    <span class="comment">// Do not configure matchingFallbacks in the defaultConfig block.</span></span><br><span class="line">    <span class="comment">// Instead, you must specify fallbacks for a given product flavor in the</span></span><br><span class="line">    <span class="comment">// productFlavors block, as shown below.</span></span><br><span class="line">    &#125;</span><br><span class="line">    flavorDimensions 'mode'</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        paid &#123;</span><br><span class="line">            dimension 'mode'</span><br><span class="line">            <span class="comment">// Because the dependency already includes a "paid" flavor in its</span></span><br><span class="line">            <span class="comment">// "mode" dimension, you don't need to provide a list of fallbacks</span></span><br><span class="line">            <span class="comment">// for the "paid" flavor.</span></span><br><span class="line">        &#125;</span><br><span class="line">        free &#123;</span><br><span class="line">            dimension 'mode'</span><br><span class="line">            <span class="comment">// Specifies a sorted list of fallback flavors that the plugin</span></span><br><span class="line">            <span class="comment">// should try to use when a dependency's matching dimension does</span></span><br><span class="line">            <span class="comment">// not include a "free" flavor. You may specify as many</span></span><br><span class="line">            <span class="comment">// fallbacks as you like, and the plugin selects the first flavor</span></span><br><span class="line">            <span class="comment">// that's available in the dependency's "mode" dimension.</span></span><br><span class="line">            matchingFallbacks = ['demo', 'trial']</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，上述情况中，如果说库中包含了一个主Module App没有的产品风味，则不会出现上述问题。</p><h4 id="库中包含了一个主Module-App没有的风味维度"><a href="#库中包含了一个主Module-App没有的风味维度" class="headerlink" title="库中包含了一个主Module App没有的风味维度"></a>库中包含了一个主Module App没有的风味维度</h4><p>例如，库中声明了一个minApi的风味维度，但是你的App中只有mode维度，因此当你要构建freeDebug这个变种版本的App时，插件就不知道你是想用minApi23Debug还是用minApi25Debug变种版本的库，这时候我们可以在主Module App中的defaultConfig代码块通过配置missingDimensionStrategy来让插件从丢失的维度中指定默认的风味，当然你也可以在productFlavors代码块中覆盖先前的选择，因此每一个风味都可以为丢失的维度指定一个不同的匹配策略。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig&#123;</span><br><span class="line">        <span class="comment">// Specifies a sorted list of flavors that the plugin should try to use from</span></span><br><span class="line">        <span class="comment">// a given dimension. The following tells the plugin that, when encountering</span></span><br><span class="line">        <span class="comment">// a dependency that includes a "minApi" dimension, it should select the</span></span><br><span class="line">        <span class="comment">// "minApi23" flavor. You can include additional flavor names to provide a</span></span><br><span class="line">        <span class="comment">// sorted list of fallbacks for the dimension.</span></span><br><span class="line">        missingDimensionStrategy 'minApi', 'minApi23', 'minApi25'</span><br><span class="line">        <span class="comment">// You should specify a missingDimensionStrategy property for each</span></span><br><span class="line">        <span class="comment">// dimension that exists in a local dependency but not in your app.</span></span><br><span class="line">        missingDimensionStrategy 'abi', 'x86', 'arm64'</span><br><span class="line">    &#125;</span><br><span class="line">    flavorDimensions 'mode'</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        free &#123;</span><br><span class="line">            dimension 'mode'</span><br><span class="line">            <span class="comment">// You can override the default selection at the product flavor</span></span><br><span class="line">            <span class="comment">// level by configuring another missingDimensionStrategy property</span></span><br><span class="line">            <span class="comment">// for the "minApi" dimension.</span></span><br><span class="line">            missingDimensionStrategy 'minApi', 'minApi25', 'minApi23'</span><br><span class="line">        &#125;</span><br><span class="line">        paid &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>值得注意的是，当你的主Module App中包含了一个库中依赖项没有的风味维度时，则不会出现上述问题。例如，当库中依赖项不包含abi这个维度时，freeX86Debug版本将会使用freeDebug版本的依赖。</p></blockquote><h2 id="使用新的依赖配置"><a href="#使用新的依赖配置" class="headerlink" title="使用新的依赖配置"></a>使用新的依赖配置</h2><p>先来看下以前的配置：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">android &#123;...&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="comment">// The 'compile' configuration tells Gradle to add the dependency to the</span></span><br><span class="line">    <span class="comment">// compilation classpath and include it in the final package.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dependency on the "mylibrary" module from this project</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">":mylibrary"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remote binary dependency</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:26.1.0'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Local binary dependency</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面也是我们常见的三种依赖项声明：</p><ol><li>模块依赖项<br>compile project(‘:mylibrary’) 行声明了一个名为“mylibrary”的本地 Android 库模块作为依赖项，并要求构建系统在构建应用时编译并包含该本地模块。</li><li>远程二进制依赖项<br>compile ‘com.android.support:appcompat-v7:26.1.0’ 行会通过指定其 JCenter 坐标，针对 Android 支持库的 26.1.0 版本声明一个依赖项。</li><li>本地二进制依赖项<br>compile fileTree(dir: ‘libs’, include: [‘*.jar’]) 行告诉构建系统在编译类路径和最终的应用软件包中包含 app/libs/ 目录内的任何 JAR 文件。</li></ol><p>先来看下以前配置的关键字：</p><ul><li><p>compile<br>指定编译时依赖项。Gradle 将此配置的依赖项添加到类路径和应用的 APK。这是默认配置。</p></li><li><p>apk<br>指定 Gradle 需要将其与应用的 APK 一起打包的仅运行时依赖项。我们可以将此配置与 JAR 二进制依赖项一起使用，而不能与其他库模块依赖项或 AAR 二进制依赖项一起使用。</p></li><li><p>provided<br>指定 Gradle 不与应用的 APK 一起打包的编译时依赖项。如果运行时无需此依赖项，这将有助于缩减 APK 的大小。我们可以将此配置与 JAR 二进制依赖项一起使用，而不能与其他库模块依赖项或 AAR 二进制依赖项一起使用。</p></li><li><p>使用构建变体或者测试源集的名称配置关键字<br>这种方式可以为特定的构建变体或者测试源集配置依赖项，如：</p></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Adds specific library module dependencies as compile time dependencies</span></span><br><span class="line">    <span class="comment">// to the fullRelease and fullDebug build variants.</span></span><br><span class="line">    fullReleaseCompile project(<span class="string">path:</span> <span class="string">':library'</span>, <span class="string">configuration:</span> <span class="string">'release'</span>)</span><br><span class="line">    fullDebugCompile project(<span class="string">path:</span> <span class="string">':library'</span>, <span class="string">configuration:</span> <span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adds a compile time dependency for local tests.</span></span><br><span class="line">    testCompile <span class="string">'junit:junit:4.12'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adds a compile time dependency for the test APK.</span></span><br><span class="line">    androidTestCompile <span class="string">'com.android.support.test.espresso:espresso-core:2.2.2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看下新的配置项：</p><ul><li><p>implementation</p><p> 原有compile已经废弃掉，新增了implementation，用它来配置模块时，它是用来告诉Gradle该Module不会在编译时暴露其依赖给其他Module，而仅仅是在运行时才会暴露出来，即对其他Module可用。因此它也常常用在该模块不需要有别的模块依赖时声明使用，例如我们的App Module或者test Module。这样做的好处是减少了我们构建的时间。</p></li><li><p>api</p><p> 同原有compile，它和上面的区别就是它在编译器和运行期都会暴露它所配置的模块，因此也常常用在                                library module中。这是因为一旦我们api配置的这个Module有变化，Gradle会在编译期重新编译那个依赖项的所有依赖。所以，如果我们项目中有大量的api配置项依赖，那么无形中就增加了构建的时间，除非你想暴露这个模块的API给其他Module使用，否则，我们应尽可能使用implementation来代替。</p></li><li><p>compileOnly</p><p> 同上面的provided，只在编译时用，不会打包到我们的APK中</p></li><li><p>runtimeOnly</p><p> 同上面的apk</p></li></ul><h2 id="一些API的变化"><a href="#一些API的变化" class="headerlink" title="一些API的变化"></a>一些API的变化</h2><p>尤其注意的是我们重命名打包的APK文件，以及输出路径。<br>变化前：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">applicationVariants.all &#123; variant -&gt;</span><br><span class="line">    variant.outputs.<span class="keyword">each</span> &#123; output -&gt;</span><br><span class="line">        <span class="keyword">def</span> outputFile = output.outputFile</span><br><span class="line">        <span class="keyword">if</span> (outputFile != <span class="keyword">null</span> &amp;&amp; outputFile.name.endsWith(<span class="string">'.apk'</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (variant.buildType.name == <span class="string">'lotteryTest'</span>) &#123;</span><br><span class="line">                <span class="keyword">def</span> fileName = <span class="string">"myApp_v$&#123;defaultConfig.versionName&#125;_$&#123;releaseTime()&#125;.apk"</span></span><br><span class="line">                output.outputFile = <span class="keyword">new</span> <span class="keyword">File</span>(outputFile.parent, fileName)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变化后：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">applicationVariants</span>.all &#123; variant -&gt;</span></span><br><span class="line">    <span class="function"><span class="title">variant</span>.outputs.all &#123; output -&gt;</span></span><br><span class="line">        def outputFile = output.outputFile</span><br><span class="line">        <span class="keyword">if</span> (outputFile != null &amp;&amp; outputFile.<span class="keyword">name</span>.endsWith(<span class="string">'.apk'</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (variant.buildType.<span class="keyword">name</span> == <span class="string">'lotteryTest'</span>) &#123;</span><br><span class="line">                def fileName = <span class="string">"myApp_v$&#123;defaultConfig.versionName&#125;_$&#123;releaseTime()&#125;.apk"</span></span><br><span class="line">                outputFileName = new File(fileName)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即我们需要修改each() 和 outputFile() 方法为 all() 和 outputFileName</p><h2 id="默认启用AAPT2"><a href="#默认启用AAPT2" class="headerlink" title="默认启用AAPT2"></a>默认启用AAPT2</h2><p>  在迁移的过程中，如果发现由于aapt2导致的异常，可以在gradle.properties中加入：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.<span class="attribute">enableAapt2</span>=<span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="支持Java8新特性"><a href="#支持Java8新特性" class="headerlink" title="支持Java8新特性"></a>支持Java8新特性</h2><h3 id="Gradle带来全新的Java8支持方案desugar"><a href="#Gradle带来全新的Java8支持方案desugar" class="headerlink" title="Gradle带来全新的Java8支持方案desugar"></a>Gradle带来全新的Java8支持方案desugar</h3><p>该方案启用十分简单，只需要配置下面代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compileOptions &#123;</span><br><span class="line">    sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你不想使用，也可以禁用，可以在gradle.properties中加入：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.<span class="attribute">enableDesugar</span>=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>记得删除上面的兼容Java8代码。</p><h3 id="移除Jack工具链，不再支持"><a href="#移除Jack工具链，不再支持" class="headerlink" title="移除Jack工具链，不再支持"></a>移除Jack工具链，不再支持</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">android </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="class">defaultConfig </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Remove this block.</span></span><br><span class="line">    <span class="class">jackOptions </span>&#123;</span><br><span class="line">        enabled true</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Keep the following configuration in order to target Java 8.</span></span><br><span class="line"><span class="class">compileOptions </span>&#123;</span><br><span class="line">    sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移除Retrolambda插件"><a href="#移除Retrolambda插件" class="headerlink" title="移除Retrolambda插件"></a>移除Retrolambda插件</h3><p>项目级build.gradle 文件：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="comment">// Remove the following dependency.</span></span><br><span class="line">    <span class="keyword">classpath</span> <span class="string">'me.tatarka:gradle-retrolambda:&lt;version_number&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Module级build.gradle文件：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Remove the following plugin.</span></span><br><span class="line">apply plugin: <span class="string">'me.tatarka.retrolambda'</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// Remove this block after migrating useful configurations.</span></span><br><span class="line">retrolambda &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// If you have arguments for the Java VM you want to keep,</span></span><br><span class="line"><span class="comment">// move them to your project's gradle.properties file.</span></span><br><span class="line">jvmArgs <span class="string">'-Xmx2048m'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="目前兼容支持的功能特性有："><a href="#目前兼容支持的功能特性有：" class="headerlink" title="目前兼容支持的功能特性有："></a>目前兼容支持的功能特性有：</h3><ul><li>Lambda expressions</li><li>Method References</li><li>Type Annotations</li><li>Default and static interface methods</li><li>Repeating annotations</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.android.com/studio/write/java8-support.html#migrate" target="_blank" rel="noopener">https://developer.android.com/studio/write/java8-support.html#migrate</a></li><li><a href="https://android-developers.googleblog.com/2017/10/android-studio-30.html" target="_blank" rel="noopener">https://android-developers.googleblog.com/2017/10/android-studio-30.html</a></li><li><a href="https://developer.android.com/studio/build/gradle-plugin-3-0-0.html#known_issues" target="_blank" rel="noopener">https://developer.android.com/studio/build/gradle-plugin-3-0-0.html#known_issues</a></li><li><a href="https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration.html" target="_blank" rel="noopener">https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android Studio 3.0 默认Gradle版本为4.1，如果你需要手动升级版本的话，记得修改gradle/wrapper/gradle-wrapper.properties文件的URL地址：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir
      
    
    </summary>
    
      <category term="Android" scheme="https://yuxingxin.com/categories/Android/"/>
    
    
      <category term="Android Studio" scheme="https://yuxingxin.com/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>Node版本管理</title>
    <link href="https://yuxingxin.com/2017/08/16/NodeVersionManage/"/>
    <id>https://yuxingxin.com/2017/08/16/NodeVersionManage/</id>
    <published>2017-08-15T16:00:00.000Z</published>
    <updated>2019-03-19T02:50:33.854Z</updated>
    
    <content type="html"><![CDATA[<p>通常情况下，当我们有多个项目来维护时，如果各个项目所使用的node版本不一样，这就需要我们同时来管理多个node版本，这时候我们可以使用nvm或者n来管理。</p><h3 id="使用nvm来管理Node"><a href="#使用nvm来管理Node" class="headerlink" title="使用nvm来管理Node"></a>使用nvm来管理Node</h3><p><a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a>全称Node Version Manager,它是通过shell脚本实现nodejs版本管理的。，windows下用户官方推荐使用nvmw或nvm-windows。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>通过CURL<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- curl -o- https:<span class="regexp">//</span>raw.githubusercontent.com<span class="regexp">/creationix/</span>nvm<span class="regexp">/v0.33.2/i</span>nstall.sh | bash</span><br></pre></td></tr></table></figure></p><p>通过Wget<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- https:<span class="regexp">//</span>raw.githubusercontent.com<span class="regexp">/creationix/</span>nvm<span class="regexp">/v0.33.2/i</span>nstall.sh | bash</span><br></pre></td></tr></table></figure></p><p>以上脚本会将nvm仓库clone到~/.nvm目录，然后会在<code>~/.bash_profile, ~/.zshrc, ~/.profile, 或 ~/.bashrc</code>末尾添加source到你的配置文件，当然Mac用户也可以使用Homebrew来安装，安装完成以后需要我们再单独配置shell。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>首先使用nvm ls-remote命令查看当前都支持哪些版本的 nodejs，然后挑一个最新的稳定版，使用 nvm install 命令安装上即可。<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nvm ls-remote</span></span><br></pre></td></tr></table></figure></p><p>安装指定版本：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm <span class="keyword">install</span> &lt;node-<span class="keyword">version</span>&gt;</span><br></pre></td></tr></table></figure></p><p>安装完成之后检查：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">-v</span></span><br></pre></td></tr></table></figure></p><p>我们也可以用下面命令安装最新最稳定的node版本<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm <span class="keyword">install</span> stable</span><br></pre></td></tr></table></figure></p><p>删除某版本的node<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm <span class="keyword">uninstall</span> &lt;node-<span class="keyword">version</span>&gt;</span><br></pre></td></tr></table></figure></p><p>如删除v8.4.0，过程中出现：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su<span class="symbol">do:</span> <span class="built_in">n</span><span class="symbol">vm:</span> command <span class="built_in">not</span> found</span><br></pre></td></tr></table></figure></p><p>修改下目录权限，查看<code>$NVM_DIR</code>这个变量指向的那个目录<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$NVM_DIR</span></span></span><br><span class="line">/Users/SeanLiu/.nvm</span><br></pre></td></tr></table></figure></p><p>执行以下命令：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">chown</span> -R SeanLiu <span class="string">"$NVM_DIR/versions/node/v8.4.0"</span></span><br><span class="line">sudo <span class="keyword">chmod</span> -R u+w <span class="string">"$NVM_DIR/versions/node/v8.4.0"</span></span><br></pre></td></tr></table></figure></p><p>再次执行删除命令就可以了：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nvm</span> <span class="selector-tag">uninstall</span> 8<span class="selector-class">.4</span><span class="selector-class">.0</span></span><br></pre></td></tr></table></figure></p><p>设置默认版本，nvm使用default的alias来实现默认版本，只要执行个命令<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nvm alias<span class="built_in"> default </span>&lt;node-version&gt;</span><br><span class="line"></span><br><span class="line">nvm alias<span class="built_in"> default </span>8.9.1</span><br></pre></td></tr></table></figure></p><p>以后再登录进系统时，就默认使用的是这个版本了</p><p>我们也可以指定使用某个版本的node：<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm <span class="meta"><span class="meta-keyword">use</span> &lt;node-version&gt;</span></span><br></pre></td></tr></table></figure></p><p>也可以使用别名设置默认的版本<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm <span class="keyword">use</span> <span class="keyword">default</span></span><br></pre></td></tr></table></figure></p><p>查看当前已经安装的版本：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nvm ls</span></span><br></pre></td></tr></table></figure></p><p>查看当前正在使用的版本：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nvm current</span></span><br></pre></td></tr></table></figure></p><p>以指定版本执行脚本：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm <span class="built_in">run</span> &lt;node-<span class="built_in">version</span>&gt; myApp.js</span><br></pre></td></tr></table></figure></p><p>卸载nvm<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~<span class="string">/.nvm</span></span><br></pre></td></tr></table></figure></p><h3 id="使用n来管理Node"><a href="#使用n来管理Node" class="headerlink" title="使用n来管理Node"></a>使用n来管理Node</h3><p><a href="https://github.com/tj/n" target="_blank" rel="noopener">n</a>是非常简单易用的node版本管理器,也是Node的一个模块，作者TJ也是express框架的作者。</p><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g n</span><br></pre></td></tr></table></figure><p>安装完成之后，直接输入n可以显示当前已经安装的版本和正在使用的版本（前面有一个o）,你可以通过移动上下方向键来选择要使用的版本，最后按回车生效。<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">n</span></span><br></pre></td></tr></table></figure></p><p>也可以通过CURL来安装<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L <span class="string">https:</span><span class="comment">//git.io/n-install | bash</span></span><br></pre></td></tr></table></figure></p><p>也可以通过如下命令安装：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/visionmedia/n.git</span><br><span class="line"><span class="keyword">cd</span> n</span><br><span class="line"><span class="keyword">make</span> install</span><br></pre></td></tr></table></figure></p><p>如果需要安装到指定目录，需要在安装前增加PREFIX前缀,默认是安装在/usr/local/bin/n，如果将n安装到~/bin/n<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">PREFIX=<span class="variable">$HOME</span> make install</span></span><br></pre></td></tr></table></figure></p><h4 id="n使用"><a href="#n使用" class="headerlink" title="n使用"></a>n使用</h4><p>安装指定版本<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n <span class="tag">&lt;<span class="name">node-versioin</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>如果该版本事先已安装，则就使用它</p><p>安装最新版本<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">n latest</span></span><br></pre></td></tr></table></figure></p><p>安装最稳定版本<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">n stable</span></span><br></pre></td></tr></table></figure></p><p>获取帮助<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n <span class="comment">--help</span></span><br></pre></td></tr></table></figure></p><p>删除某版本node<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">n</span> <span class="keyword">rm</span> &lt;node-<span class="keyword">version</span>&gt;</span><br></pre></td></tr></table></figure></p><p>以指定的版本来执行脚本<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n <span class="meta"><span class="meta-keyword">use</span> &lt;node-version&gt;</span> myApp.js</span><br></pre></td></tr></table></figure></p><p>查看某版本node的安装路径<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n bin &lt;node-<span class="built_in">version</span>&gt;</span><br></pre></td></tr></table></figure></p><h3 id="nvm与n"><a href="#nvm与n" class="headerlink" title="nvm与n"></a>nvm与n</h3><ul><li>n是作为一个node的模块而存在，而nvm 是一个独立于node/npm的外部 shell 脚本，因此n比nvm更加局限。</li><li>不要同时使用两者，这样会导致版本混乱，可以根据自己的喜好，选择其一。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常情况下，当我们有多个项目来维护时，如果各个项目所使用的node版本不一样，这就需要我们同时来管理多个node版本，这时候我们可以使用nvm或者n来管理。&lt;/p&gt;
&lt;h3 id=&quot;使用nvm来管理Node&quot;&gt;&lt;a href=&quot;#使用nvm来管理Node&quot; class=&quot;h
      
    
    </summary>
    
      <category term="FrontEnd" scheme="https://yuxingxin.com/categories/FrontEnd/"/>
    
    
      <category term="nvm n" scheme="https://yuxingxin.com/tags/nvm-n/"/>
    
  </entry>
  
  <entry>
    <title>局域网下GitLab的部署与汉化</title>
    <link href="https://yuxingxin.com/2017/07/13/GitLab/"/>
    <id>https://yuxingxin.com/2017/07/13/GitLab/</id>
    <published>2017-07-12T16:00:00.000Z</published>
    <updated>2019-03-19T02:49:05.298Z</updated>
    
    <content type="html"><![CDATA[<p>最近有这方面的需求，需要内网搭建一个Git平台，最后选了GitLab社区版，这里记录一下。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>基于Ubuntu LTS 16.04<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 安装依赖包</span></span><br><span class="line">sudo apt-<span class="keyword">get</span> install curl openssh-server ca-certificates postfix</span><br><span class="line"><span class="meta"># 安装 GitLab 社区版</span></span><br><span class="line">apt-<span class="keyword">get</span> install gitlab-ce</span><br><span class="line"><span class="meta"># 载入配置启动 （安装好后执行就默认启动了,每次修改配置都需要进行载入配置启动）</span></span><br><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure></p><p>注意使用国内安装源镜像，加快安装速度，修改/etc/apt/sources.list.d/gitlab-ce.list，添加以下行<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/gitlab-<span class="keyword">ce</span>/debian jessie main</span><br></pre></td></tr></table></figure></p><p>相关命令：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动GitLab所以组件</span></span><br><span class="line">sudo gitlab-ctl <span class="literal">start</span></span><br><span class="line"><span class="comment">#重启GitLab所有组件</span></span><br><span class="line">sudo gitlab-ctl <span class="literal">stop</span></span><br></pre></td></tr></table></figure></p><h3 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h3><p>确认当前安装版本<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/opt/gi</span>tlab<span class="regexp">/embedded/</span>service<span class="regexp">/gitlab-rails/</span>VERSION</span><br></pre></td></tr></table></figure></p><p>克隆GitLab仓库代码：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">git</span>@gitlab.com:xhang/gitlab.git</span><br></pre></td></tr></table></figure></p><p>接着运行汉化补丁：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">9.3</span> 版本的汉化补丁（<span class="number">9</span><span class="number">-3</span>-stable是英文稳定版，<span class="number">9</span><span class="number">-3</span>-stable-zh是中文版，两个 diff 结果便是汉化补丁）</span><br><span class="line">sudo git diff origin/<span class="number">9</span><span class="number">-3</span>-stable.<span class="number">.9</span><span class="number">-3</span>-stable-zh &gt; /tmp/<span class="number">9.3</span>.diff</span><br><span class="line"># 停止 gitlab</span><br><span class="line">sudo gitlab-ctl stop</span><br><span class="line"># 应用汉化补丁</span><br><span class="line">cd /opt/gitlab/embedded/service/gitlab-rails</span><br><span class="line">git apply /tmp/<span class="number">9.3</span>.diff  </span><br><span class="line"># 启动gitlab</span><br><span class="line">sudo gitlab-ctl start</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近有这方面的需求，需要内网搭建一个Git平台，最后选了GitLab社区版，这里记录一下。&lt;/p&gt;
&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;基于Ubuntu LTS 16.0
      
    
    </summary>
    
      <category term="Tools" scheme="https://yuxingxin.com/categories/Tools/"/>
    
    
      <category term="gitlab" scheme="https://yuxingxin.com/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>依赖注入库Dagger2</title>
    <link href="https://yuxingxin.com/2017/06/26/Dagger2/"/>
    <id>https://yuxingxin.com/2017/06/26/Dagger2/</id>
    <published>2017-06-25T16:00:00.000Z</published>
    <updated>2019-06-06T08:35:02.619Z</updated>
    
    <content type="html"><![CDATA[<h3 id="依赖注入Dagger2"><a href="#依赖注入Dagger2" class="headerlink" title="依赖注入Dagger2"></a>依赖注入Dagger2</h3><p>之前在项目中要用到这个库，后来就给团队内部分享完Dagger2后做的一个提纲总结。</p><h3 id="解决的痛点"><a href="#解决的痛点" class="headerlink" title="解决的痛点"></a>解决的痛点</h3><p>  依赖管理问题</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ol><li>依赖实例</li><li>注入对象</li><li>注入方式</li></ol><h3 id="提供依赖的方式"><a href="#提供依赖的方式" class="headerlink" title="提供依赖的方式"></a>提供依赖的方式</h3><ol><li><p>@Inject</p></li><li><p>@Module  优先级更高</p><p>@provide</p></li></ol><h3 id="注入在哪里"><a href="#注入在哪里" class="headerlink" title="注入在哪里"></a>注入在哪里</h3><p>  @Inject</p><h3 id="注入方式：连接的桥梁"><a href="#注入方式：连接的桥梁" class="headerlink" title="注入方式：连接的桥梁"></a>注入方式：连接的桥梁</h3><h4 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h4><p>  注入方法：void inject();</p><p>  提供中间桥梁：Application  getApplication();</p><p>  依赖的实体：modules</p><p>  依赖的传递：dependencies  本质是将依赖的Component的引用传递给了被依赖的Component</p><h4 id="SubComponent：Component的拓展"><a href="#SubComponent：Component的拓展" class="headerlink" title="@SubComponent：Component的拓展"></a>@SubComponent：Component的拓展</h4><p>  公用依赖实例</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><h5 id="Component-Dependencies：-单纯依赖"><a href="#Component-Dependencies：-单纯依赖" class="headerlink" title="Component Dependencies： 单纯依赖"></a>Component Dependencies： 单纯依赖</h5><ol><li>你想保留独立的单个组件</li><li>要明确的显示该组件所使用的其他依赖</li></ol><h5 id="Subcomponent：有点类似继承"><a href="#Subcomponent：有点类似继承" class="headerlink" title="Subcomponent：有点类似继承"></a>Subcomponent：有点类似继承</h5><ol><li>两个组件之间的关系紧密</li><li>你只关心Component，而Subcomponent只是作为Component的拓展</li></ol><h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>  @Qualifier  自定义注解</p><p>  区分多个依赖对象，单独为其打上标记</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="Scope-自定义注解"><a href="#Scope-自定义注解" class="headerlink" title="@Scope  自定义注解"></a>@Scope  自定义注解</h4><p>  管理依赖的生命周期</p><p>  默认实现：@Singleton   局部单例</p><blockquote><p>Module中provide方法使用了@scope, 对应的Component中也必须加上@scope,  注解名字也是一样的，这时候 provide提供的方法就会在Component中保持『局部单例』，如果只是在Component中标注@scope,Module中的provide方法没有标注，这时候scope就不会起作用，仅仅是为了编译通过</p></blockquote><p>  实现单例：</p><ol><li>依赖在Component中是单例的（供该依赖的provide方法和对应的Component类使用同一个Scope注解。）</li><li><p>对应的Component在App中只初始化一次，每次注入依赖都使用这个Component对象。（在Application中创建该Component）</p><p>自定义其他scope：@ActivityScope  @FragmentScope等等</p></li></ol><h3 id="延迟注入Lazy"><a href="#延迟注入Lazy" class="headerlink" title="延迟注入Lazy"></a>延迟注入Lazy<t></t></h3><p>  初始化的时候不注入，等到调用get方法的时候才去初始化依赖实例注入依赖</p><h3 id="多实例注入Provider"><a href="#多实例注入Provider" class="headerlink" title="多实例注入Provider"></a>多实例注入Provider<t></t></h3><p>  有时候不仅仅是注入单个实例，我们需要多个实例，每次调用它的 get() 方法都会调用到 <code>@Inject 构造函数</code>创建新实例或者 Module 的 provide 方法返回新实例</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;依赖注入Dagger2&quot;&gt;&lt;a href=&quot;#依赖注入Dagger2&quot; class=&quot;headerlink&quot; title=&quot;依赖注入Dagger2&quot;&gt;&lt;/a&gt;依赖注入Dagger2&lt;/h3&gt;&lt;p&gt;之前在项目中要用到这个库，后来就给团队内部分享完Dagger2后做的
      
    
    </summary>
    
      <category term="Android" scheme="https://yuxingxin.com/categories/Android/"/>
    
    
      <category term="Dagger2" scheme="https://yuxingxin.com/tags/Dagger2/"/>
    
  </entry>
  
  <entry>
    <title>终端下Python镜像源管理工具pprm</title>
    <link href="https://yuxingxin.com/2017/03/01/Pprm/"/>
    <id>https://yuxingxin.com/2017/03/01/Pprm/</id>
    <published>2017-02-28T16:00:00.000Z</published>
    <updated>2019-03-19T02:51:03.737Z</updated>
    
    <content type="html"><![CDATA[<p>我们在使用Python做开发的时候，常常会用到第三方库，.虽然用easy_install和pip来安装第三方库很方便，但默认的第三方库是从Python的<a href="https://pypi.python.org/pypi" target="_blank" rel="noopener">官方源</a>下载的，因为某些原因，官方的网站访问时快时慢，很不稳定，有时候也直接打不开了，网上可以找一些国内的镜像源可以做为替换，通过修改配置文件(<code>~/.pip/pip.conf</code>)pip.conf即可，其实这个小工具的作用就是帮我们做这个事情，另外也提供了增删查等其他相关命令。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">  npm install -g pprm</span></span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h5 id="列出所有的镜像源地址："><a href="#列出所有的镜像源地址：" class="headerlink" title="列出所有的镜像源地址："></a>列出所有的镜像源地址：</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">prm</span> <span class="string">ls</span></span><br><span class="line"></span><br><span class="line">  <span class="string">pypi</span> <span class="meta">---</span> <span class="attr">https://pypi.python.org/simple/</span></span><br><span class="line"><span class="string">*</span> <span class="string">douban</span> <span class="bullet">-</span> <span class="attr">https://pypi.doubanio.com/simple/</span></span><br><span class="line">  <span class="string">ali</span> <span class="bullet">----</span> <span class="attr">http://mirrors.aliyun.com/pypi/simple/</span></span><br><span class="line">  <span class="string">tsinghua</span>  <span class="attr">https://pypi.tuna.tsinghua.edu.cn/simple/</span></span><br><span class="line">  <span class="string">ustc</span> <span class="meta">---</span> <span class="attr">https://mirrors.ustc.edu.cn/pypi/web/simple/</span></span><br></pre></td></tr></table></figure><h5 id="切换镜像源："><a href="#切换镜像源：" class="headerlink" title="切换镜像源："></a>切换镜像源：</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ prm <span class="keyword">use</span> <span class="keyword">ali</span></span><br><span class="line"></span><br><span class="line">Registry has been <span class="keyword">set</span> <span class="keyword">to</span>: <span class="keyword">http</span>://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure><h5 id="查看当前镜像源："><a href="#查看当前镜像源：" class="headerlink" title="查看当前镜像源："></a>查看当前镜像源：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> prm current</span></span><br><span class="line"></span><br><span class="line">douban</span><br></pre></td></tr></table></figure><h5 id="添加镜像源："><a href="#添加镜像源：" class="headerlink" title="添加镜像源："></a>添加镜像源：</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ prm <span class="keyword">add</span><span class="bash"> <span class="string">'registry_name'</span> <span class="string">'registry_url'</span> <span class="string">'registry_home_url'</span></span></span><br><span class="line"><span class="bash"><span class="comment"># 参数依次是镜像源的名称、地址、项目首页</span></span></span><br></pre></td></tr></table></figure><h5 id="删除指定的镜像源："><a href="#删除指定的镜像源：" class="headerlink" title="删除指定的镜像源："></a>删除指定的镜像源：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> del <span class="string">'registry_name'</span></span></span><br></pre></td></tr></table></figure><h5 id="用浏览器打开主页："><a href="#用浏览器打开主页：" class="headerlink" title="用浏览器打开主页："></a>用浏览器打开主页：</h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prm <span class="built_in">home</span> <span class="string">'registry_name'</span></span><br></pre></td></tr></table></figure><h5 id="测试镜像源地址的响应速度："><a href="#测试镜像源地址的响应速度：" class="headerlink" title="测试镜像源地址的响应速度："></a>测试镜像源地址的响应速度：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prm <span class="built_in">test</span> <span class="string">'registry_name'</span></span><br></pre></td></tr></table></figure><h5 id="帮助中心"><a href="#帮助中心" class="headerlink" title="帮助中心"></a>帮助中心</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prm <span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/450566-ae3ae41a9170f4e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pprm"></p><h5 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h5><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prm <span class="built_in">version</span></span><br></pre></td></tr></table></figure><h3 id="项目地址："><a href="#项目地址：" class="headerlink" title="项目地址："></a>项目地址：</h3><ul><li><a href="https://github.com/yuxingxin/pprm" target="_blank" rel="noopener">GitHub_pprm</a></li><li><a href="https://www.npmjs.com/package/pprm" target="_blank" rel="noopener">npm_pprm</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在使用Python做开发的时候，常常会用到第三方库，.虽然用easy_install和pip来安装第三方库很方便，但默认的第三方库是从Python的&lt;a href=&quot;https://pypi.python.org/pypi&quot; target=&quot;_blank&quot; rel=&quot;n
      
    
    </summary>
    
      <category term="Tools" scheme="https://yuxingxin.com/categories/Tools/"/>
    
    
      <category term="registry" scheme="https://yuxingxin.com/tags/registry/"/>
    
  </entry>
  
  <entry>
    <title>关于Node和Python语言的包镜像源的替换</title>
    <link href="https://yuxingxin.com/2017/02/28/PackageRegistry/"/>
    <id>https://yuxingxin.com/2017/02/28/PackageRegistry/</id>
    <published>2017-02-27T16:00:00.000Z</published>
    <updated>2019-03-19T02:56:45.871Z</updated>
    
    <content type="html"><![CDATA[<p>最近做一些node和Python的相关开发，在更新下载包的时候发现特别慢，有时候还卡在那里半天不动，在网上查了一些国内的镜像源替换了下，就相当快了，这里简单做个记录。</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>我们在使用Python做开发的时候，常常会用到第三方库，.虽然用easy_install和pip来安装第三方库很方便，但默认的第三方库是从Python的<a href="https://pypi.python.org/pypi" target="_blank" rel="noopener">官方源</a>下载的，因为某些原因，官方的网站访问时快时慢，很不稳定，有时候也直接打不开了，这里找一些国内的镜像源可以做为替换：</p><ul><li><a href="https://pypi.douban.com/simple/" target="_blank" rel="noopener">豆瓣</a></li><li><a href="http://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener">阿里</a></li><li><a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">清华大学</a></li><li><a href="http://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">中国科学技术大学</a></li></ul><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>我们只需要选一个上面的地址配置到默认路径下(linux下<code>~/.pip/pip.conf</code>,windows在<code>%HOMEPATH%\pip\pip.ini</code>)的pip.conf文件即可：<br>修改内容为：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[global]</span></span><br><span class="line"><span class="attr">index-url</span> = http://pypi.douban.com/simple</span><br></pre></td></tr></table></figure></p><p>另外可以参考我的这篇文章写得一个小工具<a href="http://www.jianshu.com/p/ff459d79e3fd" target="_blank" rel="noopener">pprm</a></p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>由于Node的第三方包下载站也是相当的慢，所以我们也需要更换下镜像源，Linux用户默认只需要修改配置文件(<code>~/.npmrc</code>)即可:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/<span class="regexp">/registry.npmjs.org/</span><span class="symbol">:_authToken=f8378722-</span><span class="number">2</span>ecf-<span class="number">4564</span>-<span class="number">84</span>cc-<span class="number">57</span>b262467cf6</span><br><span class="line">registry=<span class="symbol">https:</span>/<span class="regexp">/registry.npm.taobao.org/</span>  /<span class="regexp">/替换这一行为你指定的源即可</span></span><br></pre></td></tr></table></figure></p><p>当然有时候我们会发现这样该来改去也比较麻烦，所以就有人写出了<a href="https://github.com/Pana/nrm" target="_blank" rel="noopener">nrm</a>:一个 NPM 源管理器，允许你快速地在如下 NPM 源间切换</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g nrm</span><br></pre></td></tr></table></figure><h4 id="列出可选的源"><a href="#列出可选的源" class="headerlink" title="列出可选的源"></a>列出可选的源</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="string">nrm</span> <span class="string">ls</span>    </span><br><span class="line"></span><br><span class="line">  <span class="string">npm</span> <span class="bullet">----</span> <span class="attr">https://registry.npmjs.org/</span></span><br><span class="line">  <span class="string">cnpm</span> <span class="meta">---</span> <span class="attr">http://r.cnpmjs.org/</span></span><br><span class="line"><span class="string">*</span> <span class="string">taobao</span> <span class="bullet">-</span> <span class="attr">https://registry.npm.taobao.org/</span></span><br><span class="line">  <span class="string">nj</span> <span class="bullet">-----</span> <span class="attr">https://registry.nodejitsu.com/</span></span><br><span class="line">  <span class="string">rednpm</span> <span class="bullet">-</span> <span class="attr">http://registry.mirror.cqupt.edu.cn/</span></span><br><span class="line">  <span class="string">npmMirror</span>  <span class="attr">https://skimdb.npmjs.com/registry/</span></span><br><span class="line">  <span class="string">edunpm</span> <span class="bullet">-</span> <span class="attr">http://registry.enpmjs.org/</span></span><br></pre></td></tr></table></figure><p>其中带 * 的是当前使用的源，上面的输出表明当前源是淘宝镜像源。</p><h4 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h4><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nrm use npm</span><br><span class="line"></span><br><span class="line">Registry <span class="keyword">has</span> been <span class="keyword">set</span> <span class="keyword">to</span>: https:<span class="comment">//registry.npmjs.org/</span></span><br></pre></td></tr></table></figure><p>上面命令代表切换到npm官方源</p><h4 id="增加源"><a href="#增加源" class="headerlink" title="增加源"></a>增加源</h4><p>你可以增加定制的源，特别适用于添加企业内部的私有源。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nrm <span class="built_in">add</span>  <span class="symbol">&lt;registry&gt;</span> <span class="symbol">&lt;url&gt;</span> [home]</span><br></pre></td></tr></table></figure></p><h4 id="删除源"><a href="#删除源" class="headerlink" title="删除源"></a>删除源</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nrm <span class="selector-tag">del</span> &lt;registry&gt;</span><br></pre></td></tr></table></figure><h4 id="测试速度"><a href="#测试速度" class="headerlink" title="测试速度"></a>测试速度</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nrm test <span class="built_in">npm</span>  <span class="comment">#测试官方npm源的访问速度</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">npm</span> ---- <span class="number">964</span>ms</span><br></pre></td></tr></table></figure><p>测试所有源的访问速度：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nrm <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p><p>注意，为了取得较准确的结果，可以考虑多次测试取平均值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近做一些node和Python的相关开发，在更新下载包的时候发现特别慢，有时候还卡在那里半天不动，在网上查了一些国内的镜像源替换了下，就相当快了，这里简单做个记录。&lt;/p&gt;
&lt;h3 id=&quot;Python&quot;&gt;&lt;a href=&quot;#Python&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Others" scheme="https://yuxingxin.com/categories/Others/"/>
    
    
      <category term="registry" scheme="https://yuxingxin.com/tags/registry/"/>
    
  </entry>
  
  <entry>
    <title>博客的迁移及自动化部署并全站https化</title>
    <link href="https://yuxingxin.com/2017/02/17/DeployViaHttps/"/>
    <id>https://yuxingxin.com/2017/02/17/DeployViaHttps/</id>
    <published>2017-02-16T16:00:00.000Z</published>
    <updated>2019-04-03T03:27:19.736Z</updated>
    
    <content type="html"><![CDATA[<p>过完年来想把博客做一个迁移，放到自己购买的服务器上，并实现自动化部署，并启用全站HTTPS</p><h2 id="hexo本地部署"><a href="#hexo本地部署" class="headerlink" title="hexo本地部署"></a>hexo本地部署</h2><p>这一步骤网上有很多教程，这里不再多说了</p><h2 id="服务器自动化部署"><a href="#服务器自动化部署" class="headerlink" title="服务器自动化部署"></a>服务器自动化部署</h2><p>大体的流程就是，我们通过<code>hexo g</code>命令在本地生成静态文件以后，通过git push到我们的远程仓库(这里我用的是GitHub)，然后由于我们事先在项目库中配置了webhooks，由它post到你的服务器一个请求链接，我们的服务器收到请求后，对应执行我们提前写好的脚本，再将push的内容同步到我们的服务器，从而更新了服务器的内容。</p><h2 id="服务器环境配置"><a href="#服务器环境配置" class="headerlink" title="服务器环境配置"></a>服务器环境配置</h2><p>我们通过ssh(windows用户可以通过putty登录)登录到我们的服务，我这里用的是Ubuntu系统，安装好nodejs,git,nginx后，将我们的文件从远程仓库拉下来<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> blog</span><br><span class="line"><span class="keyword">cd</span> blog</span><br><span class="line">git init</span><br><span class="line">git remote <span class="built_in">add</span> origin http<span class="variable">s:</span>//github.<span class="keyword">com</span>/yuxingxin/yuxingxin.github.io.git</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></p><h3 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h3><p>这个配置之前写的有相关文章，不明白的可以看<a href="http://www.jianshu.com/p/3531a011b7b6" target="_blank" rel="noopener">这里</a>，不过这里的系统是Ubuntu，所以nginx的安装路径也不太一样(<code>/etc/nginx</code>)，默认我们需要在<code>/etc/nginx/conf.d/</code>目录下添加配置文件<code>blog.conf</code>，<strong>注意这里的后缀名一定是<code>.conf</code></strong><br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span> /etc/nginx/<span class="keyword">conf</span>.d/blog.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure></p><p>然后配置上我们的域名，端口和映射地址<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;  <span class="comment">#修改这里为其他端口如8081</span></span><br><span class="line">    <span class="attribute">server_name</span>  yuxingxin.com www.yuxingxin.com; <span class="comment"># 这里是你的域名</span></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   /root/blog/; <span class="comment">#修改这里的路径为自己的路径</span></span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后重启nginx通过域名就可以访问我们的博客了<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nginx -s reload</span></span><br></pre></td></tr></table></figure></p><h3 id="webhooks配置"><a href="#webhooks配置" class="headerlink" title="webhooks配置"></a>webhooks配置</h3><p>也就是人们常说的钩子，是一个很有用的工具。你可以通过定制 Webhook 来监测你在 Github.com 上的各种事件，最常见的莫过于 push 事件,如果你设置了一个监测 push 事件的 Webhook，那么每当你的这个项目有了任何提交，这个 Webhook 都会被触发，这时 Github 就会发送一个 HTTP POST 请求到你配置好的地址。如此一来，你就可以通过这种方式去自动完成一些重复性工作；比如，你可以用 Webhook 来自动触发一些持续集成（CI）工具的运作，比如 Travis CI；又或者是通过 Webhook 去部署你的线上服务器。<br>Webhook 的配置是十分简单的。首先进入你的 repo 主页，通过点击页面上的按钮 [settings] -&gt; [Webhooks &amp; service] 进入 Webhooks 配置主页面。在Payload URL配置链接，比如：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>//xxxxx.com:<span class="number">8246</span>/webhooks/<span class="keyword">push</span>/deploy</span><br></pre></td></tr></table></figure></p><p>这样一来，仓库的配置就算好了，接下来看服务器端如何响应</p><h3 id="服务器配置webhooks响应"><a href="#服务器配置webhooks响应" class="headerlink" title="服务器配置webhooks响应"></a>服务器配置webhooks响应</h3><p>首先我们在我们的博客目录下创建一个js文件，用来启动我们的监听服务，端口就是我们在仓库配置那里的端口地址：8246<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line">var exec = <span class="built_in">require</span>(<span class="string">'child_process'</span>).exec</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(req.url === <span class="string">'/webhooks/push/deploy'</span>)&#123;</span><br><span class="line">        exec(<span class="string">'sh ./deploy.sh'</span>,<span class="function"><span class="keyword">function</span><span class="params">(error,stdout,stderr)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">error</span>)&#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="built_in">error</span>.stack);</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">'Error code:'</span>+ <span class="built_in">error</span>.code);</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          console.<span class="built_in">log</span>(<span class="string">'success'</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="keyword">end</span>()</span><br><span class="line">&#125;).listen(<span class="number">8246</span>)</span><br></pre></td></tr></table></figure></p><p>这段代码就能启动一个nodejs服务，监听8246端口，当请求过来的url完全匹配的时候，执行deploy.sh。<br>再新建一个deploy.sh文件处理部署相关脚本：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin <span class="literal">master</span></span><br></pre></td></tr></table></figure></p><h3 id="运行nodejs服务"><a href="#运行nodejs服务" class="headerlink" title="运行nodejs服务"></a>运行nodejs服务</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">./webhooks</span>.js</span><br></pre></td></tr></table></figure><p>如果你使用上面的命令运行nodejs服务，nodejs服务会在前台运行，可以使用<a href="https://www.npmjs.com/package/pm2" target="_blank" rel="noopener">pm2</a>使nodejs运行在后台。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">npm install pm2 -g</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动服务</span></span><br><span class="line">pm2 start webhooks.js</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止服务</span></span><br><span class="line">pm2 stop webhooks.js</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启服务</span></span><br><span class="line">pm2 restart webhooks.js</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 实时查看pm2的日志服务</span></span><br><span class="line">pm2 logs</span><br></pre></td></tr></table></figure></p><p>到此为止我们的自动化部署就全部完成了，以后我们只需在本地将文件push到远程仓库，就会自动同步到我们的服务器上</p><h2 id="启用全站HTTPS"><a href="#启用全站HTTPS" class="headerlink" title="启用全站HTTPS"></a>启用全站HTTPS</h2><p>这里简单总结下在 Nginx 配置 HTTPS 服务器：主要签署第三方可信任的证书和配置HTTPS</p><h3 id="关于证书"><a href="#关于证书" class="headerlink" title="关于证书"></a>关于证书</h3><p>SSL证书需要向国际公认的证书证书认证机构（简称CA，Certificate Authority）申请。<br>CA机构颁发的证书有3种类型：</p><ol><li>域名型SSL证书（DV SSL）：信任等级普通，只需验证网站的真实性便可颁发证书保护网站；</li><li>企业型SSL证书（OV SSL）：信任等级强，须要验证企业的身份，审核严格，安全性更高；</li><li>增强型SSL证书（EV SSL）：信任等级最高，一般用于银行证券等金融机构，审核严格，安全性最高，同时可以激活绿色网址栏。</li></ol><p>关于证书服务，市面上大体的都是收费的证书，当然也有部分是免费的，比如Let’s Encrypt  刚刚又拍云也上线了免费的 SSL <a href="http://weibo.com/ttarticle/p/show?id=2309404057245016043005#_0" target="_blank" rel="noopener">证书</a>，另外StartSSL也提供免费证书，有效期3年；另外还有腾讯云和阿里云都有相关的免费证书，这里我使用的是Let’s Encrypt ,这也是目前最知名的开源SSL证书。</p><h3 id="证书申请"><a href="#证书申请" class="headerlink" title="证书申请"></a>证书申请</h3><p>申请 Let’s Encrypt 证书不但免费，还非常简单，虽然每次只有 90 天的有效期，但可以通过脚本定期更新，配好之后一劳永逸。Let’s Encrypt 的证书签发过程使用的就是 ACME 协议,这里也推荐一个小工具就是<a href="https://github.com/diafygi/acme-tiny" target="_blank" rel="noopener">acme-tiny</a>,它可以帮助我们简化创建证书的流程。</p><h4 id="创建帐号"><a href="#创建帐号" class="headerlink" title="创建帐号"></a>创建帐号</h4><p>创建一个目录存放私钥证书等各种文件，然后进入后创建我们的RSA账户私钥<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ssl</span><br><span class="line"><span class="built_in">cd</span> ssl</span><br><span class="line">openssl genrsa <span class="number">4096</span> &gt; account.key</span><br></pre></td></tr></table></figure></p><h4 id="创建-CSR-文件"><a href="#创建-CSR-文件" class="headerlink" title="创建 CSR 文件"></a>创建 CSR 文件</h4><p>这一步生成我们的证书签名文件，即CSR，首先要创建RSA私钥<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa <span class="number">4096</span> &gt; domain.<span class="type">key</span></span><br></pre></td></tr></table></figure></p><p>接下来就可以生成我们的证书文件了，单个域名和多个域名生产的参数还不太一样.<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//单个域名</span><br><span class="line">openssl req -<span class="built_in">new</span> -sha256 -<span class="built_in">key</span> <span class="built_in">domain</span>.<span class="built_in">key</span> -subj <span class="string">"/CN=yuxingxin.com"</span> &gt; <span class="built_in">domain</span>.csr</span><br><span class="line">//多个域名（比如yuxingxin.com和www.yuxingxin.com）</span><br><span class="line">openssl req -<span class="built_in">new</span> -sha256 -<span class="built_in">key</span> <span class="built_in">domain</span>.<span class="built_in">key</span> -subj <span class="string">"/"</span> -reqexts SAN -config &lt;(cat /etc/ssl/openssl.cnf &lt;(<span class="built_in">printf</span> <span class="string">"[SAN]\nsubjectAltName=DNS:yuxingxin.com,DNS:www.yuxingxin.com"</span>)) &gt; <span class="built_in">domain</span>.csr</span><br></pre></td></tr></table></figure></p><h4 id="配置验证服务"><a href="#配置验证服务" class="headerlink" title="配置验证服务"></a>配置验证服务</h4><p>CA 在签发 DV（Domain Validation）证书时，需要验证域名所有权，而大部分都是通过邮件验证的方式，Let’s Encrypt 则是在你的服务器上生成一个随机验证文件，再通过创建 CSR 时指定的域名访问，如果可以访问则表明你对这个域名有控制权。<br>首先创建用于存放验证文件的目录<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/www/challenges/</span><br></pre></td></tr></table></figure></p><p>然后配置一个 HTTP 服务，以 Nginx 为例：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="comment"># 这里改成自己的域名</span></span><br><span class="line">    <span class="attribute">server_name</span> yuxingxin.com www.yuxingxin.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /.well-known/acme-challenge/ &#123;</span><br><span class="line">        <span class="attribute">alias</span> /root/www/challenges/;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> =<span class="number">404</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="生成网站证书"><a href="#生成网站证书" class="headerlink" title="生成网站证书"></a>生成网站证书</h4><p>先把acme-tiny脚本保存到之前的ssl目录<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="regexp">//</span>raw.githubusercontent.com<span class="regexp">/diafygi/</span>acme-tiny<span class="regexp">/master/</span>acme_tiny.py</span><br></pre></td></tr></table></figure></p><p>指定账户私钥、CSR 以及验证目录，在ssl目录下执行脚本<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python acme_tiny.py <span class="params">--account-key</span> <span class="string">./account.key</span> <span class="params">--csr</span> <span class="string">./domain.csr</span> <span class="params">--acme-dir</span> <span class="string">/root/www/challenges/</span> &gt; <span class="string">./signed.crt</span></span><br></pre></td></tr></table></figure></p><p>如果一切正常，当前目录ssl下就会生成一个 signed.crt，这就是申请好的证书文件。<br>这里遇到一个错误,大致如下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueError: Wrote <span class="keyword">file</span> to <span class="regexp">/root/</span>www<span class="regexp">/challenges/</span>oJbvpIhkwkBGBAQUklWJXyC8VbWAdQqlgpwUJkgC1Vg, but couldn<span class="string">'t download http://www.yuxingxin.com/.well-known/acme-challenge/oJbvpIhkwkBGBAQUklWJXyC8VbWAdQqlgpwUJkgC1Vg</span></span><br></pre></td></tr></table></figure></p><p>网上查了一些方案，觉得有一个比较靠谱，也得到了解决，大致就是原来库做了一个验证导致有些情况通不过，这里有人fork源库修改了部分代码，地址在<a href="https://github.com/frezbo/acme-tiny" target="_blank" rel="noopener">这里</a>，如果出现上述错误，可以获取这个库的脚步然后在执行上面那条命令。</p><h4 id="下载中间证书"><a href="#下载中间证书" class="headerlink" title="下载中间证书"></a>下载中间证书</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget -O - https:<span class="comment">//letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &gt; intermediate.pem</span></span><br><span class="line">cat signed<span class="selector-class">.crt</span> intermediate<span class="selector-class">.pem</span> &gt; chained.pem</span><br></pre></td></tr></table></figure><h4 id="为了后续能顺利启用-OCSP-Stapling，我们再把根证书和中间证书合在一起："><a href="#为了后续能顺利启用-OCSP-Stapling，我们再把根证书和中间证书合在一起：" class="headerlink" title="为了后续能顺利启用 OCSP Stapling，我们再把根证书和中间证书合在一起："></a>为了后续能顺利启用 OCSP Stapling，我们再把根证书和中间证书合在一起：</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget -O - https:<span class="comment">//letsencrypt.org/certs/isrgrootx1.pem &gt; root.pem</span></span><br><span class="line">cat intermediate<span class="selector-class">.pem</span> root<span class="selector-class">.pem</span> &gt; full_chained.pem</span><br></pre></td></tr></table></figure><h4 id="修改nginx证书配置"><a href="#修改nginx证书配置" class="headerlink" title="修改nginx证书配置"></a>修改nginx证书配置</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span>;</span><br><span class="line">    <span class="comment">#修改成自己的域名</span></span><br><span class="line">    <span class="attribute">server_name</span> yuxingxin.com www.yuxingxin.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#这里注意证书路径</span></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /root/ssl/chained.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /root/ssl/domain.key;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA;</span><br><span class="line">    <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">50m</span>;</span><br><span class="line">    <span class="attribute">ssl_dhparam</span> /root/ssl/dhparam.pem;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">resolver</span> <span class="number">8.8.8.8</span>;</span><br><span class="line">    <span class="attribute">ssl_stapling</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_trusted_certificate</span> /root/ssl/signed.crt;</span><br><span class="line">    <span class="attribute">add_header</span> Strict-Transport-Security <span class="string">"max-age=31536000; includeSubdomains;preload"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="comment"># 这里要改成自己存放博客静态网页的目录</span></span><br><span class="line">        <span class="attribute">root</span>  /root/blog;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="comment"># 这里改成自己的域名</span></span><br><span class="line">    <span class="attribute">server_name</span> yuxingxin.com www.yuxingxin.com;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> /root/ssl/chained.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /root/ssl/domain.key;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /.well-known/acme-challenge/ &#123;</span><br><span class="line">        <span class="attribute">alias</span> /root/www/challenges/;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> =<span class="number">404</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置自动更新"><a href="#配置自动更新" class="headerlink" title="配置自动更新"></a>配置自动更新</h3><p>Let’s Encrypt 签发的证书只有 90 天有效期，推荐使用脚本定期更新<br>创建脚本文件并赋予执行权限<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> <span class="keyword">shell</span></span><br><span class="line"><span class="keyword">cd</span> <span class="keyword">shell</span></span><br><span class="line"><span class="keyword">vi</span> renew_cert.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure></p><p>并复制下面内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cd</span> /root/ssl/</span><br><span class="line">python acme_tiny.py --account-key account.key --csr domain.csr --acme-dir /root/www/challenges/ &gt; signed.crt || <span class="built_in">exit</span></span><br><span class="line">wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &gt; intermediate.pem</span><br><span class="line">cat signed.crt intermediate.pem &gt; chained.pem</span><br><span class="line">service nginx reload</span><br></pre></td></tr></table></figure></p><p>这里借助crontab来定时执行任务，它是一个可以用来根据时间、日期、月份、星期的组合来调度对重复任务的执行的守护进程。<br>在终端执行：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">crontab -e</span></span><br></pre></td></tr></table></figure></p><p>然后添加如下内容：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">1</span> * * /root/<span class="keyword">shell</span>/renew_cert.sh &gt;/dev/null <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>这样以后证书每个月都会自动更新，一劳永逸。<br>另外这里也推荐一个网站，可以监测你的证书的有效期<a href="https://letsmonitor.org/" target="_blank" rel="noopener">https://letsmonitor.org</a><br>这样的话就算完了，但是有几点需要注意下：</p><ol><li><p>dhparam的生成</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl dhparam -out <span class="regexp">/etc/</span>nginx<span class="regexp">/ssl/</span>dhparam.pem <span class="number">2048</span></span><br></pre></td></tr></table></figure></li><li><p>强制HTTPS</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#另外还有两种其他的配置方式，可以自行Google</span></span><br><span class="line"> <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>关于HSTS<br>HTTP Strict Transport Security的缩写，即：“HTTP严格传输安全”。假设一个用户从来没有访问过我的网站，并且他第一次访问的时候访问的是 <a href="http://yuxingxin.com">http://yuxingxin.com</a> ，在正常的情况下，我的服务器就会给这位用户返回一个 301 跳转到 <a href="https://yuxingxin.com">https://yuxingxin.com</a> ，并且带上上面配置的HSTS头，在用户下次访问我的博客时，只要 HSTS 还在有效期中，浏览器就会直接跳转到相对应的 https 页面，并且这是不需要经过数据传输的，直接在本地浏览器进行的处理。<br>目前大部分浏览器对HSTS的支持已经相当完美，具体各浏览器和版本的支持情况可以在<a href="http://caniuse.com/#search=HSTS" target="_blank" rel="noopener">这里</a>上查看。 但是HSTS是有缺陷的，第一次访问网站的客户端，HSTS并不工作。 要解决这个问题，就需要我们下面要讲解的HSTS preload list。它是一个站点的列表，并通过硬编码写入 Chrome 浏览器中，列表中的站点将会默认使用 HTTPS 进行访问，此外，Firefox 、Safari 、IE 11 和 Edge 也同样用一份 HSTS 站点列表，它申请加入需要一些条件：</p></li><li>有一张有效的证书（如果是使用了 SHA-1 证书签名算法的必须在 2016 年前失效）</li><li>重定向所有的 HTTP 流量到 HTTPS （ HTTPS ONLY ）</li><li>全部子域名的流量均通过 HTTPS ，如果子域名的 www 存在的话也同样需要通过 HTTPS 传输。</li></ol><ul><li>在相应的域名中输出 HSTS 响应头<br>1 过期时间至少大于 18 周（10886400 秒）<br>2 必须声明 includeSubdomains<br>3 必须声明 preload<br>4 跳转过去的那个页面也需要有 HSTS 头<br>点击<a href="https://hstspreload.org/" target="_blank" rel="noopener">这里</a>开始申请，申请成功后，你的域名就会加入到<a href="https://code.google.com/p/chromium/codesearch#chromium/src/net/http/transport*security*state_static.json" target="_blank" rel="noopener">这个列表</a><br><img src="http://upload-images.jianshu.io/upload_images/450566-d5d44b46903e8552.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ssl.png"><br>如果大多数浏览器都已经更新到新的列表，那么针对国内的 VPS ，不打开80端口，只打开 443 ，浏览器同样会跳转过来，这样就可以免备案了，不过好像这样对搜索引擎就不太友好。</li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>所有这些工作完成以后，我们可以对证书进行检测。这里是<a href="https://www.ssllabs.com/ssltest/index.html" target="_blank" rel="noopener">检测地址</a> ，下面是我的域名的检测报告。<br><img src="http://upload-images.jianshu.io/upload_images/450566-082a2a529b747654.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="report.jpeg"><br>如果是A+,则说明你的配置是好着的。另外这里也给出一个国内的<a href="https://www.chinassl.net/ssltools/ssl-checker.html" target="_blank" rel="noopener">检测网站</a>，除了以上这些步骤，可能觉得有些繁琐，就有人写了一个<a href="https://github.com/xdtianyu/scripts/blob/master/lets-encrypt/README-CN.md" target="_blank" rel="noopener">脚本</a>,它是一个快速获取/更新 Let’s encrypt 证书的 shell script，使用该脚本可以简化上面的流程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;过完年来想把博客做一个迁移，放到自己购买的服务器上，并实现自动化部署，并启用全站HTTPS&lt;/p&gt;
&lt;h2 id=&quot;hexo本地部署&quot;&gt;&lt;a href=&quot;#hexo本地部署&quot; class=&quot;headerlink&quot; title=&quot;hexo本地部署&quot;&gt;&lt;/a&gt;hexo本地部署
      
    
    </summary>
    
      <category term="Others" scheme="https://yuxingxin.com/categories/Others/"/>
    
    
      <category term="https" scheme="https://yuxingxin.com/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>Mac平台nginx相关安装配置</title>
    <link href="https://yuxingxin.com/2017/02/14/NginxConfig/"/>
    <id>https://yuxingxin.com/2017/02/14/NginxConfig/</id>
    <published>2017-02-13T16:00:00.000Z</published>
    <updated>2019-04-03T03:38:02.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>我们通过brew来安装nginx<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>nginx</span><br></pre></td></tr></table></figure></p><blockquote><p>我在安装过程中出现一个小问题,报了这样一个错误：<br><code>Error: Could not symlink share/man/man8/nginx.8/usr/local/share/man/man8 is not writable.</code><br>从上面看大体意思就是<code>/usr/local/share/man/man8</code>这个目录对当前用户无写权限，所以我们给这个目录加上就可以了</p></blockquote><p> 下图为ls -l命令结果<br><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x  <span class="number"> 38 </span>SeanLiu  admin <span class="number"> 1292 </span><span class="number"> 2 </span>13 17:28 man1</span><br><span class="line">drwxr-xr-x <span class="number"> 103 </span>SeanLiu  admin <span class="number"> 3502 </span><span class="number"> 2 </span>13 17:28 man3</span><br><span class="line">drwxr-xr-x   <span class="number"> 7 </span>root     admin  <span class="number"> 238 </span><span class="number"> 1 </span>22 18:31 man8</span><br><span class="line">-rw-r--r--   <span class="number"> 1 </span>root     admin <span class="number"> 1583 </span><span class="number"> 2 </span>10 08:19 whatis</span><br></pre></td></tr></table></figure></p><ul><li>执行<code>sudo chown -R \</code>whoami` man8`</li><li>最后执行<code>brew link nginx</code>就好了</li></ul><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><h4 id="nginx默认安装路径："><a href="#nginx默认安装路径：" class="headerlink" title="nginx默认安装路径："></a>nginx默认安装路径：</h4><p><code>/usr/local/Cellar/nginx/1.10.3</code></p><h4 id="nginx配置文件路径"><a href="#nginx配置文件路径" class="headerlink" title="nginx配置文件路径:"></a>nginx配置文件路径:</h4><p><code>/usr/local/etc/nginx</code></p><h4 id="nginx启动命令"><a href="#nginx启动命令" class="headerlink" title="nginx启动命令"></a>nginx启动命令</h4><p><code>nginx</code></p><h4 id="端口占用"><a href="#端口占用" class="headerlink" title="端口占用"></a>端口占用</h4><p>如果出现<code>nginx: [emerg] bind() to 0.0.0.0:8080 failed (48: Address already in use)</code>错误，其实是8080端口被占用了，我们可以通过修改默认端口来避免错误：<br><code>vim /usr/local/etc/nginx/nginx.conf</code><br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">8081</span>;  <span class="comment">#修改这里为其他端口如8081</span></span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   html;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>最后保存重新运行</p><h4 id="更改默认web路径"><a href="#更改默认web路径" class="headerlink" title="更改默认web路径"></a>更改默认web路径</h4><p>默认路径为<code>/usr/local/Cellar/nginx/1.10.3/html</code><br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">8081</span>;  <span class="comment">#修改这里为其他端口如8081</span></span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   html; <span class="comment">#修改这里的路径为自己的路径 如/Users/xxx/www</span></span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>然后重启nginx 执行 <code>nginx -s reload</code> 就可以了</p><h4 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h4><p>首先查找到nginx的进程号：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ps</span> -ef | <span class="keyword">grep</span> nginx</span><br></pre></td></tr></table></figure></p><p>执行上面命令，显示如下：<br><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root      <span class="number"> 713 </span>   <span class="number"> 1 </span><span class="number"> 0 </span>00:15 ?        00:00:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;</span><br><span class="line">www-data  <span class="number"> 717 </span> <span class="number"> 713 </span><span class="number"> 0 </span>00:15 ?        00:00:00 nginx: worker process</span><br><span class="line">root     <span class="number"> 5345 </span><span class="number"> 4226 </span><span class="number"> 0 </span>15:23 pts/1    00:00:00 grep --color=auto nginx</span><br></pre></td></tr></table></figure></p><p>执行以下命令:<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kill</span> -<span class="keyword">QUIT</span> <span class="number">713</span></span><br></pre></td></tr></table></figure></p><p>另外还有两种：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 快速停止</span></span><br><span class="line"><span class="keyword">kill</span> -TERM <span class="number">713</span><span class="string">`或者`</span><span class="keyword">kill</span> -INT <span class="number">713</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行停止</span></span><br><span class="line">pkill -<span class="number">9</span> nginx</span><br></pre></td></tr></table></figure><h4 id="验证nginx配置文件是否正确"><a href="#验证nginx配置文件是否正确" class="headerlink" title="验证nginx配置文件是否正确"></a>验证nginx配置文件是否正确</h4><p>终端执行以下命令：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nginx -t</span></span><br></pre></td></tr></table></figure></p><p>出现下面提示则配置是正确的<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx: the configuration <span class="keyword">file</span> /etc/nginx/nginx.<span class="keyword">conf</span> <span class="keyword">syntax</span> <span class="keyword">is</span> ok</span><br><span class="line">nginx: configuration <span class="keyword">file</span> /etc/nginx/nginx.<span class="keyword">conf</span> test <span class="keyword">is</span> successful</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;我们通过brew来安装nginx&lt;br&gt;&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
      <category term="BackEnd" scheme="https://yuxingxin.com/categories/BackEnd/"/>
    
    
      <category term="nginx" scheme="https://yuxingxin.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>前端笔记</title>
    <link href="https://yuxingxin.com/2016/11/12/vue/"/>
    <id>https://yuxingxin.com/2016/11/12/vue/</id>
    <published>2016-11-11T16:00:00.000Z</published>
    <updated>2019-03-19T02:52:23.226Z</updated>
    
    <content type="html"><![CDATA[<h3 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h3><p>最近整理了部分前端的技术点，可以做为初学这部分的童靴的一个学习清单：</p><ul><li>vue-router：Vue.js 官方路由。与 Vue.js 内核深度整合，让构建单页应用易如反掌。</li><li>vue-resource：通过 XMLHttpRequest 或 JSONP 发起请求并处理响应。</li><li>vue-loader：webpack下loader插件 可以把.vue文件 输出成组件</li><li>vuex：一个主要应用在中大型单页应用的类似于 Flux 的数据管理架构。它主要帮我们更好地组织代码，以及把应用内的的状态保持在可维护、可理解的状态。</li><li>vue-devtools：Chrome 开发者工具扩展，用于调试 Vue.js 应用。</li><li>ES6：包含了许多新的语言特性，它们将使JS变得更加强大，更富表现力。</li><li>webpack：一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。</li><li>gulp：一个自动化构建工具,开发者可以使用它在项目开发过程中自动执行常见任务。</li><li>less/sass/stylus： CSS 预处理器框架。</li><li>PostCSS： 提供了一个解析器，它能够将 CSS 解析成抽象语法树（AST）。</li><li>Flexbox： 让容器有能力让其子项目能够改变其宽度、高度(甚至顺序)，以最佳方式填充可用空间（主要是为了适应所有类型的显示设备和屏幕大小）</li><li>Media Query： 包含了一个媒体类型和至少一个使用如宽度、高度和颜色等媒体属性来限制样式表范围的表达式。</li></ul><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><ul><li>1.实例属性、方法与代理属性、方法                    vue实例生命周期</li><li>2.插值/绑定表达式/指令(带有前缀 v- 的特性)/缩写</li><li>3.计算属性  vs $watch</li><li>4.样式绑定：对象与数组语法的用法    对象语法与计算属性的结合</li><li>5.条件渲染与列表渲染</li><li>6.方法与事件处理器                            修饰符</li><li>7.表单控件绑定</li><li>8.过渡</li><li>9.组件：数据传递/父子通信/分发内容</li><li>10.计算属性的缓存依赖</li><li>11.自定义指令/过滤器<br><strong>Tips:</strong> 受 ES5 的限制，Vue.js 不能检测到对象属性的添加或删除,可以使用 $set(key, value) 实例方法</li></ul><h3 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue-router"></a>Vue-router</h3><ul><li>1.嵌套路由配置方法</li><li>2.路由对象属性以及路由的匹配规则</li><li>3.一些常见路由配置项的含义</li><li>4.配合webpack异步载入组件</li><li>5.切换钩子函数</li><li>6.路由API</li></ul><h3 id="Vue-Resource-官方现在推荐axios"><a href="#Vue-Resource-官方现在推荐axios" class="headerlink" title="Vue-Resource(官方现在推荐axios)"></a>Vue-Resource(官方现在推荐<a href="https://github.com/mzabriskie/axios" target="_blank" rel="noopener">axios</a>)</h3><ul><li><ol><li>用法<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">get</span><span class="params">(url, [options])</span></span></span><br><span class="line"><span class="function"><span class="title">head</span><span class="params">(url, [options])</span></span></span><br><span class="line"><span class="function"><span class="title">delete</span><span class="params">(url, [options])</span></span></span><br><span class="line"><span class="function"><span class="title">jsonp</span><span class="params">(url, [options])</span></span></span><br><span class="line"><span class="function"><span class="title">post</span><span class="params">(url, [body], [options])</span></span></span><br><span class="line"><span class="function"><span class="title">put</span><span class="params">(url, [body], [options])</span></span></span><br><span class="line"><span class="function"><span class="title">patch</span><span class="params">(url, [body], [options])</span></span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>2.拦截器</p></li><li>3.结合ES6</li></ul><h3 id="Vue-loader"><a href="#Vue-loader" class="headerlink" title="Vue-loader"></a>Vue-loader</h3><ul><li><p>1.vue组件编写细则</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span>, <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml"> and <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span></span></span><br></pre></td></tr></table></figure></li><li><p>2.配置文件的规则：预处理器、Loader高级配置、导出CSS文件等</p></li><li>3.带域的CSS、PostCSS 和 Autoprefixer、热加载</li><li>4.生产环境、静态检查、测试等工作流</li></ul><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><ul><li>1.一些常用的概念，State/Getters/Mutations/Actions</li><li>2.vuex工作流<br>  用户在组件中的输入操作触发 action 调用；<br>  Actions 通过分发 mutations 来修改 store 实例的状态；<br>  Store 实例的状态变化反过来又通过 getters 被组件获知。</li><li>3.一些特定规则：<br>  应用 state 存在于单个对象中；<br>  只有 mutation handlers 可以改变 state；<br>  Mutations 必须是同步的，它们做的应该仅仅是改变 state；<br>  所有类似数据获取的异步操作细节都应封装在 actions 里面。<br>  组件通过 getters 从 store 中获取 state，并通过调用 actions 来改变 state。</li></ul><h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><ul><li>1.let、const   与var的区别</li><li>2.箭头函数</li><li>3.模板字符串以及增加的新的API(Math + Number + String + Array + Object APIs)</li><li>4.表达式解构</li><li>5.原生的模块化</li><li>6.类</li><li>7.对象字面量扩展语法</li><li>8.参数：默认参数、不定参数 和 重命名参数的处理</li><li>9.新的数据结构：Set 和 WeakSet      Map 和 WeakMap</li><li>10.生成器(Generator)</li><li>11.Promise</li><li>12.Symbol</li><li>13.Proxy</li></ul><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><ul><li>1.了解CommonJS和AMD的相关规范</li><li>2.代码分割及相关配置：单文件入口和多文件入口</li><li>3.内嵌样式表</li><li>4.去重、分块、压缩、混淆等相关配置及优化</li></ul><h3 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h3><ul><li>1.关于package.json配置文件</li><li>2.处理gulp任务的常用相关命令</li><li>3.熟悉gulpfile.js文件</li><li>4.掌握gulp API:   src/dest/task/watch</li><li>5.编写自定义任务，熟悉常用插件</li></ul><h3 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h3><ul><li>1.安装和编译</li><li>2.变量</li><li>3.嵌套</li><li>4.文件导入</li><li>5.混合</li><li>6.继承</li><li>7.运算符</li><li>8.函数</li><li>9.条件判断及循环</li></ul><h3 id="Flexbox"><a href="#Flexbox" class="headerlink" title="Flexbox"></a>Flexbox</h3><ul><li>1.水平主轴和垂直交叉轴</li><li><p>2.常用的6个容器属性</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex-direction</span></span><br><span class="line"><span class="attribute">flex-wrap</span></span><br><span class="line"><span class="attribute">flex-flow</span></span><br><span class="line"><span class="attribute">justify-content</span></span><br><span class="line"><span class="attribute">align-items</span></span><br><span class="line"><span class="attribute">align-content</span></span><br></pre></td></tr></table></figure></li><li><p>3.常用的6个项目属性</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">order</span></span><br><span class="line"><span class="attribute">flex-grow</span></span><br><span class="line"><span class="attribute">flex-shrink</span></span><br><span class="line"><span class="attribute">flex-basis</span></span><br><span class="line"><span class="attribute">flex</span></span><br><span class="line"><span class="attribute">align-self</span></span><br></pre></td></tr></table></figure></li><li><p>4.常见布局：骰子布局、网格布局、圣杯布局、输入框布局、悬挂式布局、固定底栏、流式布局</p></li></ul><h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><ul><li>1.媒体类型(media type)/媒体特性(media feature)的表达式</li><li>2.逻辑运算符:and,逗号,not ,only</li><li>3.一些常用方法：排他（exclusive）覆盖（overriding）移动端优先（Mobile first）PC优先（desktop first）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;相关技术&quot;&gt;&lt;a href=&quot;#相关技术&quot; class=&quot;headerlink&quot; title=&quot;相关技术&quot;&gt;&lt;/a&gt;相关技术&lt;/h3&gt;&lt;p&gt;最近整理了部分前端的技术点，可以做为初学这部分的童靴的一个学习清单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vue-router：Vue
      
    
    </summary>
    
      <category term="FrontEnd" scheme="https://yuxingxin.com/categories/FrontEnd/"/>
    
    
      <category term="notes" scheme="https://yuxingxin.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>西安GDG上《以开发者的角度再聊Material Design》的总结</title>
    <link href="https://yuxingxin.com/2016/07/17/MaterialDesign/"/>
    <id>https://yuxingxin.com/2016/07/17/MaterialDesign/</id>
    <published>2016-07-16T16:00:00.000Z</published>
    <updated>2019-03-19T02:49:22.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>谷歌在2014年I/O大会上推出了Material Design,旨在为手机、平板电脑、台式机和“其他平台”提供更一致、更广泛的“外观和感觉”。在国内有好几种版本的翻译：材料设计/材质设计/质感设计（官方文档）/原质设计（国内设计师更倾向于这个）。</p><h2 id="三大设计原则"><a href="#三大设计原则" class="headerlink" title="三大设计原则"></a>三大设计原则</h2><h3 id="隐喻"><a href="#隐喻" class="headerlink" title="隐喻"></a>隐喻</h3><p>通过纸墨做比，光影打造空间层次和符合客观规律的特效来隐喻表面质感、光效以及运动感。</p><h3 id="鲜明、形象、深思熟虑"><a href="#鲜明、形象、深思熟虑" class="headerlink" title="鲜明、形象、深思熟虑"></a>鲜明、形象、深思熟虑</h3><p>借鉴了传统的印刷设计，从排版、网格、空间、比例、配色、图像使用上做了精心处理，尤其对色彩、图像、字体、留白明确了规范，力求构建鲜明的用户界面。</p><h3 id="有意义的动画效果"><a href="#有意义的动画效果" class="headerlink" title="有意义的动画效果"></a>有意义的动画效果</h3><p>通过符合客观运动规律的特效效果，让物体的变化以更连续、更平滑的方式呈现给用户，从而吸引用户的注意。比如转场、触摸反馈、循环揭示等</p><p>关于界面的层次：<br><img src="/assets/images/md1.png" alt="image"></p><p>从下往上依次可以分为：</p><ul><li>界面的内容</li><li>顶部导航条 App Bar</li><li>浮动按钮  FAB</li><li>状态栏&amp;底部虚拟导航键</li><li>抽屉菜单</li><li>通知栏等系统信息</li></ul><h2 id="六大部分"><a href="#六大部分" class="headerlink" title="六大部分"></a>六大部分</h2><p>官方文档分别从动画、样式、布局、组件、模式、可用性六个方面对Material Design的设计规范进行了详细阐释。</p><p>这里主要列一些5.0以后引入的新特性：</p><h3 id="1-触控涟漪"><a href="#1-触控涟漪" class="headerlink" title="1.触控涟漪"></a>1.触控涟漪</h3><p><img src="/assets/images/md2.gif" alt="image"></p><p>首先在视图 XML 中应用此功能</p><ul><li>?android:attr/selectableItemBackground 指定有界的波纹。</li><li>?android:attr/selectableItemBackgroundBorderless 指定越过视图边界的波纹。 它将由一个非空背景的视图的最近父项所绘制和设定边界。注意这个是API21引入的新特性</li></ul><p>如果要改变默认触摸反馈颜色，可以在我们自定义的主题下面主题的添加 android:colorControlHighlight 属性。</p><p>相关类是RippleDrawable。</p><p>在drawable-v21中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">ripple</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:color</span>=<span class="string">"@android:color/darker_gray"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shape</span> <span class="attr">android:shape</span>=<span class="string">"rectangle"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"@color/colorAccent"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ripple</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果要兼容5.0以下版本，我们可以使用第三方开源库<a href="https://github.com/traex/RippleEffect" target="_blank" rel="noopener">RippleEffect</a></p><p>否则可以在drawable中定义selector指定不同的状态即可</p><h3 id="2-View状态改变动画"><a href="#2-View状态改变动画" class="headerlink" title="2. View状态改变动画"></a>2. View状态改变动画</h3><p>StateListAnimator定义当视图的状态改变的时候运行动画，如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_pressed</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">objectAnimator</span> <span class="attr">android:propertyName</span>=<span class="string">"translationZ"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"@android:integer/config_shortAnimTim"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueTo</span>=<span class="string">"2dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueType</span>=<span class="string">"floatType"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:state_pressed</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:state_focused</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">objectAnimator</span> <span class="attr">android:propertyName</span>=<span class="string">"translationZ"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"100"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueTo</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueType</span>=<span class="string">"floatType"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br></pre></td></tr></table></figure><p>给视图分配动画使用android:stateListAnimator属性,代码实现可以借助AnimationInflater.loadStateListAnimator()和View.setStateListAnimator()方法。</p><ul><li>注意当你的主题是继承的Material主题，按钮默认有一个Z轴动画。如果需要避免这个动画，设置android:stateListAnimator属性为@null即可。</li></ul><p>与此相似的是animated-selector：android5.0的一些系统组件默认使用这些动画。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">animated-selector</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- provide a different drawable for each state--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">"@+id/pressed"</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/drawable_pressed"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:state_pressed</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">"@+id/focused"</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/drawable_focused"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:state_focused</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">"@id/default"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">"@drawable/drawable_default"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- specify a transition --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transition</span> <span class="attr">android:fromId</span>=<span class="string">"@+id/default"</span> <span class="attr">android:toId</span>=<span class="string">"@+id/pressed"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">animation-list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:duration</span>=<span class="string">"15"</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/drawable1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:duration</span>=<span class="string">"15"</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/drawable2"</span>/&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">animated-selector</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-循环揭示"><a href="#3-循环揭示" class="headerlink" title="3.循环揭示"></a>3.循环揭示</h3><p>它提供视觉上的持续性挡显示或者隐藏一组界面元素。通过ViewAnimationUtils.createCircularReveal()方法可以使用动画效果来揭示或者隐藏一个视图。</p><p><img src="/assets/images/md3.gif" alt="image"></p><p>关键代码<br>揭示一个先前隐藏的视图</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animator anim =</span><br><span class="line">    ViewAnimationUtils.createCircularReveal(myView, cx, cy, <span class="number">0</span>, finalRadius)<span class="comment">;</span></span><br><span class="line">myView.setVisibility(View.VISIBLE)<span class="comment">;</span></span><br><span class="line">anim.start()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>隐藏一个先前显示的视图</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Animator anim =</span><br><span class="line">    ViewAnimationUtils.createCircularReveal(myView, cx, cy, initialRadius, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">anim.addListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onAnimationEnd(animation);</span><br><span class="line">        myView.setVisibility(View.INVISIBLE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure><p>针对5.0以下如果实现，可以借用第三方库：<a href="https://github.com/ozodrukh/CircularReveal" target="_blank" rel="noopener">CircularReveal</a></p><h3 id="共享元素转场"><a href="#共享元素转场" class="headerlink" title="共享元素转场"></a>共享元素转场</h3><p>android 5.0(api 21)提供以下进入和退出效果：</p><ul><li>explode(分解)  </li><li>slide(滑动)   </li><li>fade(淡入淡出)</li></ul><p>接下来猪脚登场,共享元素过渡效果：</p><ul><li>changeBounds - 改变目标视图的布局边界</li><li>changeClipBounds - 裁剪目标视图边界</li><li>changeTransform - 改变目标视图的缩放比例和旋转角度</li><li>changeImageTransform - 改变目标图片的大小和缩放比例</li></ul><p><img src="/assets/images/SceneTransition.png" alt="image"></p><p>首先在我们继承的主题上，使用android:windowContentTransitions属性开启窗口内内容过渡效果</p><ul><li>以共享元素启动一个操作行为</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActivityOptionsCompat <span class="keyword">options</span> = ActivityOptionsCompat.</span><br><span class="line">    makeSceneTransitionAnimation(<span class="keyword">this</span>, (View)ivAvatar, <span class="string">"avatar"</span>);</span><br><span class="line">startActivity(intent, <span class="keyword">options</span>.toBundle());</span><br></pre></td></tr></table></figure><ul><li>以多个共享元素启动一个操作行为</li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;<span class="built_in">View</span>, <span class="keyword">String</span>&gt; p1 = Pair.<span class="keyword">create</span>((<span class="built_in">View</span>)ivProfile, <span class="string">"profile"</span>);</span><br><span class="line">Pair&lt;<span class="built_in">View</span>, <span class="keyword">String</span>&gt; p2 = Pair.<span class="keyword">create</span>(vPalette, <span class="string">"palette"</span>);</span><br><span class="line">Pair&lt;<span class="built_in">View</span>, <span class="keyword">String</span>&gt; p3 = Pair.<span class="keyword">create</span>((<span class="built_in">View</span>)tvName, <span class="string">"text"</span>);</span><br><span class="line">ActivityOptionsCompat options = ActivityOptionsCompat.</span><br><span class="line">    makeSceneTransitionAnimation(this, p1, p2, p3);</span><br><span class="line">startActivity(intent, options.toBundle());</span><br></pre></td></tr></table></figure><h3 id="Scrolling-Animations"><a href="#Scrolling-Animations" class="headerlink" title="Scrolling Animations"></a>Scrolling Animations</h3><p>放到后面</p><h3 id="高度和阴影"><a href="#高度和阴影" class="headerlink" title="高度和阴影"></a>高度和阴影</h3><p><img src="/assets/images/md4.png" alt="image"></p><p>Z = elevation + translationZ</p><p>主要借助elevation属性</p><h3 id="着色"><a href="#着色" class="headerlink" title="着色"></a>着色</h3><p>利用 Android 5.0（API 级别 21）及更高版本,可为位图以及定义为 Alpha 蒙版的点九图着色，主要借助android:tint 以及 android:tintMode 属性设置您的布局中的着色颜色和模式。</p><h3 id="裁剪视图"><a href="#裁剪视图" class="headerlink" title="裁剪视图"></a>裁剪视图</h3><p><img src="/assets/images/md5.png" alt="image"></p><ul><li>扩展 ViewOutlineProvider 类别。</li><li>重写 getOutline() 方法。</li><li>利用 View.setOutlineProvider() 方法设置轮廓。</li></ul><h3 id="矢量图片添加动画"><a href="#矢量图片添加动画" class="headerlink" title="矢量图片添加动画"></a>矢量图片添加动画</h3><p>先是xml文件，对应类是VectorDrawable<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">vector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:height</span>=<span class="string">"64dp"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:width</span>=<span class="string">"64dp"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:viewportHeight</span>=<span class="string">"600"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:viewportWidth</span>=<span class="string">"600"</span> &gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">group</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:name</span>=<span class="string">"rotationGroup"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:pivotX</span>=<span class="string">"300.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:pivotY</span>=<span class="string">"300.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:rotation</span>=<span class="string">"45.0"</span> &gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:name</span>=<span class="string">"v"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:fillColor</span>=<span class="string">"#000000"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:pathData</span>=<span class="string">"M300,70 l 0,-70 70,70 0,0 -70,70z"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">vector</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>设置drawable，对应类是AnimatedVectorDrawable<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">animated-vector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:drawable</span>=<span class="string">"@drawable/vectordrawable"</span> &gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">target</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:name</span>=<span class="string">"rotationGroup"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:animation</span>=<span class="string">"@anim/rotation"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">target</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:name</span>=<span class="string">"v"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:animation</span>=<span class="string">"@anim/path_morph"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">animated-vector</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>上面是使用了两个属性动画，对应类是ObjectAnimator</p><p>其中旋转动画和变形动画：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;objectAnimator  </span><br><span class="line">    xmlns:<span class="attribute">android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    android:<span class="attribute">duration</span>=<span class="string">"6000"</span>  </span><br><span class="line">    android:<span class="attribute">propertyName</span>=<span class="string">"rotation"</span>  </span><br><span class="line">    android:<span class="attribute">valueFrom</span>=<span class="string">"0"</span>  </span><br><span class="line">    android:<span class="attribute">valueTo</span>=<span class="string">"360"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;objectAnimator  </span><br><span class="line">    xmlns:<span class="attribute">android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    android:<span class="attribute">duration</span>=<span class="string">"3000"</span>  </span><br><span class="line">    android:<span class="attribute">propertyName</span>=<span class="string">"pathData"</span>  </span><br><span class="line">    android:<span class="attribute">valueFrom</span>=<span class="string">"M300,70 l 0,-70 70,70 0,0   -70,70z"</span>  </span><br><span class="line">    android:<span class="attribute">valueTo</span>=<span class="string">"M300,70 l 0,-70 70,0  0,140 -70,0 z"</span>  </span><br><span class="line">    android:<span class="attribute">valueType</span>=<span class="string">"pathType"</span>/&gt;</span><br></pre></td></tr></table></figure></p><h3 id="从图像萃取颜色"><a href="#从图像萃取颜色" class="headerlink" title="从图像萃取颜色"></a>从图像萃取颜色</h3><p>如果要萃取这些颜色，可以通过如下函数：</p><p><img src="/assets/images/md6.png" alt="image"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Palette</span><span class="selector-class">.from</span>(<span class="selector-tag">bitmap</span>)<span class="selector-class">.generate</span>()</span><br><span class="line"><span class="selector-tag">Palette</span><span class="selector-class">.generateAsync</span>(<span class="selector-tag">bitmap</span>,<span class="selector-tag">paletteAsyncListener</span>)</span><br></pre></td></tr></table></figure><p>然后可以通过 Palette.getVibrantColor方法获取色值</p><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>颜色不宜过多。选取一种主色、一种辅助色（非必需），在此基础上进行明度、饱和度变化，构成配色方案。(<a href="https://www.materialpalette.com" target="_blank" rel="noopener">https://www.materialpalette.com</a>)</p><h3 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h3><p>建议模仿现实中的折纸效果，通过扁平色彩表现空间和光影。这里也推荐下这个插件：<a href="https://github.com/konifar/android-material-design-icon-generator-plugin" target="_blank" rel="noopener">https://github.com/konifar/android-material-design-icon-generator-plugin</a></p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>优先使用图像。然后可以考虑使用插画。</p><h3 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h3><p>英文官方建议Roboto字体，中文推荐Noto(思源黑体)，另外官方也开源了<a href="http://fonts.google.com/" target="_blank" rel="noopener">字体库</a>,需翻墙</p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>这里列出部分尺寸：</p><ul><li>所有可操作元素最小点击区域尺寸：48dp X 48dp。</li><li>栅格系统的最小单位是8dp，一切距离、尺寸都应该是8dp的整数倍。以下是一些常见的尺寸与距离：（推荐网格校正工具：keyline pushing）</li><li>顶部状态栏高度：24dp</li><li>Appbar最小高度：56dp</li><li>底部导航栏高度：48dp</li><li>悬浮按钮尺寸：56x56dp/40x40dp</li><li>用户头像尺寸：64x64dp/40x40dp</li><li>小图标点击区域：48x48dp</li><li>侧边抽屉到屏幕右边的距离：56dp</li><li>卡片间距：8dp</li><li>分隔线上下留白：8dp</li><li>大多元素的留白距离：16dp</li></ul><p>推荐国外开发者贡献的一个开源库：<a href="https://github.com/DmitryMalkovich/material-design-dimens" target="_blank" rel="noopener">https://github.com/DmitryMalkovich/material-design-dimens</a>  里面总结了一些Material Design的设计规范，另外也推荐一款网格校正工具：<a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwiB17eglZvOAhVJ72MKHdcIADUQFggfMAA&amp;url=https%3A%2F%2Fplay.google.com%2Fstore%2Fapps%2Fdetails%3Fid%3Dcom.faizmalkani.keylines%26hl%3Dzh_CN&amp;usg=AFQjCNFaXp2sbsfOHk8bifBkhuS38VukCw&amp;sig2=pEOMduInSxFH9v2qvjPcYw" target="_blank" rel="noopener">keyline pushing</a></p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>这里列出来一些官方组件，可供我们开发Material Design时使用</p><ul><li>RecyclerView</li><li>CardView</li><li>DrawerLayout</li><li>NavigationView</li><li>Toolbar</li><li>FloatingActionButton</li><li>Snackbar</li><li>TextInputLayout</li><li>TextInputEditText</li><li>CoordinatorLayout</li><li>TabLayout</li><li>AppBarLayout</li><li>SwipeRefreshLayout</li><li>CollapsingToolbarLayout</li><li>BottomSheetBehavior</li><li>PercentRelativeLayout</li><li>Palette</li><li>PagerTabStrip</li><li>PagerTitleStrip</li><li>SlidingPanelLayout</li></ul><h3 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h3><p>关于RecyclerView的几点总结：</p><ul><li>RecyclerView.LayoutManager    :负责Item视图的布局的显示管理</li><li>RecyclerView.ItemDecoration    :给每一项Item视图添加子View,如加分割线等</li><li>RecyclerView.ItemAnimator:负责处理数据添加或者删除时候的动画效果</li><li>RecyclerView.Adapter:为每一项Item创建视图</li><li>RecyclerView.ViewHolder:承载Item视图的子布局</li></ul><p>与ListView的对比：</p><ul><li>RecyclerView需借助ViewHolder模式来实现Adapter</li><li>RecyclerView可以自定义Item布局：listview只能以垂直线性排列的方式来布局Item,而RecyclerView借助RecyclerView.LayoutManager可以实现多种布局，如网格、瀑布流等</li><li>Item 动画：借助RecyclerView.ItemAnimator很容易实现item动画</li><li>数据源：listview针对不同的数据源可以有不同的适配器，而RecyclerView需要借助RecyclerView.Adapter自定义实现适配器来提供数据。</li><li>Item Decoration：listview可以通过android:divider很容易实现分割线等，而RecycerView则需要借助RecyclerView.ItemDecoration</li><li>Item Click : listview可以通过AdapterView.OnItemClickListener来实现，而RecyclerView则只提供了RecyclerView.OnItemTouchListener</li></ul><h3 id="CardView"><a href="#CardView" class="headerlink" title="CardView"></a>CardView</h3><p><img src="/assets/images/md7.png" alt="image"></p><p>两个属性：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">app:</span>cardCornerRadius</span><br><span class="line"><span class="symbol">app:</span>cardBackgroundColor</span><br></pre></td></tr></table></figure><h3 id="Toolbar"><a href="#Toolbar" class="headerlink" title="Toolbar"></a>Toolbar</h3><p>用来替代ActionBar，可以当做一个普通的ViewGroup来使用，所以来说比前者更灵活</p><h3 id="AppBarLayout"><a href="#AppBarLayout" class="headerlink" title="AppBarLayout"></a>AppBarLayout</h3><p>常作为Toolbar和其他View的父View配合CoordinatorLayout使用来实现Scrolling Animation</p><h3 id="FloatingActionButton"><a href="#FloatingActionButton" class="headerlink" title="FloatingActionButton"></a>FloatingActionButton</h3><p>浮动Button,也可以加入二级菜单</p><h3 id="Snackbar"><a href="#Snackbar" class="headerlink" title="Snackbar"></a>Snackbar</h3><p>带有动作的Toast</p><h3 id="TabLayout"><a href="#TabLayout" class="headerlink" title="TabLayout"></a>TabLayout</h3><p>常和ViewPager搭配使用，比较方便</p><h3 id="CoordinatorLayout-Behavior"><a href="#CoordinatorLayout-Behavior" class="headerlink" title="CoordinatorLayout.Behavior"></a>CoordinatorLayout.Behavior</h3><p>CoordinatorLayout是一个比较重要的类，大致主要分这几点：</p><ul><li>一个抽象内部类</li><li>利用泛型是指定我们应用这个Behavior的view的类型</li><li>自定义Behavior：某个View监听另一个view的状态变化，例如大小、位置、显示状态等：layoutDependendsOn和onDependentViewChanged方法；</li><li>某个view监听CoordinatorLayout里的滑动状态：onStartNestedScroll和onNestedPreScroll方法。</li><li>CoordinatorLayout 所做的事情就是当成一个通信的 桥梁 ，连接不同的view。使用 Behavior 对象进行通信。</li></ul><p>两个常见用例：</p><ul><li>CoordinatorLayout与悬浮操作按钮</li></ul><ol><li><p>CoordinatorLayout是用来协调其子view们之间动作的一个父view，而Behavior就是用来给CoordinatorLayout的子view们实现交互的。</p></li><li><p>FloatingActionButton作为一个子View添加进CoordinatorLayout并且将CoordinatorLayout传递给 Snackbar.make()</p></li></ol><ul><li>CoordinatorLayout与app bar</li></ul><ol><li><p>使用AppBarLayout可以让你的Toolbar与其他view（比如TabLayout的选项卡）能响应被标记了ScrollingViewBehavior的View的滚动事件</p></li><li><p>这里使用了CollapsingToolbarLayout的app:layout_collapseMode=”pin”来确保Toolbar在view折叠的时候仍然被固定在屏幕的顶部。借助app:layout_collapseMode=”parallax”（以及使用app:layout_collapseParallaxMultiplier=”0.7”来设置视差因子）来实现视差滚动效果（比如CollapsingToolbarLayout里面的一个ImageView），这种情况和CollapsingToolbarLayout的app:contentScrim=”?attr/colorPrimary”属性一起配合更完美。</p></li></ol><p>总结：</p><ul><li>CoordinatorLayout必须作为整个布局的父布局容器。</li><li>给需要滑动的组件设置 app:layout_scrollFlags=”scroll|enterAlways” 属性。</li><li>给你的可滑动的组件，也就是RecyclerView 或者 NestedScrollView 设置如下属性:app:layout_behavior = @string/appbar_scrolling_view_behavior</li><li>给需要有折叠效果的组件设置 layout_collapseMode属性。</li></ul><h3 id="Chris-Banes"><a href="#Chris-Banes" class="headerlink" title="Chris Banes"></a>Chris Banes</h3><p>android.support:design库作者</p><p>github: <a href="https://github.com/chrisbanes" target="_blank" rel="noopener">https://github.com/chrisbanes</a><br>google+: <a href="https://plus.google.com/+ChrisBanes" target="_blank" rel="noopener">https://plus.google.com/+ChrisBanes</a><br>twitter: <a href="https://twitter.com/chrisbanes" target="_blank" rel="noopener">https://twitter.com/chrisbanes</a><br>blog: <a href="http://chris.banes.me/" target="_blank" rel="noopener">http://chris.banes.me/</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>阴影：android:elevation 和 android:translationZ</p></li><li><p>调色：通过android:colorPrimary 和 android:colorAccent、Palette萃取等</p></li><li><p>图标：使用遵循material design spec的icon</p></li><li><p>尺寸：注意8dp的整数倍</p></li><li><p>动效：波纹动画、循环揭示、共享元素转场、滑动、SVG动画等</p></li><li><p>组件：FAB、Appbar、Tabs、Cards、Lists等</p></li></ul><h2 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h2><h3 id="样式与布局兼容"><a href="#样式与布局兼容" class="headerlink" title="样式与布局兼容"></a>样式与布局兼容</h3><blockquote><p>可以写对应的样式文件和布局文件</p><ul><li>res/values/styles.xml.</li><li>res/values-v21/styles.xml.</li><li>res/layout/my_activity.xml</li><li>res/layout-v21/my_activity.xml</li></ul></blockquote><h3 id="使用支持库提供的组件"><a href="#使用支持库提供的组件" class="headerlink" title="使用支持库提供的组件"></a>使用支持库提供的组件</h3><h3 id="使用兼容的主题：Theme-AppCompat"><a href="#使用兼容的主题：Theme-AppCompat" class="headerlink" title="使用兼容的主题：Theme.AppCompat"></a>使用兼容的主题：Theme.AppCompat</h3><blockquote><p>以下组件可以借助兼容主题来实现已有样式</p><ul><li>EditText</li><li>Spinner</li><li>CheckBox</li><li>RadioButton</li><li>SwitchCompat</li><li>CheckedTextView</li></ul></blockquote><h3 id="调色板"><a href="#调色板" class="headerlink" title="调色板"></a>调色板</h3><p><img src="/assets/images/md8.png" alt="image"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"android:Theme.Material"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:colorPrimary"</span>&gt;</span>@color/primary<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:colorPrimaryDark"</span>&gt;</span>@color/primary_dark<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:colorAccent"</span>&gt;</span>@color/accent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用第三方组件库"><a href="#使用第三方组件库" class="headerlink" title="使用第三方组件库"></a>使用第三方组件库</h3><h3 id="自己造轮子"><a href="#自己造轮子" class="headerlink" title="自己造轮子"></a>自己造轮子</h3><p>先<a href="http://developer.android.com/design/material/index.html" target="_blank" rel="noopener">熟悉API</a>，再查看官方设计指南，利用现有API进行封装</p><h2 id="Best-In-Class-Android-Design"><a href="#Best-In-Class-Android-Design" class="headerlink" title="Best-In-Class Android Design"></a>Best-In-Class Android Design</h2><p>Material Design团队整理的Google Play上比较好的MD风格的App</p><p><img src="/assets/images/md9.png" alt="image"></p><p><a href="https://play.google.com/store/apps/collection/promotion_3001769_io_awards" target="_blank" rel="noopener">https://play.google.com/store/apps/collection/promotion_3001769_io_awards</a></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>这次的PPT<a href="https://pan.baidu.com/s/1dFLqrs9" target="_blank" rel="noopener">下载地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;谷歌在2014年I/O大会上推出了Material Design,旨在为手机、平板电脑、台式机和“其他平台”提供更一致、更广泛的“外观和感觉
      
    
    </summary>
    
      <category term="Android" scheme="https://yuxingxin.com/categories/Android/"/>
    
    
      <category term="Material Design" scheme="https://yuxingxin.com/tags/Material-Design/"/>
    
  </entry>
  
  <entry>
    <title>从Android Studio来谈开发工具</title>
    <link href="https://yuxingxin.com/2016/03/01/AndroidStudio/"/>
    <id>https://yuxingxin.com/2016/03/01/AndroidStudio/</id>
    <published>2016-02-29T16:00:00.000Z</published>
    <updated>2019-03-19T02:46:56.800Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>不得不说这是一个老生常谈的话题，从我们开始学习一门新语言或者接触一个新的开发平台，面临的第一个问题就是开发工具的选择与熟悉，写这个话题一方面是MDG第一篇总结，另一方面也是知乎上一个用户问的一个问题，他想让我推荐一本以Android Studio(后面都简称as)为开发工具的Android入门书籍，其实做久了Android的都知道，网上讲解as的系列文章有很多（我把不错的都列在文章结尾），然后呢，Android入门书籍也有很多，其中大家公认的郭神的《第一行代码》算是经典，但是这本书写的比较早，里面的代码所用的开发工具还都基于eclipse,然后这对于我们新进入Android开发领域的同学似乎有点犯难了，总觉得有本两者结合的书那该有多好。其实这些都无可厚非，这篇文章想从Android Studio下手（当然我会挑常用的来列）来聊聊开发工具的一些琐碎的东西。</p><p>不得不说我是一个JetBrains公司的超级粉，从Web开发的IntelliJ IDEA到前端开发的WebStorm,从Python开发的PyCharm到Android开发的as（基于JetBrains的IntelliJ IDEA Community Edition），从我一开始学习了其中一个，然后切换到其他任何一个，其实都不是很困难，因为他们有很多相似的地方。这里先不谈这些，言归正传：我把开发工具的熟悉呢分为三个方面：代码编辑、编译调试、发布部署，这也是按照我们项目开发的流程来的。在说这个之前，可能有必要提下它与eclipse的工程区别：</p><ul><li>as是单个工程的开发模式；其实JetBrains公司的其它几款产品也有类似开发模式。</li><li>as中的application相当于eclispe中的workspace</li><li>as中的module相当于eclipse中的project</li></ul><h3 id="1-关注Tips"><a href="#1-关注Tips" class="headerlink" title="1. 关注Tips"></a>1. 关注Tips</h3><p>如果你在第一次打开之后设置了不再显示，也没有关系，可以从菜单——&gt;Help——&gt;Tip of the day中找到:</p><p><img src="/assets/images/tips.png" alt="image"></p><p>另外值得一提的是，国外开发者整理的Tips库<a href="https://github.com/pavlospt/Android-Studio-Tips-by-Philippe-Breault" target="_blank" rel="noopener">Android-Studio-Tips-by-Philippe-Breault</a></p><h3 id="2-Android-Studio项目目录"><a href="#2-Android-Studio项目目录" class="headerlink" title="2. Android Studio项目目录"></a>2. Android Studio项目目录</h3><p>关于项目目录的一些菜单,如下图这部分：</p><p><img src="/assets/images/nav1.png" alt="image"> <img src="/assets/images/nav.png" alt="image"></p><ul><li>文件和导航关联<br>我们在写代码的时候经常需要打开某个文件的时候，想在左边的文件树上自动打开关联到位置，这样很方便的找寻本目录下的其他文件或者其他的相关文件，AS提供了这几种方案：</li></ul><ol><li>通过点击图中红框圈住的最左边的小圆圈</li><li>通过设置勾选<code>AutoScroll to Source</code>和<code>AutoScroll from source</code></li><li>通过点击小圆圈右边的折叠导航按钮打开Navigation Bar，操作方式就是打开文件的时候，然后就会出现一个下拉，基本就是这个文件所在目录的文件列表，还可以使用上下左右的键位来选择其他目录。</li></ol><ul><li>AS针对左边项目目录提供两种视图：平铺和树状（如上图），这里有一点值得要提的是，当我们想在同一个目录下同时建立两个空文件夹时，在这两种视图模式下，记得要把<code>Hide Empty Middle Package</code> 和 <code>Compact Empty Middle Package</code>给勾掉</li><li>如果我们想在类中的成员显示在左边导航，记得勾选<code>Show Members</code></li></ul><h3 id="3-常用设置"><a href="#3-常用设置" class="headerlink" title="3. 常用设置"></a>3. 常用设置</h3><ul><li>中文乱码：找到IDE preferences -&gt; Appearance,在右侧勾选上“Override default fonts by”，然后在第一个下拉框中选择字体为“simsun”，然后apply，重启IDE，可以解决。</li><li>设置快捷键：IDE preferences -&gt; Keymap  可以选择自己喜欢的Eclipse快捷键或者其他的。当然也可以修改或者删除</li><li>设置行号：IDE preferences -&gt; Editor -&gt; General -&gt; Appearance -&gt; Show line numbers 勾选 ，然后点击应用。</li><li>设置主题：找到IDE preferences -&gt; Appearance ,右侧Theme,我自己有在用Darcula。</li><li>Eclipse工程导入AS：直接通过File -&gt; Import Project然后在弹出的对话框中选择项目，注意Project和Module的区别。</li><li>右键删除项目：我们首先需要通过在Module Setting中移除module，即在打开的对话框点击减号，然后回到项目可以发现右键菜单的delete选项。</li><li>我们只有每次引用一些类的时候必须要导包，而Studio可以通过设置自动导包:<br>到 Preferences -&gt; Editor —&gt; General -&gt; Auto Import -&gt; Java 把以下选项勾上就OK了</li></ul><p><img src="/assets/images/import.png" alt="image"> </p><h3 id="4-常用快捷键"><a href="#4-常用快捷键" class="headerlink" title="4.常用快捷键"></a>4.常用快捷键</h3><table><thead><tr><th>操作</th><th>Mac OSX</th><th>Win/Linux</th></tr></thead><tbody><tr><td>注释代码(//)</td><td>Cmd + /</td><td>Ctrl + /</td></tr><tr><td>注释代码(/**/)</td><td>Cmd + Option + /</td><td>Ctrl + Shift + /</td></tr><tr><td>格式化代码</td><td>Cmd + Option + L</td><td>Ctrl + Alt + L</td></tr><tr><td>清除无效包引用</td><td>Option + Control + O</td><td>Alt + Ctrl + O</td></tr><tr><td>查找</td><td>Cmd + F</td><td>Ctrl + F</td></tr><tr><td>查找+替换</td><td>Cmd + R</td><td>Ctrl + R</td></tr><tr><td>上下移动代码</td><td>Option + Shift + Up/Down</td><td>Alt + Shift + Up/Down</td></tr><tr><td>删除行</td><td>Cmd + Delete</td><td>Ctrl + Y</td></tr><tr><td>扩大缩小选中范围</td><td>Option + Up/Down</td><td>Ctrl + W/Ctrl + Shift + W</td></tr><tr><td>快捷生成结构体</td><td>Cmd + Option + T</td><td>Ctrl + Alt + T</td></tr><tr><td>快捷覆写方法</td><td>Cmd + O</td><td>Ctrl + O</td></tr><tr><td>快捷定位到行首/尾</td><td>Cmd + Left/Right</td><td>Ctrl + Left/Right</td></tr><tr><td>折叠展开代码块</td><td>Cmd + Plus,Minus</td><td>Ctrl + Plus/Minus</td></tr><tr><td>折叠展开全部代码块</td><td>Cmd + Shift + Plus,Minus</td><td>Ctrl + Shift + Plus,Minus</td></tr><tr><td>文件方法结构</td><td>Cmd + F12</td><td>Ctrl + F12</td></tr><tr><td>查找调用的位置</td><td>Ctrl + Option + H</td><td>Ctrl + Alt + H</td></tr><tr><td>大小写转换</td><td>Cmd + Shift + U</td><td>Ctrl + Shift + U</td></tr></tbody></table><h3 id="5-Gradle基础"><a href="#5-Gradle基础" class="headerlink" title="5. Gradle基础"></a>5. Gradle基础</h3><p>先来看项目结构：</p><ul><li>src/main/            //源代码</li><li>src/androidTest/     //测试代码</li></ul><p>源代码下面：</p><ul><li>java/          //Java代码</li><li>resources/    //资源文件</li></ul><p>另外还有针对Android特有的文件和文件夹：</p><ul><li>AndroidManifest.xml</li><li>res/</li><li>assets/</li><li>aidl/</li><li>rs/</li><li>jni/</li><li>jniLibs/</li></ul><p>对于旧工程不满足默认的项目工程目录，所以我们还需要灵活配置，让它们重新映射到新的资源文件或者文件夹里面：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            manifest<span class="selector-class">.srcFile</span> <span class="string">'AndroidManifest.xml'</span></span><br><span class="line">            java<span class="selector-class">.srcDirs</span> = [<span class="string">'src'</span>]</span><br><span class="line">            resources<span class="selector-class">.srcDirs</span> = [<span class="string">'src'</span>]</span><br><span class="line">            aidl<span class="selector-class">.srcDirs</span> = [<span class="string">'src'</span>]</span><br><span class="line">            renderscript<span class="selector-class">.srcDirs</span> = [<span class="string">'src'</span>]</span><br><span class="line">            res<span class="selector-class">.srcDirs</span> = [<span class="string">'res'</span>]</span><br><span class="line">            assets<span class="selector-class">.srcDirs</span> = [<span class="string">'assets'</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        androidTest.setRoot(<span class="string">'tests'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h4><p>通常情况下任务约定由assemble(编译)、check(检查)、build(构建)、clean(清理)  其中build包含了assemble和check</p><p>Build Types:<br>默认Android plugin提供了debug和release两个构建变量，当然，我们同时也可以自定义构建变量，如下：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">android </span>&#123;</span><br><span class="line">    <span class="keyword">buildTypes </span>&#123;</span><br><span class="line">        <span class="built_in">debug</span> &#123;</span><br><span class="line">            applicationIdSuffix <span class="string">".debug"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">jnidebug </span>&#123;</span><br><span class="line">            initWith(<span class="keyword">buildTypes.debug)</span></span><br><span class="line"><span class="keyword"> </span>           applicationIdSuffix <span class="string">".jnidebug"</span></span><br><span class="line">            <span class="keyword">jniDebuggable </span>true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面新建了一个jnidebug的构建变量，另外为了保证可以安装在同一个设备上，我们这里修改了他们的applicationId，即加上分别加上后缀’.debug’和’.jnidebug’，另外通过initWith方法来指定jniDebug是从debug这个基础上的一个副本，然后通过jniDebuggable配置来启用JNI组件的构建调试。</p><p>除此之外，我们也可以用构建变量添加指定的代码和资源文件，对于每个构建变量，在一个新的sourceSet被创建后，它都有一个默认位置：<code>src/&lt;buildtypename&gt;</code>,如：<code>src/debug/java</code> 目录，它可以用来放只在编译debug APK时才会被编译的代码，这也就意味着构建变量名字不能是<code>main</code>或者<code>androidTest</code>（插件强制的），它们必须是独一无二的。</p><p>像其他源码集一样，它可以被重新定位：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    sourceSets<span class="selector-class">.jnidebug</span><span class="selector-class">.setRoot</span>(<span class="string">'foo/jnidebug'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然，对应我们也会生成一个新的assembleJnidebug任务，它和默认的debug/release一样。</p><h4 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h4><p>签名一个App需要下面这几样：</p><ul><li>A keystore</li><li>A keystore password</li><li>A key alias name</li><li>A key password</li><li>The store type</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题外话&quot;&gt;&lt;a href=&quot;#题外话&quot; class=&quot;headerlink&quot; title=&quot;题外话&quot;&gt;&lt;/a&gt;题外话&lt;/h3&gt;&lt;p&gt;不得不说这是一个老生常谈的话题，从我们开始学习一门新语言或者接触一个新的开发平台，面临的第一个问题就是开发工具的选择与熟悉，写这个话
      
    
    </summary>
    
      <category term="Android" scheme="https://yuxingxin.com/categories/Android/"/>
    
    
      <category term="Android Studio" scheme="https://yuxingxin.com/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>新的一年，每一天都在努力为明天，记新年开篇</title>
    <link href="https://yuxingxin.com/2016/02/25/NewYearPlanSummary/"/>
    <id>https://yuxingxin.com/2016/02/25/NewYearPlanSummary/</id>
    <published>2016-02-24T16:00:00.000Z</published>
    <updated>2019-03-19T02:49:42.782Z</updated>
    
    <content type="html"><![CDATA[<p>早就计划写这篇文章了，可是没想到过完年来白天晚上一直忙，刚刚工作搭档说晚上有事，今晚不加班，于是就回来补上了这篇文章，虽现在是自由职业，却发现比上班还忙，我每天还照常和上班族一样赶着清晨的第一缕阳光一路走着来到年前的办公室开始这一天的工作。说起过去的一年，MobDevGroup（以下都缩写为MDG）是我花时间最多的一个站，从最初的想法，把浏览器书签整理，到后面越来越多的文章加进来，以至于把我的印象笔记也塞的满满的，不方便查找可能是我一开始的初衷，于是如网站那样分了工具、设计、开发这几块，然后每一个版块下面又分了好多子块，归根结底其实还是想通过分类好找一点，但随着关注的人多了，压力一下子大了起来，很多朋友通过各种方式都给我提了许多建议，说来惭愧，的确是一个人精力有限，也只能部分采纳（不过建议真的都是不错的，这里真希望更多愿意分享的移动开发朋友加入进来经营这个），我从中大概总结了几点想法通过这篇文章分享出来，这也是我在过年假期期间一直在琢磨的一个问题。</p><p>如果你看过MDG的话，你会发现有一个问题就是知识点比较零散，不系统，尽管它分过类，我也大概了解关注公众号的用户，可能很多基础知识都不是太牢固，包括我在内对于不常用到的知识点一下子也是很陌生，所以今年我想尽可能的把MDG重点放在系统的构建知识点上面，年前关注MDG的同学可能看到我通过公众平台和MDG微博放的几张图，总结的开发的知识点，但是说实在这个比较老了，另外也太琐碎，所以仅供小伙伴们参考学习。于是就有了现在这个念头，同时也是帮助我自己建立知识体系。移动开发领域已经有很多优秀的公众号（后面我会列举一些我关注的），他们每天都会在上面发布一些不错的技术，有总结，有黑科技、有新技术资讯等等，一个人精力有限，所以我想既然有这么多人都在做了，我就默默关注学习吧，而MDG就换个角度来做一些可以构建基础知识体系的知识点总结吧，虽比不上大神们的公众号，不过出发点是更加系统的学习移动开发技术，从这一点来讲，我会尽力做好它。</p><p>过年一直琢磨的这几点，我把它列了出来：</p><ul><li>构建开发的基础知识体系，或许你在MDG文章分类能看到这点，不过这次想以原创文章的方式来总结，时间可能会长一点，但没关系，来日方长嘛。</li><li>Q&amp;A问与答，大体是列一些平时学习过程中常见的问题及解决办法，并总结出来，有这个想法还是我去年看的一本书《App研发录：架构设计、Crash分析和竞品技术分析》,作者对于Crash异常的整理与分析不得不让人竖起大拇指，很少会有人这么去写书，因为这个工作可能需要耗费很多精力来做，同时也更需要平时不断的积累。</li><li>开源库，这个其实在我们开发过程中已经离不开了，它可以极大的提高我们的开发效率，所以很有必要学习它，大体是从开源库子版块选择有代表性的去做专题。</li><li>辅助开发的资源，也是以文章总结的形式列出来，除了MDG上列出的分类外，比如还可以是我们平时用的软件、看的书籍、关注的App应用、优秀的微信公众号、更可以扩展到kindle帮助阅读的一些使用技巧，浏览器辅助插件，程序员的一些健康注意事项，总之都是围绕我们这一行的做一些总结。</li></ul><p>这里还是有必要列一下之前我在博客中提到的一些资源：</p><ul><li>官网或者官方视频</li><li>开源社区（GitHub、Git@OSC等）</li><li>技术分享站(掘金、开发者头条、极客头条等)</li><li>订阅开发者博客及开发者周报</li><li>关注开发者微信公众号</li><li>关注技术问答社区（StackOverflow、SegmentFault等）</li><li>关注网络问答社区（知乎、Quora等）</li><li>关注阅读社区（Medium、简书等）</li><li>关注极客站（V2EX、reddit等）</li></ul><p>之前一直有人争议全栈，也有人问过我这方面的问题，在这里我想借用自己的经历来说下我对所谓的“全栈”看法，我一毕业就进了一家创业公司，当时还没有任何移动开发人员，更别说有人和你交流讨论了，一开始Android做起，第一个版本出来后慢慢开始有了团队，后面又经历Hybrid App的开发，iOS的移植，Web App的开发，一路走来，由于是自学，踩了不少坑，总算完成了各个平台的实现，所以我想全栈的苗头一开始都源自老板给逼的，另外还有一点，随着你业务复杂度的增加，你会发现单靠原生开发已经不能更好满足需求，这时候你各种找资料发现HTML5结合会更好，所以又要开始学前端JS，各种形形色色的前端框架，这样随着需求不断增加，你依旧不断地去一路学习。所以到这里我觉得全栈真的不是说简单地学完这个学那个，那样真的是最后什么都不精，我理解的全栈应该是<strong>根据你自己的核心业务需求来做周边一圈的技术栈，它和你专一个方向不矛盾，相反或许能为你的需求找到更好的解决方案从而更好地服务核心技术</strong>。</p><p>我们平时做客户端开发的都会有这样一个问题：就是只能做客户端，没有人给提供服务端，就懒得做了，这时候你该想要是有人给我提供服务端，我也能。。。但是记得总有这么一些人其实不这么想，用郭神的一句话“每当你在感叹，如果有这样一个东西就好了的时候，请注意，其实这是你的机会”，因为等别人接口其实是一个被动过程，更何况自己如果想做点东西，没人愿意无偿给你写后端，这时候有人可能会想到聚合数据，但这个只能是一些公共的数据服务接口，并且也有限制条件，我们何尝不自己没事琢磨点怎么弄数据呢，你之前搞过前端的对JS熟悉，是不是也可以会点Node.js做个服务端 造点假数据，如果不想造也完全可以学点Python搞一下爬虫，抓点数据过来，想写好接口再了解Restful架构，如果是考虑安全又想到认证，OAuth、加密、再不行你不是懂Http吗，延伸一下那Https呢？就这样随着你需求的扩大，你的知识体系也一直在扩展，今天还看到一个同学在群里问做Android开发的为什么要懂http、https这类问题，他觉得没有用到，其实不然。</p><p>很多时候，提出来一个词就让我们觉得特牛逼，其实我觉得不必在意这些所谓的称呼，话说现在又出来一个爆栈工程师，这个世界上大牛多了去了，真的有基本你提到的他都能全搞定，但是那类人少之又少，他们的存在或许就是让人膜拜的，让你知道这一行人外有人，天外有天。所以还是那句话围绕你的核心技术栈然后根据你的需求来扩展你的知识体系，不用太在乎学多了是负担，学多了就会不精了，这里借用代码家的那句话：“做自己喜欢的事，不用太在乎规矩”,真的是这样。</p><p>最后，我也会持续更新MDG站资源，并第一时间在MDG QQ群(Android资源分享群：104575056；iOS资源分享群：69080804；移动前端资源分享群：104575412)和MDG微博分享，我平时很少有在群里聊天的习惯，不管是加的QQ群还是微信群，另一方面也没有太多时间，基本上说话都是发一些资源在里面，所以我也建议小伙伴们把更多时间留在讨论问题上，少一点吐槽和闲扯。</p><p>在假期期间，央视财经频道播出的节目《遇见大咖》系列节目第二期里，介绍的是李彦宏，里面有一个情节是百度每年的8月8号夏日狂欢在李彦宏出场时放的背景音乐《Hall of Fame》，国内南征北战演唱的一个和它调类似的歌曲叫《我的天空》，我很喜欢里面的一句歌词：“只要我还有梦 就会看到彩虹 在我的天空”，新的一年愿更多的小伙伴找准自己未来的路并坚定的走下去，你终究会在自己的天空里看到属于你的那片彩虹。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;早就计划写这篇文章了，可是没想到过完年来白天晚上一直忙，刚刚工作搭档说晚上有事，今晚不加班，于是就回来补上了这篇文章，虽现在是自由职业，却发现比上班还忙，我每天还照常和上班族一样赶着清晨的第一缕阳光一路走着来到年前的办公室开始这一天的工作。说起过去的一年，MobDevGro
      
    
    </summary>
    
      <category term="Notes" scheme="https://yuxingxin.com/categories/Notes/"/>
    
    
      <category term="notes" scheme="https://yuxingxin.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>写在最后一个工作日的MobDevGroup新年计划</title>
    <link href="https://yuxingxin.com/2016/01/29/NewYearPlan/"/>
    <id>https://yuxingxin.com/2016/01/29/NewYearPlan/</id>
    <published>2016-01-28T16:00:00.000Z</published>
    <updated>2019-03-19T02:49:37.456Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉马上要过年了，这一年总觉得走的太快，回过头来捋一捋这一年做的东西，其实有一些还是有一点意义的，比如MobDevGroup站，真的有朋友私信我说确实帮到了他们，这也是让我觉得最欣慰的地方，今天是我工作的最后一天，早上来就开始想计划下一年的工作，以前MobDevGroup在于想做全，以致于很多地方都没有做好，新的一年我打算自己开始在专题上面下功夫，大致方向是从基础知识块、Q&amp;A(问与答)、开源库三个方面总结学习。会有相关专题的内容，比如涉及基础知识的概括，常见问题的讨论，以及项目中常用的开源库的学习等等。</p><p><img src="/assets/images/newPlan.png" alt="image"></p><p>另外在过去的一年中，也有网上朋友给我提建议就是邮件订阅和QQ群，终于在年终我把这个加上了，后续新的内容会以邮件订阅的形式发出，并在QQ群通知，也可以留意网站。</p><p>写完这个就下班了，最后提前祝小伙伴新年快乐、阖家幸福！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不知不觉马上要过年了，这一年总觉得走的太快，回过头来捋一捋这一年做的东西，其实有一些还是有一点意义的，比如MobDevGroup站，真的有朋友私信我说确实帮到了他们，这也是让我觉得最欣慰的地方，今天是我工作的最后一天，早上来就开始想计划下一年的工作，以前MobDevGrou
      
    
    </summary>
    
      <category term="Notes" scheme="https://yuxingxin.com/categories/Notes/"/>
    
    
      <category term="notes" scheme="https://yuxingxin.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>西安GDG上关于主题[当Android遇上RxJava]的分享总结</title>
    <link href="https://yuxingxin.com/2016/01/10/XianGDGShare/"/>
    <id>https://yuxingxin.com/2016/01/10/XianGDGShare/</id>
    <published>2016-01-09T16:00:00.000Z</published>
    <updated>2019-03-19T02:52:29.139Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>1月10号这一天，也是值得高兴的日子，一大早起来打开手机看到《RxJava Essentials》一书的作者Ivan.Morgillo给我在推特上发的消息点赞并转发后关注了我，这让我激动不已，可能对于我这种没见过大世面的人来说，这点小事或许就足以让我自己心里乐上三天。然后就是昨天下午在西安GDG做了关于RxJava的分享，这也圆了我的梦想，当我还是初生牛犊的时候，就不断的听到GDG这个词，心里就梦想着哪一天也能站在上面讲一次，果不其然，一次偶然的机会就真应了习大大新年贺词的那句话：“只要坚持,梦想总是可以实现的”，可能对于我这种喜欢Google的开发者来说，在GDG做一次分享真是莫大的荣幸与荣耀。</p><p>##分享内容总结</p><p>大致分为以下三个主题线：</p><ul><li>1.介绍了ReactiveX、RxJava</li><li>2.Android开发中遇到的常见场景</li><li>3.关于RxJava与Android的学习</li></ul><h3 id="ReactiveX的介绍"><a href="#ReactiveX的介绍" class="headerlink" title="ReactiveX的介绍"></a>ReactiveX的介绍</h3><p>我把它总结为以下三点：</p><ul><li>1.扩展的观察者模式：通过订阅可观测对象的序列流然后做出反应。</li><li>2.迭代器模式：对对象序列进行迭代输出从而使订阅者可以依次对其处理。</li><li>3.函数式编程思想：简化问题的解决的步骤，让你的代码更优雅和简洁</li></ul><p>然后介绍了ReactiveX在各个语言和平台上的实现,<a href="http://reactivex.io/languages.html" target="_blank" rel="noopener">官方地址</a><br>最后对上面三点展开进行详细介绍：</p><ul><li>1.先介绍GoF书中的观察者模式，被观察者发出事件，然后观察者（事件源）订阅然后进行处理。并指出其中的不足：比如观察者不知道是否出错与完成，还有就是整个过程是同步，会阻塞线程，从而引出所谓的“扩展”的观察者模式，除了提到的不足作为补充外，另外还有一点：如果没有观察者，被观察者是不会发出任何事件的。</li><li>2.迭代器模式：提供一种方法顺序访问一个聚合对象中的各种元素,而又不暴露该对象的内部表示，用《RxJava Essentials》一书做的的对比：迭代器模式在事件处理上采用的是“同步/拉式”的方式，而被观察者采用的是“异步/推式”的方式，而对观察者而言，显然后者更灵活。</li><li>3.对于函数式编程举例展示了代码风格的不同。</li></ul><h3 id="RxJava的介绍"><a href="#RxJava的介绍" class="headerlink" title="RxJava的介绍"></a>RxJava的介绍</h3><p>我也按照三点作为介绍</p><ul><li>1.RxJava的核心</li><li>2.RxJava操作符</li><li>3.RxJava的扩展</li></ul><p>然后对这三点展开来讲，其中最花时间的也是这一部分。</p><h4 id="RxJava的核心对象"><a href="#RxJava的核心对象" class="headerlink" title="RxJava的核心对象"></a>RxJava的核心对象</h4><p>先是通过一个<code>Hello World</code>的例子介绍了几个容易混淆的类/接口：</p><ul><li>Observable</li><li>OnSubscribe</li><li>Observer</li><li>Subscription</li><li>Subscriber</li></ul><p>代码展示如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;String&gt; myObservable = Observable</span><br><span class="line">        .create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">                subscriber.onNext(<span class="string">"Hello World!"</span>);</span><br><span class="line">                subscriber.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">Subscriber&lt;String&gt; mySubscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">"基础写法："</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObservable.subscribe(mySubscriber);</span><br></pre></td></tr></table></figure></p><p>简化一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;String&gt; myObservable = Observable.just(<span class="string">"Hello World!"</span>);</span><br><span class="line"></span><br><span class="line">Action1&lt;String&gt; onNextAction = <span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.v(<span class="string">"Action1简化后:"</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObservable.subscribe(onNextAction);</span><br></pre></td></tr></table></figure></p><p>匿名函数写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"Hello World!"</span>).subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                Log.v(<span class="string">"匿名函数写法："</span>,s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p><p>最后用Java 8 lambdas(Retrolambda)表达式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"Hello World!"</span>).subscribe(s -&gt; Log.v(<span class="string">"lambdas写法"</span>,s));</span><br></pre></td></tr></table></figure></p><p>其中这一部分从源码角度简单概括了从被观察者创建，到观察者创建，最后再订阅的过程，并顺便指出了上面几个易混淆的类/接口之间的关系。</p><p>第二部分是关于异步的话题：</p><p>先是介绍这几种调度器：</p><ul><li>1.Schedulers.immediate()</li><li>2.Schedulers.newThread()</li><li>3.Schedulers.trampoline()</li><li>4.Schedulers.io()</li><li>5.Schedulers.computation()</li><li>6.AndroidSchedulers.mainThread()</li></ul><p>然后就是两个操作符：</p><ul><li>subscribeOn()：指定 subscribe() 所发生的线程，事件产生的线程</li><li>observeOn()：指定 Subscriber 所运行在的线程，事件消费的线程</li></ul><h4 id="RxJava操作符"><a href="#RxJava操作符" class="headerlink" title="RxJava操作符"></a>RxJava操作符</h4><p>在讲操作符之前，先是介绍了直观有趣的宝石图：这里引用了一张官方的<a href="http://reactivex.io/documentation/observable.html" target="_blank" rel="noopener">图片</a>,另外再附上一个国外程序员创建的动态的宝石图<a href="http://rxmarbles.com/" target="_blank" rel="noopener">网站</a>，虽然不全，但是作者一直在更新，相信后面会有更多，这有助于我们来理解操作符。</p><p>大致分为这几类展开介绍：</p><ul><li>创建操作符：Create, Defer, From, Interval, Just, Range, Repeat, Timer等。</li><li>变换操作符：Map、FlatMap、ConcatMap等。</li><li>过滤操作符：Debounce, Distinct, ElementAt, Filter, First, Last, Sample, Skip, SkipLast, Take, TakeLast等。</li><li>合买操作符以及自定义操作符。</li></ul><p>最后用一个例子做了下总结，需求如下：</p><ul><li>将一个为数字的字符串数组元素转换为数字</li><li>过滤掉大于10的数字</li><li>去重</li><li>取最后面3个元素</li><li>累计求和</li></ul><p>用代码实现就是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String[] numbers = &#123;<span class="string">"11"</span>, <span class="string">"2"</span>, <span class="string">"2"</span>, <span class="string">"13"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>,<span class="string">"7"</span>&#125;;</span><br><span class="line">Observable.from(numbers)</span><br><span class="line">        .map(s -&gt; Integer.parseInt(s))</span><br><span class="line">        .filter(i -&gt; i &lt; <span class="number">10</span>)</span><br><span class="line">        .distinct()</span><br><span class="line">        .takeLast(<span class="number">3</span>)</span><br><span class="line">        .reduce((number1,number2) -&gt; number1 + number2)</span><br><span class="line">        .subscribe(i -&gt; System.out.println(i));</span><br></pre></td></tr></table></figure></p><p>其中创建操作符例子如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String[] strings = &#123;<span class="string">"张三"</span>,<span class="string">"李四"</span>,<span class="string">"王五"</span>,<span class="string">"赵六"</span>&#125;;</span><br><span class="line">Observable.from(strings)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                Log.i(<span class="string">"name"</span>, s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p><p>变换操作符例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showUserName</span><span class="params">(String userName)</span></span>&#123;</span><br><span class="line">    textView.setText(userName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showUserName</span><span class="params">(String userName)</span></span>&#123;</span><br><span class="line">    Observable.just(userName).subscribe( <span class="keyword">new</span>  Action1&lt;String&gt;()&#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">                textView.setText(s);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要在显示前对这个字符串做处理，然后再展示，比如加“张三，你好”</p><ul><li>方法1：我们可以对字符串本身操作   (不合适)</li><li>方法2：我们可以放到Action1.call()方法里做处理   （不合适）</li><li>方法3：使用操作符做变换：map    （RxJava的做法）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showUserName</span><span class="params">(String userName)</span></span>&#123;</span><br><span class="line">    Observable.just(userName).map(<span class="keyword">new</span> Func1&lt;String,String&gt;()&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(String text)</span></span>&#123;</span><br><span class="line">             <span class="keyword">return</span> handleUserName(text);   </span><br><span class="line">           &#125;</span><br><span class="line">    &#125;).subscribe( <span class="keyword">new</span> Action1&lt;String&gt;()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">            textView.setText(s);</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于flatMap()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印出中国的所有省份名称。</span></span><br><span class="line">List&lt;Province&gt;  provinceList = …</span><br><span class="line">Observable.from(provinceList)</span><br><span class="line">    .map(<span class="keyword">new</span> Func1&lt;Province,String&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Province province)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> province.getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).subscribe(<span class="keyword">new</span> Action1&lt;String&gt;()&#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">            Log.i(“省份名称”,s)</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印出中国每个省份的所有城市  (不合适)</span></span><br><span class="line">List&lt;Province&gt;  provinceList = …</span><br><span class="line">Observable.from(provinceList)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;Province&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Province province)</span></span>&#123;</span><br><span class="line">            List&lt;City&gt; cities = province.getCities();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cities.size(); i++) &#123;</span><br><span class="line">                   City city = cities.get(i);</span><br><span class="line">                   Log.i(“城市”, city.getName());</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RxJava做法</span></span><br><span class="line">List&lt;Province&gt;  provinceList = …</span><br><span class="line">Observable.from(provinceList)</span><br><span class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;Province,Observable&lt;City&gt;&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Observable&lt;City&gt; <span class="title">call</span><span class="params">(Province province)</span></span>&#123;</span><br><span class="line">                 <span class="keyword">return</span> Observable.from(province.getCities());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;City&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(City city)</span></span>&#123;</span><br><span class="line">               Log.i(“城市”, city.getName());       </span><br><span class="line">            &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>关于flatMap的应用扩展<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//介绍回调地狱</span></span><br><span class="line">restAdapter.getApiService().getToken(<span class="keyword">new</span> Callback&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        restAdapter.getApiService().getUserInfo(token,<span class="keyword">new</span> Callback&lt;UserInfo&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">                     showMessage(userInfo.getUser);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failure</span><span class="params">(RetrofitError error)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//处理错误</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failure</span><span class="params">(RetrofitError error)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Error handling</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>如何用RxJava来解决：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">restAdapter.getApiService()</span><br><span class="line">    .getToken()</span><br><span class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;String,Observable&lt;UserInfo&gt;&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;UserInfo&gt; <span class="title">call</span><span class="params">(String token)</span></span>&#123;</span><br><span class="line">                     <span class="keyword">return</span> restAdapter.getApiService().getUserInfo(token);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;UserInfo&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(UserInfo userInfo)</span></span>&#123;</span><br><span class="line">                     showMessage(userInfo.getUser);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><p>加入线程切换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">restAdapter.getApiService().getToken()</span><br><span class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;String,Observable&lt;UserInfo&gt;&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;UserInfo&gt; <span class="title">call</span><span class="params">(String token)</span></span>&#123;</span><br><span class="line">                     <span class="keyword">return</span> restAdapter.getApiService().getUserInfo(token);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribeOn(Schedulers.io()) <span class="comment">// 指定 subscribe() 发生在 IO 线程</span></span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())<span class="comment">// 指定 Subscriber 的回调发生在主线程</span></span><br><span class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;UserInfo&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(UserInfo userInfo)</span></span>&#123;</span><br><span class="line">                     showMessage(userInfo.getUser);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>#####操作符复用：</p><p>先介绍不合适的做法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">applySchedulers</span><span class="params">(Observable&lt;T&gt; observable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> observable.subscribeOn(Schedulers.io())</span><br><span class="line">     .observeOn(AndroidSchedulers.mainThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用后，破坏了链式调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">applySchedulers(restAdapter.getApiService().getToken()</span><br><span class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;String,Observable&lt;UserInfo&gt;&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;UserInfo&gt; <span class="title">call</span><span class="params">(String token)</span></span>&#123;</span><br><span class="line">                     <span class="keyword">return</span> restAdapter.getApiService().getUserInfo(token);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    ).subscribe(<span class="keyword">new</span> Action1&lt;UserInfo&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(UserInfo userInfo)</span></span>&#123;</span><br><span class="line">                     showMessage(userInfo.getUser);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><h5 id="我们加入转换器与Compose"><a href="#我们加入转换器与Compose" class="headerlink" title="我们加入转换器与Compose()"></a>我们加入转换器与Compose()</h5><p>Transformer：继承Func1<observable<t>, Observable<r>&gt;的一个接口，其实是将一个Observable转换为另一个Observable<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Transformer&lt;T, T&gt; <span class="title">applySchedulers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Transformer&lt;T, T&gt;() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">call</span><span class="params">(Observable&lt;T&gt; observable)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> observable.subscribeOn(Schedulers.io())</span><br><span class="line">             .observeOn(AndroidSchedulers.mainThread());</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></r></observable<t></p><p>用compose操作符做法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">restAdapter.getApiService().getToken()</span><br><span class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;String,Observable&lt;UserInfo&gt;&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;UserInfo&gt; <span class="title">call</span><span class="params">(String token)</span></span>&#123;</span><br><span class="line">                     <span class="keyword">return</span> restAdapter.getApiService().getUserInfo(token);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .compose(applySchedulers())</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;UserInfo&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(UserInfo userInfo)</span></span>&#123;</span><br><span class="line">                     showMessage(userInfo.getUser);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h4 id="RxJava的扩展"><a href="#RxJava的扩展" class="headerlink" title="RxJava的扩展"></a>RxJava的扩展</h4><p>主要是针对以下几个开源库展开来说：</p><ul><li>1.Rxbinding：用RxJava实现onClick,TextWatcher,check等事件绑定。</li><li>2.RxBus：用RxJava实现EventBus或者Otto。</li><li>3.RxPreferences：用RxJava实现Android中的SharedPreferences。</li><li>4.RxLifecycle：用来严格控制由于发布了一个订阅后，由于没有及时取消，导致Activity/Fragment无法销毁导致的内存泄露。</li><li>5.ReactiveNetwork：使用RxJava来监听网络连接状态和wifi信号强度变化。</li><li>6.RxPermissions：针对 Android 6.0 权限管理进行一个 Rx 封装的一个类库。</li><li>7.rxloader：用RxJava对loader的一个封装。</li><li>还有更多…</li></ul><h3 id="Android应用场景"><a href="#Android应用场景" class="headerlink" title="Android应用场景"></a>Android应用场景</h3><ul><li>1.避免嵌套回调地狱问题。</li><li>2.使用debounce减少频繁的网络请求。避免每输入（删除）一个字就做一次联想。</li><li>3.使用combineLatest合并最近N个结点,注册的时候所有输入信息（邮箱、密码、电话号码等）合法才点亮注册按钮。</li><li>4.使用merge合并两个数据源,最后做统一处理。</li><li>5.使用concat和first做缓存，依次检查memory、disk和network中是否存在数据，任何一步一旦发现数据后面的操作都不执行。</li><li>6.使用timer做定时操作。</li><li>7.使用interval做周期性操作。</li><li>8.使用throttleFirst防止按钮重复点击</li><li>9.做响应式的界面。</li><li>更多…</li></ul><p>部分例子代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RxTextView.textChanges(searchEditText)</span><br><span class="line">     .debounce(<span class="number">150</span>, MILLISECONDS)</span><br><span class="line">     .switchMap(Api::searchItems)</span><br><span class="line">     .subscribe(<span class="keyword">this</span>::updateList, t-&gt;showError());</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Observable.merge(getNews(), getHotNews(), </span><br><span class="line">    <span class="keyword">new</span> Func2&lt;Response&lt;News&gt;, MyResponse&lt;News&gt;, Boolean&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Response&lt;News&gt; response, Response&lt;News&gt; response2)</span> </span>&#123;</span><br><span class="line">            mData.clear();</span><br><span class="line">            mData.addAll(response);</span><br><span class="line">            mData.addAll(response2.msg);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Subscriber&lt;Boolean&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;&#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Boolean o)</span> </span>&#123;</span><br><span class="line">               mAdapter.notifyDataSetChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RxView.clicks(button)  </span><br><span class="line">      .throttleFirst(<span class="number">1</span>, TimeUnit.SECONDS)  </span><br><span class="line">      .subscribe(<span class="keyword">new</span> Observer&lt;Object&gt;() &#123;  </span><br><span class="line">          <span class="meta">@Override</span>  </span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                log.d (<span class="string">"completed"</span>);  </span><br><span class="line">          &#125;  </span><br><span class="line">  </span><br><span class="line">          <span class="meta">@Override</span>  </span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;  </span><br><span class="line">                log.e(<span class="string">"error"</span>);  </span><br><span class="line">          &#125;  </span><br><span class="line">  </span><br><span class="line">          <span class="meta">@Override</span>  </span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Object o)</span> </span>&#123;  </span><br><span class="line">               log.d(<span class="string">"button clicked"</span>);  </span><br><span class="line">          &#125;  </span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(<span class="keyword">this</span>);  </span><br><span class="line">RxSharedPreferences rxPreferences = RxSharedPreferences.create(preferences);  </span><br><span class="line">  </span><br><span class="line">Preference&lt;Boolean&gt; checked = rxPreferences.getBoolean(<span class="string">"checked"</span>, <span class="keyword">true</span>);  </span><br><span class="line">  </span><br><span class="line">CheckBox checkBox = (CheckBox) findViewById(R.id.cb_test);  </span><br><span class="line">RxCompoundButton.checkedChanges(checkBox)  </span><br><span class="line">        .subscribe(checked.asAction());</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;String&gt; memory = Observable</span><br><span class="line">    .create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">if</span> (memoryCache != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                subscriber.onNext(memoryCache);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                subscriber.onCompleted();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line"></span><br><span class="line">Observable&lt;String&gt; disk = Observable</span><br><span class="line">    .create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;  </span><br><span class="line">            String cachePref = rxPreferences.getString(<span class="string">"cache"</span>).get();  </span><br><span class="line">            <span class="keyword">if</span> (!TextUtils.isEmpty(cachePref)) &#123;  </span><br><span class="line">                subscriber.onNext(cachePref);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                subscriber.onCompleted();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line"></span><br><span class="line">Observable&lt;String&gt; network = Observable.just(<span class="string">"network"</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//依次检查memory、disk、network  </span></span><br><span class="line">Observable.concat(memory, disk, network)  </span><br><span class="line">    .first()  </span><br><span class="line">    .subscribeOn(Schedulers.newThread())  </span><br><span class="line">    .subscribe(s -&gt; &#123;  </span><br><span class="line">        memoryCache = <span class="string">"memory"</span>;  </span><br><span class="line">        System.out.println(<span class="string">"subscribe: "</span> + s);  </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h4 id="感谢-参考"><a href="#感谢-参考" class="headerlink" title="感谢/参考"></a>感谢/参考</h4><p>感谢Jake大神的启蒙，感谢Ivan.Morgillo的书《RxJava Essentials》,感谢扔物线的文章和大头鬼的翻译文章，同时也是一路看他们的文章走过来的，最后感谢所有分享RxJava的小伙伴们。</p><ul><li><a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">http://gank.io/post/560e15be2dca930e00da1083</a></li><li><a href="http://blog.csdn.net/lzyzsd/article/details/41833541" target="_blank" rel="noopener">http://blog.csdn.net/lzyzsd/article/details/41833541</a></li><li><a href="http://blog.csdn.net/theone10211024/article/details/50435325" target="_blank" rel="noopener">http://blog.csdn.net/theone10211024/article/details/50435325</a></li><li>《RxJava Essentials》</li><li><a href="http://reactivex.io" target="_blank" rel="noopener">http://reactivex.io</a></li></ul><h3 id="关于RxJava和Android的学习"><a href="#关于RxJava和Android的学习" class="headerlink" title="关于RxJava和Android的学习"></a>关于RxJava和Android的学习</h3><p>主要从渠道，知识点和资源几方面介绍了下学习，提到<a href="http://mobdevgroup.com" target="_blank" rel="noopener">MobDevGroup</a>这个资源站。</p><h2 id="GDG总结"><a href="#GDG总结" class="headerlink" title="GDG总结"></a>GDG总结</h2><p>由于时间上的问题，没有对一些原理进行讲解，尤其是变换等，大部分是在讲应用，总之呢除了对自己知识点一次不错的总结外，也是对自己的一次历练，接下来再接再厉。最后附上这次的PPT下载地址：</p><ul><li>Mac <a href="http://vdisk.weibo.com/s/CeH3i0tfvuvLU" target="_blank" rel="noopener">keynote</a></li><li>Windows <a href="http://vdisk.weibo.com/s/CeH3i0tfvuvMd" target="_blank" rel="noopener">PowerPoint</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;1月10号这一天，也是值得高兴的日子，一大早起来打开手机看到《RxJava Essentials》一书的作者Ivan.Morgillo给我在
      
    
    </summary>
    
      <category term="Android" scheme="https://yuxingxin.com/categories/Android/"/>
    
    
      <category term="RxJava" scheme="https://yuxingxin.com/tags/RxJava/"/>
    
  </entry>
  
</feed>
