[
  
  {
    "title": "Android三方开源库之RxJava3源码分析",
    "url": "/posts/android-rxjava/",
    "categories": "Android",
    "tags": "源码分析",
    "date": "2020-07-26 00:00:00 +0800",
    "content": "RxJava作为主流的框架之一，有着丰富的功能操作符以及便捷的线程切换，深受Android开发者喜爱，本文尝试从源码角度分析其工作原理。  Single.just  Single.just最为最简单的模型，可以看下它是如何工作的：  Single&lt;Integer&gt; single = Single.just(1); single.subscribe(new SingleObserver&lt;Integer&gt;() {     @Override     public void onSubscribe(Disposable d) {     }      @Override     public void onSuccess(Integer integer) {     }      @Override     public void onError(Throwable e) {     } });   先看下just方法：  // Single.java @CheckReturnValue @SchedulerSupport(SchedulerSupport.NONE) @NonNull public static &lt;T&gt; Single&lt;T&gt; just(final T item) {     ObjectHelper.requireNonNull(item, \"value is null\");     return RxJavaPlugins.onAssembly(new SingleJust&lt;T&gt;(item)); }   通过RxJavaPlugins.onAssembly方法返回一个SingleJust对象：  // RxJavaPlugins.java @NonNull public static &lt;T&gt; Single&lt;T&gt; onAssembly(@NonNull Single&lt;T&gt; source) {     Function&lt;? super Single, ? extends Single&gt; f = onSingleAssembly;     if (f != null) {         return apply(f, source);     }     return source; }   这里的onAssembly是一个钩子函数，如果f不为空的时候，处理完后可以看到，返回了参数本身，即上面说的SingleJust对象，紧接着看下subscribe方法：  // Single.java @SchedulerSupport(SchedulerSupport.NONE) @Override public final void subscribe(SingleObserver&lt;? super T&gt; observer) {     ...     try {         subscribeActual(observer);     } catch (NullPointerException ex) {         throw ex;     } catch (Throwable ex) {         Exceptions.throwIfFatal(ex);         NullPointerException npe = new NullPointerException(\"subscribeActual failed\");         npe.initCause(ex);         throw npe;     } }   这里实际上调用的是subscribeActual方法，也就是实际订阅的方法，即SingleJust的subscribeActual方法：  // SingleJust.java @Override protected void subscribeActual(SingleObserver&lt;? super T&gt; observer) {     observer.onSubscribe(Disposables.disposed());     observer.onSuccess(value); }   可以看到这里直接将值，直接传给观察者么也就是上面示例中的SingleObserver对象，然后回调其onSubscribe和onSuccess方法，因为不会出错，所以没有onError方法，这样就完成一次最简单的订阅。  接下来看下如果中间有操作符时，该怎么处理。  Map操作符  Single&lt;Integer&gt; single = Single.just(1); Single&lt;String&gt; singleString = single.map(new Function&lt;Integer, String&gt;() {     @Override     public String apply(Integer integer) throws Exception {         return integer.toString();     } }); singleString.subscribe(new SingleObserver&lt;String&gt;() {     @Override     public void onSubscribe(Disposable d) {      }      @Override     public void onSuccess(String s) {      }      @Override     public void onError(Throwable e) {      } });   首先看下map方法：  // Single.java @CheckReturnValue @NonNull @SchedulerSupport(SchedulerSupport.NONE) public final &lt;R&gt; Single&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) {     ObjectHelper.requireNonNull(mapper, \"mapper is null\");     return RxJavaPlugins.onAssembly(new SingleMap&lt;T, R&gt;(this, mapper)); }   同样是一个钩子函数，返回一个SingleMap对象，其中构造函数中第一个参数为上游的Single，mapper为一个转换器对象，紧接着看下SingleMap的subscribe方法，其实也是在调用其subscribeActual方法:  // SingleMap.java public final class SingleMap&lt;T, R&gt; extends Single&lt;R&gt; {     final SingleSource&lt;? extends T&gt; source;      final Function&lt;? super T, ? extends R&gt; mapper;      public SingleMap(SingleSource&lt;? extends T&gt; source, Function&lt;? super T, ? extends R&gt; mapper) {         this.source = source;         this.mapper = mapper;     }      @Override     protected void subscribeActual(final SingleObserver&lt;? super R&gt; t) {         source.subscribe(new MapSingleObserver&lt;T, R&gt;(t, mapper));     }      static final class MapSingleObserver&lt;T, R&gt; implements SingleObserver&lt;T&gt; {          final SingleObserver&lt;? super R&gt; t;          final Function&lt;? super T, ? extends R&gt; mapper;          MapSingleObserver(SingleObserver&lt;? super R&gt; t, Function&lt;? super T, ? extends R&gt; mapper) {             this.t = t;             this.mapper = mapper;         }          @Override         public void onSubscribe(Disposable d) {             t.onSubscribe(d);         }          @Override         public void onSuccess(T value) {             R v;             try {                 // 执行方法转换                 v = ObjectHelper.requireNonNull(mapper.apply(value), \"The mapper function returned a null value.\");             } catch (Throwable e) {                 Exceptions.throwIfFatal(e);                 onError(e);                 return;             }              t.onSuccess(v);         }          @Override         public void onError(Throwable e) {             t.onError(e);         }     } }   其中source为我们上游的被观察者，MapSingleObserver为我们内部创建的观察者对象，它将下游的观察者t，即示例中的SingleObserver和转换器对象包装起来，通过调用上游被观察者的subscribe方法，完成订阅关系。即该方法内部调用onSubscribe、onSuccess、onError方法时，会将事件传递给下游，即通过t调用其onSubscribe、onSuccess、onError方法。  综上：     基于上游观察者对象Single通过操作符创建了一个新的被观察者对象SingleMap   在被观察者对象SingleMap内部创建了一个新的观察者MapSingleObserver   通过SingMap的subscribe方法（实际上是subscribeActual方法）和中介MapSingleObserver将上游被观察者对象Single与下游观察者SingleObserver联系起来。   Dispose  我们可以通过dispose方法来让上游或内部调度器停止工作，达到丢失的效果。                 操作符       上下游       后续事件       延迟                       Single.just       无       无       无                 Single.delay       无       无       有                 Single.map       有       无       无                 Observable.delay       无       无       有                 Observable.interval       无       有       有                 Observable.map       有       有       无           Single.just  我们看下其subscribeActual方法，该方法中给观察者的是一个全局的Disposable对象，因为时间太短，所以不用对其进行取消。  // SingleJust.java @Override protected void subscribeActual(SingleObserver&lt;? super T&gt; observer) {     observer.onSubscribe(Disposables.disposed());     observer.onSuccess(value); }   Observable.interval  首先来看下示例：  Observable&lt;Long&gt; integerObservable = Observable.interval(0, 1, TimeUnit.SECONDS); integerObservable.subscribe(new Observer&lt;Long&gt;() {     @Override     public void onSubscribe(Disposable d) {      }      @Override     public void onNext(Long aLong) {      }       @Override     public void onError(Throwable e) {      }      @Override     public void onComplete() {      } });   上面示例中Observable.interval方法返回一个ObservableInterval对象，然后看下其subscribeActual方法：  // ObservableInterval.java @Override public void subscribeActual(Observer&lt;? super Long&gt; observer) {     // 创建观察者，实现了Disposable和Runnable     IntervalObserver is = new IntervalObserver(observer);     observer.onSubscribe(is); \t// 线程调度器     Scheduler sch = scheduler;      if (sch instanceof TrampolineScheduler) {         Worker worker = sch.createWorker();         is.setResource(worker);         worker.schedulePeriodically(is, initialDelay, period, unit);     } else {         // 将上面创建的观察者交给线程调度器去执行，并返回Disposable对象         Disposable d = sch.schedulePeriodicallyDirect(is, initialDelay, period, unit);         is.setResource(d);     } }   上面方法中首先创建了一个实现Disposable和Runnable的观察者，并将该观察者对象通过onSubscribe方法传递给了下游，方便下游取消，然后将该观察者交给线程调度器去执行，同时将返回值Disposable对象赋值给该观察者。  // ObservableInterval.java static final class IntervalObserver extends AtomicReference&lt;Disposable&gt; implements Disposable, Runnable {      private static final long serialVersionUID = 346773832286157679L;      final Observer&lt;? super Long&gt; downstream;      long count;      IntervalObserver(Observer&lt;? super Long&gt; downstream) {         this.downstream = downstream;     }      @Override     public void dispose() {         // 取消自己         DisposableHelper.dispose(this);     }      @Override     public boolean isDisposed() {         return get() == DisposableHelper.DISPOSED;     }      @Override     public void run() {         if (get() != DisposableHelper.DISPOSED) {             // 往下游传递             downstream.onNext(count++);         }     }      public void setResource(Disposable d) {         // 设置Disposable给自己         DisposableHelper.setOnce(this, d);     } }   ObservableInterval继承了一个原子引用类，它保证线程读写安全，并实现了Disposable和Runnable接口，通过构造函数将下游观察者的事件传递给下游  当订阅开始时，将IntervalObserver传递给下游，并且它可以被下游取消，接着传递给调度器，执行调度器的run方法，将数据往下游传递，并返回一个Disposable对象，意味着可以随时取消调度器里面的该任务，然后又将该对象通过setResource方法设置给IntervalObserver自己，所以下游调用disposable方法时，会调用IntervalObserver的dispose，然后IntervalObserver内部随即调用自己的dispose方法，完成了取消。  Single.map  首先看下示例：  Single&lt;Integer&gt; single = Single.just(1); Single&lt;String&gt; singleString = single.map(new Function&lt;Integer, String&gt;() {     @Override     public String apply(Integer integer) throws Exception {         return integer.toString();     } }); singleString.subscribe(new SingleObserver&lt;String&gt;() {     @Override     public void onSubscribe(Disposable d) {      }      @Override     public void onSuccess(String s) {      }      @Override     public void onError(Throwable e) {      } });   通过上面我们知道，上游创建了一个SingleJust对象，在调用map方法时，将自己传递给下游的SingleMap对象并返回。在调用subscribe方法时，其实是调用SingleMap的subscribeActual方法：  // SingleMap.java @Override protected void subscribeActual(final SingleObserver&lt;? super R&gt; t) {     source.subscribe(new MapSingleObserver&lt;T, R&gt;(t, mapper)); }   上面方法直接调用上游source去订阅MapSingleObserver这个观察者，然后在上游调用onSubscribe时调用下游的onSubscribe方法；在上游调用onSuccess时自己做了一下mapper.apply(value)转换操作，将数据转换成下游所需要的，然后再调用下游的onSuccess传递给下游；onError同onSubscribe原理是一样的。  Single.delay  首先来看下示例：  Single&lt;Integer&gt; single = Single.just(1); Single&lt;Integer&gt; singleDelay = single.delay(1, TimeUnit.SECONDS); singleDelay.subscribe(new SingleObserver&lt;Integer&gt;() {     @Override     public void onSubscribe(Disposable d) {      }      @Override     public void onSuccess(Integer integer) {      }      @Override     public void onError(Throwable e) {      } });   上面single.delay方法返回SingleDelay对象，然后调用它的subscribe放，其实是调用subscribeActual方法：  @Override protected void subscribeActual(final SingleObserver&lt;? super T&gt; observer) {      final SequentialDisposable sd = new SequentialDisposable();     observer.onSubscribe(sd);     source.subscribe(new Delay(sd, observer)); }   内部创建了一个Disposable对象，并将该对象通过onSubscribe方法传递给下游观察者，最后让上游订阅这个观察者，下面是SequentialDisposable代码：  // SequentialDisposable.java public final class SequentialDisposable extends AtomicReference&lt;Disposable&gt; implements Disposable {      private static final long serialVersionUID = -754898800686245608L;      public SequentialDisposable() {         // nothing to do     }      public SequentialDisposable(Disposable initial) {         lazySet(initial);     }      public boolean update(Disposable next) {         return DisposableHelper.set(this, next);     }      public boolean replace(Disposable next) {         return DisposableHelper.replace(this, next);     }      @Override     public void dispose() {         DisposableHelper.dispose(this);     }      @Override     public boolean isDisposed() {         return DisposableHelper.isDisposed(get());     } }   代码和上面IntervalObserver有点像，紧接着看下Delay类：  // SingleDelay.java final class Delay implements SingleObserver&lt;T&gt; {         private final SequentialDisposable sd;         final SingleObserver&lt;? super T&gt; downstream;          Delay(SequentialDisposable sd, SingleObserver&lt;? super T&gt; observer) {             this.sd = sd;             this.downstream = observer;         }          @Override         public void onSubscribe(Disposable d) {             sd.replace(d);         }          @Override         public void onSuccess(final T value) {             sd.replace(scheduler.scheduleDirect(new OnSuccess(value), time, unit));         }          @Override         public void onError(final Throwable e) {             sd.replace(scheduler.scheduleDirect(new OnError(e), delayError ? time : 0, unit));         }          final class OnSuccess implements Runnable {             private final T value;              OnSuccess(T value) {                 this.value = value;             }              @Override             public void run() {                 downstream.onSuccess(value);             }         }          final class OnError implements Runnable {             private final Throwable e;              OnError(Throwable e) {                 this.e = e;             }              @Override             public void run() {                 downstream.onError(e);             }         }     }   subscribeActual方法最后在上游订阅Delay的时候，触发onSubscribe，Delay内部随即将该Disposable存入SequentialDisposable对象（需要注意的是下游拿到的Disposable始终是这个SequentialDisposable）中，此时如果下游调用dispose，也就是调用SequentialDisposable的dispose，也就是上游的dispose，dispose流程在这个节点上就完成了向上传递。  当上游产生数据，通过onSuccess方法传递给观察者Delay，在其onSuccess方法内部将调度器返回的Disposable替换SequentialDisposable内部，这样下游取消任务时，就直接把任务取消了，当调度器执行的OnSuccess的run方法， 下游就可以接收到数据了。  Observable.map  Observable.map所对应的是ObservableMap，直接看其subscribeActual方法：  // ObservableMap.java public final class ObservableMap&lt;T, U&gt; extends AbstractObservableWithUpstream&lt;T, U&gt; {     final Function&lt;? super T, ? extends U&gt; function;      public ObservableMap(ObservableSource&lt;T&gt; source, Function&lt;? super T, ? extends U&gt; function) {         super(source);         this.function = function;     }      @Override     public void subscribeActual(Observer&lt;? super U&gt; t) {         source.subscribe(new MapObserver&lt;T, U&gt;(t, function));     }      static final class MapObserver&lt;T, U&gt; extends BasicFuseableObserver&lt;T, U&gt; {         final Function&lt;? super T, ? extends U&gt; mapper;          MapObserver(Observer&lt;? super U&gt; actual, Function&lt;? super T, ? extends U&gt; mapper) {             super(actual);             this.mapper = mapper;         }          @Override         public void onNext(T t) {             if (done) {                 return;             }              if (sourceMode != NONE) {                 downstream.onNext(null);                 return;             }              U v;              try {                 v = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper function returned a null value.\");             } catch (Throwable ex) {                 fail(ex);                 return;             }             downstream.onNext(v);         }          @Override         public int requestFusion(int mode) {             return transitiveBoundaryFusion(mode);         }          @Nullable         @Override         public U poll() throws Exception {             T t = qd.poll();             return t != null ? ObjectHelper.&lt;U&gt;requireNonNull(mapper.apply(t), \"The mapper function returned a null value.\") : null;         }     } }   这里通过mapper.apply转换一下将数据传递给下游，同时在subscribeActual中并没有直接调用onSubscribe，MapObserver类中也没有，那应该是在父类中完成的：  // BasicFuseableObserver.java public final void onSubscribe(Disposable d) {     if (DisposableHelper.validate(this.upstream, d)) {          this.upstream = d;         if (d instanceof QueueDisposable) {             this.qd = (QueueDisposable&lt;T&gt;)d;         }          if (beforeDownstream()) {              // 调用下游的onSubscribe方法             downstream.onSubscribe(this);              afterDownstream();         }      } }   这里将上游的Disposable存储起来，并将中间节点自己传递给了下游，同时调用下游的onSubscribe  Observable.delay  该方法返回的是ObservableDelay类，看其subscribeActual方法：  // ObservableDelay.java public final class ObservableDelay&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; {     final long delay;     final TimeUnit unit;     final Scheduler scheduler;     final boolean delayError;      public ObservableDelay(ObservableSource&lt;T&gt; source, long delay, TimeUnit unit, Scheduler scheduler, boolean delayError) {         super(source);         this.delay = delay;         this.unit = unit;         this.scheduler = scheduler;         this.delayError = delayError;     }      @Override     @SuppressWarnings(\"unchecked\")     public void subscribeActual(Observer&lt;? super T&gt; t) {         Observer&lt;T&gt; observer;         if (delayError) {             observer = (Observer&lt;T&gt;)t;         } else {             observer = new SerializedObserver&lt;T&gt;(t);         }          Scheduler.Worker w = scheduler.createWorker();          source.subscribe(new DelayObserver&lt;T&gt;(observer, delay, unit, w, delayError));     }      static final class DelayObserver&lt;T&gt; implements Observer&lt;T&gt;, Disposable {         final Observer&lt;? super T&gt; downstream;         final long delay;         final TimeUnit unit;         final Scheduler.Worker w;         final boolean delayError;          Disposable upstream;          DelayObserver(Observer&lt;? super T&gt; actual, long delay, TimeUnit unit, Worker w, boolean delayError) {             super();             this.downstream = actual;             this.delay = delay;             this.unit = unit;             this.w = w;             this.delayError = delayError;         }          @Override         public void onSubscribe(Disposable d) {             if (DisposableHelper.validate(this.upstream, d)) {                 this.upstream = d;                 // 调用下游的onSubscribe方法，并传递自己给下游                 downstream.onSubscribe(this);             }         }          @Override         public void onNext(final T t) {             w.schedule(new OnNext(t), delay, unit);         }          @Override         public void onError(final Throwable t) {             w.schedule(new OnError(t), delayError ? delay : 0, unit);         }          @Override         public void onComplete() {             w.schedule(new OnComplete(), delay, unit);         }          @Override         public void dispose() {             upstream.dispose();             w.dispose();         }          @Override         public boolean isDisposed() {             return w.isDisposed();         }          final class OnNext implements Runnable {             private final T t;              OnNext(T t) {                 this.t = t;             }              @Override             public void run() {                 downstream.onNext(t);             }         }          final class OnError implements Runnable {             private final Throwable throwable;              OnError(Throwable throwable) {                 this.throwable = throwable;             }              @Override             public void run() {                 try {                     downstream.onError(throwable);                 } finally {                     w.dispose();                 }             }         }          final class OnComplete implements Runnable {             @Override             public void run() {                 try {                     downstream.onComplete();                 } finally {                     w.dispose();                 }             }         }     } }   上面在subscribeActual没有调用下游的onSubscribe，而是在DelayObserver的onSubscribe方法完成调用，即先验证一下上游 然后将上游的Disposable赋值给upstream，调用下游的onSubscribe，把自己传给下游。当下游调用dispose时，在DelayObserver的dispose方法中将上游的Disposable给取消掉，然后把自己的调度器任务也给取消掉。当上游调用到DelayObserver的onNext时，OnNext任务（Runnable）提交给调度器执行，在执行任务时调用下游的onNext方法。  线程切换  subscribeOn  该方法返回SingleSubscribeOn对象，然后看其subscribeActual方法：  public final class SingleSubscribeOn&lt;T&gt; extends Single&lt;T&gt; {     final SingleSource&lt;? extends T&gt; source;      final Scheduler scheduler;      public SingleSubscribeOn(SingleSource&lt;? extends T&gt; source, Scheduler scheduler) {         this.source = source;         this.scheduler = scheduler;     }      @Override     protected void subscribeActual(final SingleObserver&lt;? super T&gt; observer) {         final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(observer, source);         observer.onSubscribe(parent); \t\t         // 切换线程         Disposable f = scheduler.scheduleDirect(parent);          parent.task.replace(f);      }      static final class SubscribeOnObserver&lt;T&gt;     extends AtomicReference&lt;Disposable&gt;     implements SingleObserver&lt;T&gt;, Disposable, Runnable {          private static final long serialVersionUID = 7000911171163930287L;          final SingleObserver&lt;? super T&gt; downstream;          final SequentialDisposable task;          final SingleSource&lt;? extends T&gt; source;          SubscribeOnObserver(SingleObserver&lt;? super T&gt; actual, SingleSource&lt;? extends T&gt; source) {             this.downstream = actual;             this.source = source;             this.task = new SequentialDisposable();         }          @Override         public void onSubscribe(Disposable d) {             DisposableHelper.setOnce(this, d);         }          @Override         public void onSuccess(T value) {             downstream.onSuccess(value);         }          @Override         public void onError(Throwable e) {             downstream.onError(e);         }          @Override         public void dispose() {             DisposableHelper.dispose(this);             task.dispose();         }          @Override         public boolean isDisposed() {             return DisposableHelper.isDisposed(get());         }          @Override         public void run() {             source.subscribe(this);         }     } }   上面代码将parent交给线程调度器去执行，看下它的Run方法，在scheduleDirect那里切了线程，然后在另一个线程中去执行source.subscribe(this)，即这里在Scheduler指定的线程里启动了subscribe（订阅），所以多次执行subscribeOn，只会对最开始的Observable起作用。  observeOn  该方法返回SingleObserveOn对象，直接看其subscribeActual方法：  // SingleObserveOn.java public final class SingleObserveOn&lt;T&gt; extends Single&lt;T&gt; {      final SingleSource&lt;T&gt; source;      final Scheduler scheduler;      public SingleObserveOn(SingleSource&lt;T&gt; source, Scheduler scheduler) {         this.source = source;         this.scheduler = scheduler;     }      @Override     protected void subscribeActual(final SingleObserver&lt;? super T&gt; observer) {         source.subscribe(new ObserveOnSingleObserver&lt;T&gt;(observer, scheduler));     }      static final class ObserveOnSingleObserver&lt;T&gt; extends AtomicReference&lt;Disposable&gt;     implements SingleObserver&lt;T&gt;, Disposable, Runnable {         private static final long serialVersionUID = 3528003840217436037L;          final SingleObserver&lt;? super T&gt; downstream;          final Scheduler scheduler;          T value;         Throwable error;          ObserveOnSingleObserver(SingleObserver&lt;? super T&gt; actual, Scheduler scheduler) {             this.downstream = actual;             this.scheduler = scheduler;         }          @Override         public void onSubscribe(Disposable d) {             if (DisposableHelper.setOnce(this, d)) {                 downstream.onSubscribe(this);             }         }          @Override         public void onSuccess(T value) {             this.value = value;             Disposable d = scheduler.scheduleDirect(this);             DisposableHelper.replace(this, d);         }          @Override         public void onError(Throwable e) {             this.error = e;             Disposable d = scheduler.scheduleDirect(this);             DisposableHelper.replace(this, d);         }          @Override         public void run() {             Throwable ex = error;             if (ex != null) {                 downstream.onError(ex);             } else {                 downstream.onSuccess(value);             }         }          @Override         public void dispose() {             DisposableHelper.dispose(this);         }          @Override         public boolean isDisposed() {             return DisposableHelper.isDisposed(get());         }     } }   可以看到，上游订阅了ObserveOnSingleObserver这个观察者，当下游调用onSuccess方法时，会执行构造函数传进来的scheduler.scheduleDirect方法，即调用ObserveOnSingleObserver的run函数，所以该函数会运行在scheduler指定的线程中，即下游的onSuccess和onError方法都会在Scheduler指定的线程中运行。所以每次调用observeOn，都会进行一次线程切换，下游的每个Observer都会运行在指定的切换的线程中。  Scheduler调度器  Schedulers.newThread()里面是创建了一个线程池Executors.newScheduledThreadPool(1, factory)来执行任务，但是这个线程池里面的线程不会得到重用，每次都是新建的线程池。当 scheduleDirect() 被调用的时候，会创建一个 Worker，Worker 的内部 会有一个 Executor，由 Executor 来完成实际的线程切换；同时该方法也会返回一个Disposable对象，交给外层的Observer，从而执行dispose方法，取消订阅链。  // NewThreadScheduler.java  @NonNull @Override public Worker createWorker() {     return new NewThreadWorker(threadFactory); }  // NewThreadWorker.java  public NewThreadWorker(ThreadFactory threadFactory) {     executor = SchedulerPoolFactory.create(threadFactory); }  // SchedulerPoolFactory.java public static ScheduledExecutorService create(ThreadFactory factory) {     final ScheduledExecutorService exec = Executors.newScheduledThreadPool(1, factory);     tryPutIntoPool(PURGE_ENABLED, exec);     return exec; }   Schedulers.io()方法和上面区别不大，它的线程可以被重用，所以Android中我们常用它来做线程切换。  // IoScheduler.java public final class IoScheduler extends Scheduler {     ...     @NonNull     @Override     public Worker createWorker() {         return new EventLoopWorker(pool.get());     }     ... }   static final class EventLoopWorker extends Scheduler.Worker {     private final CompositeDisposable tasks;     private final CachedWorkerPool pool;     private final ThreadWorker threadWorker;      final AtomicBoolean once = new AtomicBoolean();      EventLoopWorker(CachedWorkerPool pool) {         this.pool = pool;         this.tasks = new CompositeDisposable();         // 从缓存池取         this.threadWorker = pool.get();     }      @Override     public void dispose() {         if (once.compareAndSet(false, true)) {             tasks.dispose();              // releasing the pool should be the last action             pool.release(threadWorker);         }     }      @Override     public boolean isDisposed() {         return once.get();     }      @NonNull     @Override     public Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) {         if (tasks.isDisposed()) {             // don't schedule, we are unsubscribed             return EmptyDisposable.INSTANCE;         }          return threadWorker.scheduleActual(action, delayTime, unit, tasks);     } }  static final class ThreadWorker extends NewThreadWorker {     private long expirationTime;      ThreadWorker(ThreadFactory threadFactory) {         super(threadFactory);         this.expirationTime = 0L;     }      public long getExpirationTime() {         return expirationTime;     }      public void setExpirationTime(long expirationTime) {         this.expirationTime = expirationTime;     } }   而AndroidSchedulers.mainThread()内部直接是使用Handler进行线程切换，将任务放到主线程去做  // AndroidSchedulers.java public final class AndroidSchedulers { \t...     private static final class MainHolder {         static final Scheduler DEFAULT             = new HandlerScheduler(new Handler(Looper.getMainLooper()), false);     }     ... }   总结  以上从源码角度分析了RxJava3中的订阅流程，取消订阅流程和线程切换流程，这样可以更好的理解RxJava工作机制。"
  },
  
  {
    "title": "Android三方开源库之OkHttp源码分析",
    "url": "/posts/android-okhttp/",
    "categories": "Android",
    "tags": "源码分析",
    "date": "2020-07-14 00:00:00 +0800",
    "content": "OkHttp 是目前应用最广泛的开源网络库了，而且在Android6.0之后也将内部的HttpUrlConnection替换成了OkHttp，这篇文章来分析一下源码。  基本使用  OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder()     .url(\"https://github.com\")     .build(); // 同步请求 try {     okhttp3.Response response = client.newCall(request).execute(); } catch (IOException e) {     e.printStackTrace(); }  // 异步请求 client.newCall(request).enqueue(new okhttp3.Callback() {     @Override     public void onFailure(@NonNull okhttp3.Call call, @NonNull IOException e) {      }      @Override     public void onResponse(@NonNull okhttp3.Call call, @NonNull okhttp3.Response response) throws IOException {      } });    代码中涉及到几个对象，来一起看下：  OkHttpClient：OkHttp的核心配置类，采用建造者模式，多个方便配置的参数。  Request：请求参数配置类，也采用建造者模式，可以配置的参数有请求URL、请求方法、请求头、请求体  Response: 返回结果类，包含Code、Message、header、body等  Call：请求接口，表示一个已经准备的好的请求，可以执行或取消。  RealCall：通过OkHttpClient的newCall方法返回的一个Call对象，它是上面Call接口的实现类，负责请求的调度，内部通过同步或者异步请求，构造内部逻辑责任链，并执行责任链相关的逻辑，直到获取结果  源码分析  请求  接下来我们就先从RealCall请求看起：  RealCall有两个最重要的方法，execute() 和 enqueue()，一个是处理同步请求，一个是处理异步请求。先看下同步请求：  // RealCall.kt override fun execute(): Response {     check(executed.compareAndSet(false, true)) { \"Already Executed\" }      timeout.enter()     // 请求监听     callStart()     try {         client.dispatcher.executed(this)         return getResponseWithInterceptorChain()     } finally {         client.dispatcher.finished(this)     } }   上面首先采用CAS检查当前线程是否被执行过，如果没有执行过就将标识首先置为true，然后开始执行，紧接着请求超时倒计时开始计时，然后监听请求，最后执行调度器中的executed方法，将当前RealCall对象加入runningSyncCalls队列，然后调用getResponseWithInterceptorChain方法拿到response。  接着看下异步请求：  // RealCall.kt override fun enqueue(responseCallback: Callback) {     check(executed.compareAndSet(false, true)) { \"Already Executed\" }      callStart()     client.dispatcher.enqueue(AsyncCall(responseCallback)) }   上面首先也是采用CAS检查当前线程是否被执行过，然后监听请求，最后创建一个AsyncCall对象，然后通过调度器的 enqueue方法将其加入到readyAsyncCalls队列中。  进阶着看下调度器的enqueue方法：  // Dispatcher.kt  internal fun enqueue(call: AsyncCall) {     // 加锁保证线程安全     synchronized(this) {         // 加入队列         readyAsyncCalls.add(call)          // Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to         // the same host.         if (!call.call.forWebSocket) {             // 查看 有没有相同的域名请求，如果有就可以复用             val existingCall = findExistingCallWithHost(call.host)             if (existingCall != null) call.reuseCallsPerHostFrom(existingCall)         }     }     // 执行请求     promoteAndExecute() }  private fun promoteAndExecute(): Boolean {     this.assertThreadDoesntHoldLock()      val executableCalls = mutableListOf&lt;AsyncCall&gt;()     val isRunning: Boolean     synchronized(this) {         // 遍历准备请求队列         val i = readyAsyncCalls.iterator()         while (i.hasNext()) {             val asyncCall = i.next() \t\t\t//runningAsyncCalls 的数量不能大于最大并发请求数 64             if (runningAsyncCalls.size &gt;= this.maxRequests) break // Max capacity.             // 同一个域名最大请求数为5             if (asyncCall.callsPerHost.get() &gt;= this.maxRequestsPerHost) continue // Host max capacity. \t\t\t// 从请求队列移除，并加入到​executableCalls执行队列和​runningAsyncCalls运行队列             i.remove()             asyncCall.callsPerHost.incrementAndGet()             executableCalls.add(asyncCall)             runningAsyncCalls.add(asyncCall)         }         // 通过判断运行队列的请求数量来判断是否有请求正在执行         isRunning = runningCallsCount() &gt; 0     }      // 遍历可执行队列，调用线程池来执行AsyncCall     for (i in 0 until executableCalls.size) {         val asyncCall = executableCalls[i]         asyncCall.executeOn(executorService)     }      return isRunning }   上面代码中，调度器的enqueue方法将AsyncCall加入到readyAsyncCalls准备请求队列，然后调用promoteAndExecute方法开始执行请求，遍历上面的准确请求队列，将符合条件的AsyncCall通过其executeOn方法交给线程池来执行。即执行AsyncCall的run方法。AsyncCall是RealCall的内部类，看下它的run方法：  // RealCall.kt inner class AsyncCall(     private val responseCallback: Callback ) : Runnable {     fun executeOn(executorService: ExecutorService) {         client.dispatcher.assertThreadDoesntHoldLock()          var success = false         try {             // 交给线程池执行             executorService.execute(this)             success = true         } catch (e: RejectedExecutionException) {             val ioException = InterruptedIOException(\"executor rejected\")             ioException.initCause(e)             noMoreExchanges(ioException)             responseCallback.onFailure(this@RealCall, ioException)         } finally {             if (!success) {                 client.dispatcher.finished(this) // This call is no longer running!             }         }     }      override fun run() {         threadName(\"OkHttp ${redactedUrl()}\") {             var signalledCallback = false             // 请求超时倒计时开始             timeout.enter()             try {                 // 通过责任链获取返回结果                 val response = getResponseWithInterceptorChain()                 signalledCallback = true                 responseCallback.onResponse(this@RealCall, response)             } catch (e: IOException) {                 if (signalledCallback) {                     // Do not signal the callback twice!                     Platform.get().log(\"Callback failure for ${toLoggableString()}\", Platform.INFO, e)                 } else {                     responseCallback.onFailure(this@RealCall, e)                 }             } catch (t: Throwable) {                 cancel()                 if (!signalledCallback) {                     val canceledException = IOException(\"canceled due to $t\")                     canceledException.addSuppressed(t)                     responseCallback.onFailure(this@RealCall, canceledException)                 }                 throw t             } finally {                 client.dispatcher.finished(this)             }         }     } }   可以看到上面run方法，就是调用getResponseWithInterceptorChain方法拿到response，然后通过Callback.onResponse方法传递出去。反之，如果请求失败，捕获了异常，就通过Callback.onFailure将异常信息传递出去。 最终，请求结束，调用调度器finish方法。  // Dispatcher.kt internal fun finished(call: AsyncCall) {     call.callsPerHost.decrementAndGet()     finished(runningAsyncCalls, call) }  /** Used by [Call.execute] to signal completion. */ internal fun finished(call: RealCall) {     finished(runningSyncCalls, call) }  private fun &lt;T&gt; finished(calls: Deque&lt;T&gt;, call: T) {     val idleCallback: Runnable?     synchronized(this) {         // 从运行队列中移除当前请求         if (!calls.remove(call)) throw AssertionError(\"Call wasn't in-flight!\")         idleCallback = this.idleCallback     }          //继续执行剩余请求，将call从readyAsyncCalls中取出加入到runningAsyncCalls，然后执行     val isRunning = promoteAndExecute()      if (!isRunning &amp;&amp; idleCallback != null) {         //如果执行完了所有请求，处于闲置状态，调用闲置回调方法         idleCallback.run()     } }   上面finish方法中，首先将当前请求从运行队列中移除，然后继续执行剩余请求，最后如果所有请求都执行完了，就调用闲置回调方法。  响应  其实是响应获取结果主要是看getResponseWithInterceptorChain方法是如何返回结果的：  // RealCall.kt  @Throws(IOException::class) internal fun getResponseWithInterceptorChain(): Response {     // Build a full stack of interceptors.     // 拦截器列表     val interceptors = mutableListOf&lt;Interceptor&gt;()     interceptors += client.interceptors     interceptors += RetryAndFollowUpInterceptor(client)     interceptors += BridgeInterceptor(client.cookieJar)     interceptors += CacheInterceptor(client.cache)     interceptors += ConnectInterceptor     if (!forWebSocket) {         interceptors += client.networkInterceptors     }     interceptors += CallServerInterceptor(forWebSocket)      // 创建拦截器责任链     val chain = RealInterceptorChain(         call = this,         interceptors = interceptors,         index = 0,         exchange = null,         request = originalRequest,         connectTimeoutMillis = client.connectTimeoutMillis,         readTimeoutMillis = client.readTimeoutMillis,         writeTimeoutMillis = client.writeTimeoutMillis     )      var calledNoMoreExchanges = false     try {         // 执行拦截器责任链获取结果         val response = chain.proceed(originalRequest)         if (isCanceled()) {             response.closeQuietly()             throw IOException(\"Canceled\")         }         return response     } catch (e: IOException) {         calledNoMoreExchanges = true         throw noMoreExchanges(e) as Throwable     } finally {         if (!calledNoMoreExchanges) {             noMoreExchanges(null)         }     } }   从上面代码看出，这里采用责任链设计模式，通过拦截器构建了一个RealInterceptorChain责任链，然后通过执行其proceed方法来获得结果。  拦截器  上面代码中，可以看出这个责任链是由一系列的拦截器组成：          client.Interceptors：开发者设置的拦截器，会在所有拦截器处理之前处理           RetryAndFollowUpInterceptor：失败重试和重定向拦截器           BridgeInterceptor：负责处理Request和Response的拦截器           CacheInterceptor：负责缓存处理的拦截器           ConnectInterceptor：负责和服务器建立连接服务的拦截器           client.networkInterceptors：开发者自己设置的拦截器           CallServerInterceptor：进行数据请求和响应的拦截器      先看下拦截器的定义：  // Interceptor.kt fun interface Interceptor {   @Throws(IOException::class)   fun intercept(chain: Chain): Response    companion object {     /**      * Constructs an interceptor for a lambda. This compact syntax is most useful for inline      * interceptors.      *      * ```kotlin      * val interceptor = Interceptor { chain: Interceptor.Chain -&gt;      *     chain.proceed(chain.request())      * }      * ```      */     inline operator fun invoke(crossinline block: (chain: Chain) -&gt; Response): Interceptor =       Interceptor { block(it) }   }    interface Chain {     fun request(): Request      @Throws(IOException::class)     fun proceed(request: Request): Response      /**      * Returns the connection the request will be executed on. This is only available in the chains      * of network interceptors; for application interceptors this is always null.      */     fun connection(): Connection?      fun call(): Call      fun connectTimeoutMillis(): Int      fun withConnectTimeout(timeout: Int, unit: TimeUnit): Chain      fun readTimeoutMillis(): Int      fun withReadTimeout(timeout: Int, unit: TimeUnit): Chain      fun writeTimeoutMillis(): Int      fun withWriteTimeout(timeout: Int, unit: TimeUnit): Chain   } }   上面声明了一个SAM函数接口，内部有一个Chain接口，其核心方法是proceed，通过它获取结果，紧接着看下该接口的实现类RealInterceptorChain：  // RealInterceptorChain.kt @Throws(IOException::class) override fun proceed(request: Request): Response {     check(index &lt; interceptors.size)      calls++      if (exchange != null) {         check(exchange.finder.routePlanner.sameHostAndPort(request.url)) {             \"network interceptor ${interceptors[index - 1]} must retain the same host and port\"         }         check(calls == 1) {             \"network interceptor ${interceptors[index - 1]} must call proceed() exactly once\"         }     }      // Call the next interceptor in the chain.     // 创建新的责任链，调用责任链中下一个拦截器     val next = copy(index = index + 1, request = request)     val interceptor = interceptors[index]      // 执行拦截器中的拦截方法     @Suppress(\"USELESS_ELVIS\")     val response = interceptor.intercept(next) ?: throw NullPointerException(         \"interceptor $interceptor returned null\")      if (exchange != null) {         check(index + 1 &gt;= interceptors.size || next.calls == 1) {             \"network interceptor $interceptor must call proceed() exactly once\"         }     }      return response }   上面代码中会按照拦截器列表的中顺序执行，返回Response。  下面介绍下上面的各个拦截器：  client.Interceptors  这是用户自己定义的拦截器，会被添加到interceptors列表，这是第一个被执行的拦截器，一般就是通过实现Interceptor的intercept方法，先处理自己的逻辑，比如设置Header等信息，然后通过chain.proceed(request)返回Response  RetryAndFollowUpInterceptor  它负责请求失败重试与重定向的后续请求工作：  @Throws(IOException::class) override fun intercept(chain: Interceptor.Chain): Response {     val realChain = chain as RealInterceptorChain     var request = chain.request     val call = realChain.call     var followUpCount = 0     var priorResponse: Response? = null     var newRoutePlanner = true     var recoveredFailures = listOf&lt;IOException&gt;()     while (true) {         call.enterNetworkInterceptorExchange(request, newRoutePlanner, chain)          var response: Response         var closeActiveExchange = true         try {             if (call.isCanceled()) {                 throw IOException(\"Canceled\")             }              try {                 response = realChain.proceed(request)                 newRoutePlanner = true             } catch (e: IOException) {                 // An attempt to communicate with a server failed. The request may have been sent.\t\t// 判断是否请求重试                 if (!recover(e, call, request, requestSendStarted = e !is ConnectionShutdownException)) {                     throw e.withSuppressed(recoveredFailures)                 } else {                     recoveredFailures += e                 }                 newRoutePlanner = false                 continue             }              // Clear out downstream interceptor's additional request headers, cookies, etc.             response = response.newBuilder()             .request(request)             .priorResponse(priorResponse?.stripBody())             .build()              val exchange = call.interceptorScopedExchange             // 根据状态码来判断重试或者重定向             val followUp = followUpRequest(response, exchange)              if (followUp == null) {                 if (exchange != null &amp;&amp; exchange.isDuplex) {                     call.timeoutEarlyExit()                 }                 closeActiveExchange = false                 return response             }              val followUpBody = followUp.body             if (followUpBody != null &amp;&amp; followUpBody.isOneShot()) {                 closeActiveExchange = false                 return response             }              response.body.closeQuietly()              if (++followUpCount &gt; MAX_FOLLOW_UPS) {                 throw ProtocolException(\"Too many follow-up requests: $followUpCount\")             }              request = followUp             priorResponse = response         } finally {             call.exitNetworkInterceptorExchange(closeActiveExchange)         }     } }  private fun recover(     e: IOException,     call: RealCall,     userRequest: Request,     requestSendStarted: Boolean ): Boolean {     // The application layer has forbidden retries.     if (!client.retryOnConnectionFailure) return false      // We can't send the request body again.     if (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) return false      // This exception is fatal.     if (!isRecoverable(e, requestSendStarted)) return false      // No more routes to attempt.     if (!call.retryAfterFailure()) return false      // For failure recovery, use the same route selector with a new connection.     return true }   上面代码中，当请求内部发生异常时，会判断是否请求重试，判定逻辑在recover方法中：     client的retryOnConnectionFailure参数设置为false，不进行重试   请求的body已经发出，不进行重试   特殊的异常类型不进行重试（如ProtocolException，SSLHandshakeException、SSLPeerUnverifiedException等）   没有更多的routes（包含proxy和inetaddress），不进行重试   BridgeInterceptor  它负责将用户请求转换为服务器需要的请求，比如设置内容长度，编码、gzip压缩、添加cookie以及其他header，同时将服务器返回的结果进行转换为用户需要的结果，是从应用程序到服务器的桥梁  CacheInterceptor  它根据OkHttpClient配置的缓存，首先通过Request尝试获取缓存，然后通过工厂模式CacheStrategy.Factory生成的缓存策略，来判断如何使用缓存     如果缓存策略设置网络不可用，并且缓存也没有，直接构造一个Response返回   如果缓存策略设置网络不可用，但是有缓存，就返回缓存   执行后续流程   当缓存存在，如果返回304，就使用缓存的Response   否则就构建网络请求的Response，如果OkHttpClient配置的有缓存，就把该Response缓存起来   最后返回Response   ConnectInterceptor  该拦截器负责和服务器建立链接，先初始化一个exchange对象，根据这个对象赋值一个新的连接责任链，最后执行该连接责任链  // ConnectInterceptor.kt object ConnectInterceptor : Interceptor {   @Throws(IOException::class)   override fun intercept(chain: Interceptor.Chain): Response {     val realChain = chain as RealInterceptorChain     val exchange = realChain.call.initExchange(realChain)     val connectedChain = realChain.copy(exchange = exchange)     return connectedChain.proceed(realChain.request)   } }  // RealCall.kt internal fun initExchange(chain: RealInterceptorChain): Exchange {     synchronized(this) {         check(expectMoreExchanges) { \"released\" }         check(!responseBodyOpen)         check(!requestBodyOpen)     }      val exchangeFinder = this.exchangeFinder!!     val connection = exchangeFinder.find()     val codec = connection.newCodec(client, chain)     val result = Exchange(this, eventListener, exchangeFinder, codec)     this.interceptorScopedExchange = result     this.exchange = result     synchronized(this) {         this.requestBodyOpen = true         this.responseBodyOpen = true     }      if (canceled) throw IOException(\"Canceled\")     return result }   上面代码中初始化Exchange的过程，首先通过exchangeFinder的find方法返回一个RealConnection对象，然后根据这个对象的newCodeC方法，获得ExchangeCodec对象，最后构造出一个ExChange对象，可见这个对象中包含了一个RealConnection对象，它是Socket的包装类，也就是说最终获得的是一个建立连接的socket对象。  client.networkInterceptors  这是另一个自定义的网络拦截器networkInterceptors，按照顺序执行的规定，这时候连接已经建立了，可以获得数据了，因此可以利用它做一些网络调试，它和第一个自定义拦截器不同的地方在于，它们所处的拦截器位置不一样，第一个应用拦截器有且只能执行一次，而这个网络拦截器它可能执行0次（直接返回缓存）或者多次（失败重试）  CallServerInterceptor  它是最后一个拦截器了，前面的拦截器已经完成了socket连接和tls连接，那么这一步就是请求头与请求体发送给服务器以及解析服务器返回的数据。     首先向服务器发送header，如果有body也一并发送   解析Response header来构造Response对象，如果有body，就在前面的Response对象基础上添加上body   由于是最后一个拦截器，他不会再调用chain.proceed方法，而是将得到的Response返回给前面每一个拦截器   总结  最后用一张图，我们总结下整个工作流程："
  },
  
  {
    "title": "Android三方开源库之Retrofit源码分析",
    "url": "/posts/android-retrofit/",
    "categories": "Android",
    "tags": "源码分析",
    "date": "2020-07-08 00:00:00 +0800",
    "content": "Retrofit是目前Android开发中主流的网络请求客户端，其底层基于OkHttp封装，提供了方便高效的网络请求框架。  基本用法  Retrofit retrofit = new Retrofit.Builder()                 .baseUrl(\"https://api.github.com\")                 .addConverterFactory(GsonConverterFactory.create())                 .build();  GitHubApiService service = retrofit.create(GitHubApiService.class); Call&lt;List&lt;String&gt;&gt; call = service.listRepo();  call.enqueue(new Callback&lt;List&lt;String&gt;&gt;() {     @Override     public void onResponse(Call&lt;List&lt;String&gt;&gt; call, Response&lt;List&lt;String&gt;&gt; response) {      }      @Override     public void onFailure(Call&lt;List&lt;String&gt;&gt; call, Throwable t) {      } });  public interface GitHubAPIService {      @GET(\"/users/{user}/repos\")     Call&lt;List&lt;String&gt;&gt; listRepo(@Path(\"user\") String user); }   上面代码中，说下具体的每个类：     Retrofit，全局配置类，通过内部类Builder来构建   GitHubApiService是用户自己创建的接口，通过Retrofit的create方法实例化   Call是执行网络请求的一个顶层接口，具体在源码中真正执行的是OkHttpCall   Callback是请求结果的回调   源码分析  OkHttp的封装  首先通过call.enqueue方法来看：  // Call.java public interface Call&lt;T&gt; extends Cloneable {     ...     void enqueue(Callback&lt;T&gt; callback); \t... }   这是一个接口，我们自定义的接口返回的Call对象，所以说重点是看喜爱Retrofit的create方法：  // Retrofit.java public &lt;T&gt; T create(final Class&lt;T&gt; service) {     validateServiceInterface(service);     return (T)         Proxy.newProxyInstance(         service.getClassLoader(),         new Class&lt;?&gt;[] {service},         new InvocationHandler() {             private final Platform platform = Platform.get();             private final Object[] emptyArgs = new Object[0];              @Override             public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args)                 throws Throwable {                 // If the method is a method from Object then defer to normal invocation.                 if (method.getDeclaringClass() == Object.class) {                     return method.invoke(this, args);                 }                 args = args != null ? args : emptyArgs;                 return platform.isDefaultMethod(method)                     ? platform.invokeDefaultMethod(method, service, proxy, args)                     : loadServiceMethod(method).invoke(args);             }         }); }   这里面主要是用到了Java的动态代理，在运行期，动态的创建我们自定义接口的实现类，作为代理对象，当调用接口方法时，会执行InvocationHandler 的 invoke 方法。  紧接着看invoke方法代码：  如果要执行的方法是来自于Object，那么就Object调用自己的方法，否则就会根据平台（Java8）执行默认的方法，因为是在Android平台，会走到loadServiceMethod(method).invoke(args)这里，紧接着看下这个方法：  // Retrofit.java  ServiceMethod&lt;?&gt; loadServiceMethod(Method method) {     ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);     if (result != null) return result;      synchronized (serviceMethodCache) {         result = serviceMethodCache.get(method);         if (result == null) {             result = ServiceMethod.parseAnnotations(this, method);             serviceMethodCache.put(method, result);         }     }     return result; }   该方法通过ServiceMethod.parseAnnotations(this, method)创建一个ServiceMethod对象，并缓存起来，当下次调用的时候，会先从缓存取。  // ServiceMethod.java static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method) {     RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);      Type returnType = method.getGenericReturnType();     if (Utils.hasUnresolvableType(returnType)) {         throw methodError(             method,             \"Method return type must not include a type variable or wildcard: %s\",             returnType);     }     if (returnType == void.class) {         throw methodError(method, \"Service methods cannot return void.\");     }      return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory); }   上面ServiceMethod的方法返回一个HttpServiceMethod的泛型对象，紧接着看下该对象的invoke方法：  // HttpServiceMethod.java @Override final @Nullable ReturnT invoke(Object[] args) {     Call&lt;ResponseT&gt; call = new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);     return adapt(call, args); }   从上面代码也可以看出来，内部利用OkHttpCall创建了一个Call对象，其中adapt方法是一个抽象方法，我们通过HttpServiceMethod.parseAnnotations方法可以看到：  // HttpServiceMethod.java static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations(       Retrofit retrofit, Method method, RequestFactory requestFactory) {     boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;     boolean continuationWantsResponse = false;     boolean continuationBodyNullable = false;      Annotation[] annotations = method.getAnnotations();     Type adapterType;     if (isKotlinSuspendFunction) {       Type[] parameterTypes = method.getGenericParameterTypes();       Type responseType =           Utils.getParameterLowerBound(               0, (ParameterizedType) parameterTypes[parameterTypes.length - 1]);       if (getRawType(responseType) == Response.class &amp;&amp; responseType instanceof ParameterizedType) {         // Unwrap the actual body type from Response&lt;T&gt;.         responseType = Utils.getParameterUpperBound(0, (ParameterizedType) responseType);         continuationWantsResponse = true;       } else {         // TODO figure out if type is nullable or not         // Metadata metadata = method.getDeclaringClass().getAnnotation(Metadata.class)         // Find the entry for method         // Determine if return type is nullable or not       }        adapterType = new Utils.ParameterizedTypeImpl(null, Call.class, responseType);       annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);     } else {       adapterType = method.getGenericReturnType();     }      // 创建CallAdapter对象     CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =         createCallAdapter(retrofit, method, adapterType, annotations);     Type responseType = callAdapter.responseType();          ...      Converter&lt;ResponseBody, ResponseT&gt; responseConverter =         createResponseConverter(retrofit, method, responseType);      okhttp3.Call.Factory callFactory = retrofit.callFactory;     if (!isKotlinSuspendFunction) {                  // 如果不是kotlin挂起函数，返回CallAdapted       return new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);     } else if (continuationWantsResponse) {       //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.       return (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)           new SuspendForResponse&lt;&gt;(               requestFactory,               callFactory,               responseConverter,               (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);     } else {       //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.       return (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)           new SuspendForBody&lt;&gt;(               requestFactory,               callFactory,               responseConverter,               (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter,               continuationBodyNullable);     }   }   从方法返回值可以看出，如果不是kotlin挂起函数，这里返回的其实CallAdapted对象，  static final class CallAdapted&lt;ResponseT, ReturnT&gt; extends HttpServiceMethod&lt;ResponseT, ReturnT&gt; {     private final CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter;      CallAdapted(         RequestFactory requestFactory,         okhttp3.Call.Factory callFactory,         Converter&lt;ResponseBody, ResponseT&gt; responseConverter,         CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter) {       super(requestFactory, callFactory, responseConverter);       this.callAdapter = callAdapter;     }      @Override     protected ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args) {       return callAdapter.adapt(call);     }   }   从上面可以看出，该对象继承自HttpServiceMethod，所以先是调用其父类的invoke方法，在该方法里面调用它自身（CallAdapted）的adapt方法，进而 调用CallAdapter的adapt方法，而CallAdapter其实是在上面HttpServiceMethod.parseAnnotations这个方法里通过下面一段代码创建出来的对象：  CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =     createCallAdapter(retrofit, method, adapterType, annotations);   我们接着看下该方法：  // HttpServiceMethod.java private static &lt;ResponseT, ReturnT&gt; CallAdapter&lt;ResponseT, ReturnT&gt; createCallAdapter(     Retrofit retrofit, Method method, Type returnType, Annotation[] annotations) {     try {         //noinspection unchecked         return (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations);     } catch (RuntimeException e) { // Wide exception range because factories are user code.         throw methodError(method, e, \"Unable to create call adapter for %s\", returnType);     } }   该方法会调用Retrofit的callAdapter方法:  // Retrofit.java public CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) {     return nextCallAdapter(null, returnType, annotations); }  public CallAdapter&lt;?, ?&gt; nextCallAdapter(     @Nullable CallAdapter.Factory skipPast, Type returnType, Annotation[] annotations) {     ...      int start = callAdapterFactories.indexOf(skipPast) + 1;     for (int i = start, count = callAdapterFactories.size(); i &lt; count; i++) {         CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(returnType, annotations, this);         if (adapter != null) {             return adapter;         }     }     ... }    经过一系列调用发现，callAdapter对象是遍历callAdapterFactories这个集合，然后调用里面对象的get方法，根据返回值得到CallAdapter，如果不为空，就直接返回该CallAdapter对象，我们看下这个这个列表是从什么时候添加进去值的：  public Retrofit build() {     ...      okhttp3.Call.Factory callFactory = this.callFactory;     if (callFactory == null) {         callFactory = new OkHttpClient();     }      Executor callbackExecutor = this.callbackExecutor;     if (callbackExecutor == null) {         callbackExecutor = platform.defaultCallbackExecutor();     }      // Make a defensive copy of the adapters and add the default Call adapter.     List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories);     callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));          ...      return new Retrofit(         callFactory,         baseUrl,         unmodifiableList(converterFactories),         unmodifiableList(callAdapterFactories),         callbackExecutor,         validateEagerly); }    我们看到通过Retrofit的build方法，在callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));处添加了一个默认的CallAdpaterFactory：  // Platform.java   List&lt;? extends CallAdapter.Factory&gt; defaultCallAdapterFactories(       @Nullable Executor callbackExecutor) {       // 上面的CallAdapter     DefaultCallAdapterFactory executorFactory = new DefaultCallAdapterFactory(callbackExecutor);     return hasJava8Types         ? asList(CompletableFutureCallAdapterFactory.INSTANCE, executorFactory)         : singletonList(executorFactory);   }    我们看下它的get方法：  final class DefaultCallAdapterFactory extends CallAdapter.Factory {   private final @Nullable Executor callbackExecutor;    DefaultCallAdapterFactory(@Nullable Executor callbackExecutor) {     this.callbackExecutor = callbackExecutor;   }    @Override   public @Nullable CallAdapter&lt;?, ?&gt; get(       Type returnType, Annotation[] annotations, Retrofit retrofit) {     if (getRawType(returnType) != Call.class) {       return null;     }     if (!(returnType instanceof ParameterizedType)) {       throw new IllegalArgumentException(           \"Call return type must be parameterized as Call&lt;Foo&gt; or Call&lt;? extends Foo&gt;\");     }     final Type responseType = Utils.getParameterUpperBound(0, (ParameterizedType) returnType);      final Executor executor =         Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class)             ? null             : callbackExecutor;      return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() {       @Override       public Type responseType() {         return responseType;       }        @Override       public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) {         return executor == null ? call : new ExecutorCallbackCall&lt;&gt;(executor, call);       }     };   } }    到这里其实我们也就看出来了，经过一连串的调用，我们发现CallAdapted的adapt方法调用其实就是DefaultCallAdapterFactory中get方法返回的CallAdapter对象的adapt方法调用，继续往上看，就是HttpMethodService的invoke方法中adapt方法的调用，又因为上面的executor在Retrofit的build方法中已经初始化，所以这个adapt方法返回一个ExecutorCallbackCall对象  // Retorfit.java public Retrofit build() {     ...     Executor callbackExecutor = this.callbackExecutor;     if (callbackExecutor == null) {         callbackExecutor = platform.defaultCallbackExecutor();     }      // Make a defensive copy of the adapters and add the default Call adapter.     List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories);     callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));     ... }   // Platform.java @Override public Executor defaultCallbackExecutor() {     return new MainThreadExecutor(); }  static final class MainThreadExecutor implements Executor {     private final Handler handler = new Handler(Looper.getMainLooper());      @Override     public void execute(Runnable r) {         handler.post(r);     } }   而ExecutorCallbackCall是对OkHttpCall和MainThreadExecutor的封装，它也是DefaultCallAdapterFactory的内部类：  // DefaultCallAdapterFactory.java static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; {     final Executor callbackExecutor;     final Call&lt;T&gt; delegate;      ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) {         this.callbackExecutor = callbackExecutor;         this.delegate = delegate;     }      @Override     public void enqueue(final Callback&lt;T&gt; callback) {         Objects.requireNonNull(callback, \"callback == null\");          delegate.enqueue(             new Callback&lt;T&gt;() {                 @Override                 public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) {                     callbackExecutor.execute(                         () -&gt; {                             if (delegate.isCanceled()) {                                 // Emulate OkHttp's behavior of throwing/delivering an IOException on                                 // cancellation.                                 callback.onFailure(ExecutorCallbackCall.this, new IOException(\"Canceled\"));                             } else {                                 callback.onResponse(ExecutorCallbackCall.this, response);                             }                         });                 }                  @Override                 public void onFailure(Call&lt;T&gt; call, final Throwable t) {                     callbackExecutor.execute(() -&gt; callback.onFailure(ExecutorCallbackCall.this, t));                 }             });     }      @Override     public boolean isExecuted() {         return delegate.isExecuted();     }      @Override     public Response&lt;T&gt; execute() throws IOException {         return delegate.execute();     }     ... }   通过执行ExecutorCallbackCall的enqueue方法，本质其实就是在执行OkHttpCall的enqueue方法：  // OKHttpCall.java @Override public void enqueue(final Callback&lt;T&gt; callback) {     Objects.requireNonNull(callback, \"callback == null\");      okhttp3.Call call;     Throwable failure;      synchronized (this) {         if (executed) throw new IllegalStateException(\"Already executed.\");         executed = true;          call = rawCall;         failure = creationFailure;         if (call == null &amp;&amp; failure == null) {             try {                 // 创建okhttp3.Call对象                 call = rawCall = createRawCall();             } catch (Throwable t) {                 throwIfFatal(t);                 failure = creationFailure = t;             }         }     }      if (failure != null) {         callback.onFailure(this, failure);         return;     }      if (canceled) {         call.cancel();     }      call.enqueue(         new okhttp3.Callback() {             @Override             public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {                 Response&lt;T&gt; response;                 try {                     response = parseResponse(rawResponse);                 } catch (Throwable e) {                     throwIfFatal(e);                     callFailure(e);                     return;                 }                  try {                     callback.onResponse(OkHttpCall.this, response);                 } catch (Throwable t) {                     throwIfFatal(t);                     t.printStackTrace(); // TODO this is not great                 }             }              @Override             public void onFailure(okhttp3.Call call, IOException e) {                 callFailure(e);             }              private void callFailure(Throwable e) {                 try {                     callback.onFailure(OkHttpCall.this, e);                 } catch (Throwable t) {                     throwIfFatal(t);                     t.printStackTrace(); // TODO this is not great                 }             }         }); }  private okhttp3.Call createRawCall() throws IOException {     okhttp3.Call call = callFactory.newCall(requestFactory.create(args));     if (call == null) {         throw new NullPointerException(\"Call.Factory returned null.\");     }     return call; }   上面代码首先通过createRawCall方法创建了一个okhttp3.Call对象，其实就是通过callFactory的newCall方法创建的，而callFactory对象是在在 OkHttpCall 构造中直接赋值的  // OKHttpCall.java   OkHttpCall(     RequestFactory requestFactory,     Object[] args,     okhttp3.Call.Factory callFactory,     Converter&lt;ResponseBody, T&gt; responseConverter) {     this.requestFactory = requestFactory;     this.args = args;     this.callFactory = callFactory;     this.responseConverter = responseConverter; }   那么OkHttpCall是在哪创建的呢？继续往回追代码，可以看到是在HttpServiceMethod的invoke方法里  @Override final @Nullable ReturnT invoke(Object[] args) {   Call&lt;ResponseT&gt; call = new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);   return adapt(call, args); }   而这里callFactory是HttpServiceMethod的成员变量，在其parseAnnotations方法中被赋值：  // HttpServiceMethod.java static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations(     Retrofit retrofit, Method method, RequestFactory requestFactory) {          ...              okhttp3.Call.Factory callFactory = retrofit.callFactory;     ... }     而Retrofit的callFactory是通过Builder构建的  // Retorfit.java public Retrofit build() {     if (baseUrl == null) {         throw new IllegalStateException(\"Base URL required.\");     }      okhttp3.Call.Factory callFactory = this.callFactory;     if (callFactory == null) {         callFactory = new OkHttpClient();     }      Executor callbackExecutor = this.callbackExecutor;     if (callbackExecutor == null) {         callbackExecutor = platform.defaultCallbackExecutor();     }      // Make a defensive copy of the adapters and add the default Call adapter.     List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories);     callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));      // Make a defensive copy of the converters.     List&lt;Converter.Factory&gt; converterFactories =         new ArrayList&lt;&gt;(         1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize());      // Add the built-in converter factory first. This prevents overriding its behavior but also     // ensures correct behavior when using converters that consume all types.     converterFactories.add(new BuiltInConverters());     converterFactories.addAll(this.converterFactories);     converterFactories.addAll(platform.defaultConverterFactories());      return new Retrofit(         callFactory,         baseUrl,         unmodifiableList(converterFactories),         unmodifiableList(callAdapterFactories),         callbackExecutor,         validateEagerly); }     从上面也可以发现原来一直寻找的callFactory就是OkHttpClient，综上也就是通过OkHttpClient的newCall方法创建了Call对象，从这里也就可以看出其实主要用的是OkHttp这一网络请求库，也验证了我们一开始说的Retrofit其实就是对OkHttp的封装。  Request对象构建  我们还回到ServiceMethod.parseAnnotations方法：  static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method) {     RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);     ...     return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory); }    再来看下RequestFactory.parseAnnotations方法：  final class RequestFactory {   static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {     return new Builder(retrofit, method).build();   }     Builder(Retrofit retrofit, Method method) {         this.retrofit = retrofit;         this.method = method;         this.methodAnnotations = method.getAnnotations();         this.parameterTypes = method.getGenericParameterTypes();         this.parameterAnnotationsArray = method.getParameterAnnotations();     }     RequestFactory build() {       for (Annotation annotation : methodAnnotations) {           // 解析自定义接口的方法注解         parseMethodAnnotation(annotation);       }        ...        int parameterCount = parameterAnnotationsArray.length;       parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];       for (int p = 0, lastParameter = parameterCount - 1; p &lt; parameterCount; p++) {         parameterHandlers[p] =             parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p], p == lastParameter);       }        ...              return new RequestFactory(this);     }     private void parseMethodAnnotation(Annotation annotation) {       if (annotation instanceof DELETE) {         parseHttpMethodAndPath(\"DELETE\", ((DELETE) annotation).value(), false);       } else if (annotation instanceof GET) {         parseHttpMethodAndPath(\"GET\", ((GET) annotation).value(), false);       } else if (annotation instanceof HEAD) {         parseHttpMethodAndPath(\"HEAD\", ((HEAD) annotation).value(), false);       } else if (annotation instanceof PATCH) {         parseHttpMethodAndPath(\"PATCH\", ((PATCH) annotation).value(), true);       } else if (annotation instanceof POST) {         parseHttpMethodAndPath(\"POST\", ((POST) annotation).value(), true);       } else if (annotation instanceof PUT) {         parseHttpMethodAndPath(\"PUT\", ((PUT) annotation).value(), true);       } else if (annotation instanceof OPTIONS) {         parseHttpMethodAndPath(\"OPTIONS\", ((OPTIONS) annotation).value(), false);       } else if (annotation instanceof HTTP) {         HTTP http = (HTTP) annotation;         parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());       } else if (annotation instanceof retrofit2.http.Headers) {         String[] headersToParse = ((retrofit2.http.Headers) annotation).value();         if (headersToParse.length == 0) {           throw methodError(method, \"@Headers annotation is empty.\");         }         headers = parseHeaders(headersToParse);       } else if (annotation instanceof Multipart) {         if (isFormEncoded) {           throw methodError(method, \"Only one encoding annotation is allowed.\");         }         isMultipart = true;       } else if (annotation instanceof FormUrlEncoded) {         if (isMultipart) {           throw methodError(method, \"Only one encoding annotation is allowed.\");         }         isFormEncoded = true;       }     }     ... }    上面这个方法解析方法注解参数，然后返回RequestFactory 对象，最后传到HttpServiceMethod.parseAnnotations方法里面，后面传递给CallAdapted构造函数，从而调用父类HttpServiceMethod的构造函数，赋值给其成员变量requestFactory，然后在OkHttpCall构造函数中传递，赋值给其成员变量requestFactory，即一开始我们看的代码中的requestFactory值：  okhttp3.Call call = callFactory.newCall(requestFactory.create(args));  紧接着我们看下其create方法：  // RequestFactory.java okhttp3.Request create(Object[] args) throws IOException {          ...      RequestBuilder requestBuilder =         new RequestBuilder(             httpMethod,             baseUrl,             relativeUrl,             headers,             contentType,             hasBody,             isFormEncoded,             isMultipart);      if (isKotlinSuspendFunction) {       // The Continuation is the last parameter and the handlers array contains null at that index.       argumentCount--;     }      List&lt;Object&gt; argumentList = new ArrayList&lt;&gt;(argumentCount);     for (int p = 0; p &lt; argumentCount; p++) {       argumentList.add(args[p]);       handlers[p].apply(requestBuilder, args[p]);     }      return requestBuilder.get().tag(Invocation.class, new Invocation(method, argumentList)).build();   }   从上面代码可以看出，最后通过RequestBuilder来构造okhttp3.Request 的对象  Response解析  我们回到OkHttpCall方法中，  // OkHttpCall.java @Override public void enqueue(final Callback&lt;T&gt; callback) {    ...      call.enqueue(         new okhttp3.Callback() {             @Override             public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {                 Response&lt;T&gt; response;                 try {                     // 解析返回结果                     response = parseResponse(rawResponse);                 } catch (Throwable e) {                     throwIfFatal(e);                     callFailure(e);                     return;                 }                  try {                     callback.onResponse(OkHttpCall.this, response);                 } catch (Throwable t) {                     throwIfFatal(t);                     t.printStackTrace(); // TODO this is not great                 }             }              @Override             public void onFailure(okhttp3.Call call, IOException e) {                 callFailure(e);             }              private void callFailure(Throwable e) {                 try {                     callback.onFailure(OkHttpCall.this, e);                 } catch (Throwable t) {                     throwIfFatal(t);                     t.printStackTrace(); // TODO this is not great                 }             }         }); } Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException {     ResponseBody rawBody = rawResponse.body();      // Remove the body's source (the only stateful object) so we can pass the response along.     rawResponse =         rawResponse             .newBuilder()             .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))             .build();      int code = rawResponse.code();     if (code &lt; 200 || code &gt;= 300) {       try {         // Buffer the entire body to avoid future I/O.         ResponseBody bufferedBody = Utils.buffer(rawBody);         return Response.error(bufferedBody, rawResponse);       } finally {         rawBody.close();       }     }      if (code == 204 || code == 205) {       rawBody.close();       return Response.success(null, rawResponse);     }      ExceptionCatchingResponseBody catchingBody = new ExceptionCatchingResponseBody(rawBody);     try {         // 通过 responseConverter 转换 ResponseBody       T body = responseConverter.convert(catchingBody);       return Response.success(body, rawResponse);     } catch (RuntimeException e) {       // If the underlying source threw an exception, propagate that rather than indicating it was       // a runtime exception.       catchingBody.throwIfCaught();       throw e;     }   }   从上面方法我们看到，解析返回结果的方法为parseResponse方法，在该方法中通过 responseConverter 转换 ResponseBody，而responseConverter同样是OkHttpCall构造方法传进来的，继续往回查找代码，最后找到该对象来自下面这行代码：  // HttpServiceMethod.java static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations(       Retrofit retrofit, Method method, RequestFactory requestFactory) {     ... \tConverter&lt;ResponseBody, ResponseT&gt; responseConverter =     createResponseConverter(retrofit, method, responseType);     ... }  private static &lt;ResponseT&gt; Converter&lt;ResponseBody, ResponseT&gt; createResponseConverter(     Retrofit retrofit, Method method, Type responseType) {     Annotation[] annotations = method.getAnnotations();     try {         return retrofit.responseBodyConverter(responseType, annotations);     } catch (RuntimeException e) { // Wide exception range because factories are user code.         throw methodError(method, e, \"Unable to create converter for %s\", responseType);     } }    最后还是调用Retrofit的responseBodyConverter方法：  // Retrofit.java public &lt;T&gt; Converter&lt;ResponseBody, T&gt; responseBodyConverter(Type type, Annotation[] annotations) {     return nextResponseBodyConverter(null, type, annotations); }  public &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter(     @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) {     ...      int start = converterFactories.indexOf(skipPast) + 1;     for (int i = start, count = converterFactories.size(); i &lt; count; i++) {         Converter&lt;ResponseBody, ?&gt; converter =             converterFactories.get(i).responseBodyConverter(type, annotations, this);         if (converter != null) {             //noinspection unchecked             return (Converter&lt;ResponseBody, T&gt;) converter;         }     }      ... }  public Retrofit build() {       // Make a defensive copy of the converters.       List&lt;Converter.Factory&gt; converterFactories =           new ArrayList&lt;&gt;(               1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize());        // Add the built-in converter factory first. This prevents overriding its behavior but also       // ensures correct behavior when using converters that consume all types.     // 添加默认的构建的转换器       converterFactories.add(new BuiltInConverters());     // 添加自己配置的转换器       converterFactories.addAll(this.converterFactories);     // 如果是 Java8 就添加一个 OptionalConverterFactory 的转换器，否则就是一个空的       converterFactories.addAll(platform.defaultConverterFactories());        return new Retrofit(           callFactory,           baseUrl,           unmodifiableList(converterFactories),           unmodifiableList(callAdapterFactories),           callbackExecutor,           validateEagerly);     }   可以看到通过遍历converterFactories，然后根据返回值类型type来找到对应的 Converter 解析，如果不为空，直接返回此 Converter 对象，该对象也就是我们要找的Converter对象，这里通过Retrofit的build方法往converterFactories添加自己配置的转换器GsonConverterFactory，从而调用其responseBodyConverter方法：  // GsonConverterFactory.java @Override public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations,                                                         Retrofit retrofit) {     TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));     return new GsonResponseBodyConverter&lt;&gt;(gson, adapter); }   上面返回GsonResponseBodyConverter对象，然后调用其convert方法，返回我们需要的结果：  // GsonResponseBodyConverter.java @Override public T convert(ResponseBody value) throws IOException {     JsonReader jsonReader = gson.newJsonReader(value.charStream());     try {         T result = adapter.read(jsonReader);         if (jsonReader.peek() != JsonToken.END_DOCUMENT) {             throw new JsonIOException(\"JSON document was not fully consumed.\");         }         return result;     } finally {         value.close();     } }   RxJava支持  我们在初始化一个Retrofit时加入 addCallAdapterFactory(RxJava2CallAdapterFactory.create())这行  val retrofit = Retrofit.Builder()     .baseUrl(\"https://api.github.com/\")     //加入 RxJava2CallAdapterFactory 支持     .addCallAdapterFactory(RxJava2CallAdapterFactory.create())     .addConverterFactory(GsonConverterFactory.create())     .build()      interface GitHubApiService {     @GET(\"users/{user}/repos\")     fun listReposRx(@Path(\"user\") user: String?): Single&lt;Repo&gt; }  //创建出GitHubApiService对象 val service = retrofit.create(GitHubApiService::class.java) service.listReposRx(\"octocat\")     .subscribeOn(Schedulers.io())     .observeOn(AndroidSchedulers.mainThread())     .subscribe({ repo -&gt;         \"response name = ${repo[0].name}\".logE()     }, { error -&gt;         error.printStackTrace()     })    通过该方法会把RxJava2CallAdapterFactory加入到callAdapterFactories这个list集合中，接下来同样回到HttpServiceMethod的parseAnnotations方法中：  //HttpServiceMethod.java static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations(     Retrofit retrofit, Method method, RequestFactory requestFactory) {    ....     CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =       createCallAdapter(retrofit, method, adapterType, annotations);    okhttp3.Call.Factory callFactory = retrofit.callFactory;   if (!isKotlinSuspendFunction) {          return new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);   }      ... }    在接下来和上面一样的过程，经过一系列方法追溯，最后到了Retrofit的nextCallAdapter方法中：  // Retrofit.java public CallAdapter&lt;?, ?&gt; nextCallAdapter(       @Nullable CallAdapter.Factory skipPast, Type returnType, Annotation[] annotations) {     ...     for (int i = start, count = callAdapterFactories.size(); i &lt; count; i++) {       CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(returnType, annotations, this);       if (adapter != null) {         return adapter;       }     }     ... }    遍历 callAdapterFactories 根据 returnType类型 来找到对应的 CallAdapter 返回  比如：我们在 GitHubApiService 的 returnType 类型为 Single，那么返回的就是 RxJava2CallAdapterFactory 所获取的 CallAdapter，这里看下通过RxJava2CallAdapterFactory的 get方法  // RxJava2CallAdapterFactory.java @Override public @Nullable CallAdapter&lt;?, ?&gt; get(       Type returnType, Annotation[] annotations, Retrofit retrofit) {          Class&lt;?&gt; rawType = getRawType(returnType);      if (rawType == Completable.class) {       // Completable is not parameterized (which is what the rest of this method deals with) so it       // can only be created with a single configuration.       return new RxJava2CallAdapter(Void.class, scheduler, isAsync, false, true, false, false,           false, true);     }      boolean isFlowable = rawType == Flowable.class;     // 当期是Single，所以isSingle返回true     boolean isSingle = rawType == Single.class;     boolean isMaybe = rawType == Maybe.class;     if (rawType != Observable.class &amp;&amp; !isFlowable &amp;&amp; !isSingle &amp;&amp; !isMaybe) {       return null;     }     ...      return new RxJava2CallAdapter(responseType, scheduler, isAsync, isResult, isBody, isFlowable,         isSingle, isMaybe, false);   }   上面 方法返回RxJava2CallAdapter类，然后调用其adapt方法，  // RxJava2CallAdapter.java @Override public Object adapt(Call&lt;R&gt; call) {     Observable&lt;Response&lt;R&gt;&gt; responseObservable = isAsync         ? new CallEnqueueObservable&lt;&gt;(call)         : new CallExecuteObservable&lt;&gt;(call);      Observable&lt;?&gt; observable;     if (isResult) {         observable = new ResultObservable&lt;&gt;(responseObservable);     } else if (isBody) {         observable = new BodyObservable&lt;&gt;(responseObservable);     } else {         observable = responseObservable;     }      if (scheduler != null) {         observable = observable.subscribeOn(scheduler);     }      if (isFlowable) {         return observable.toFlowable(BackpressureStrategy.LATEST);     }     if (isSingle) {         return observable.singleOrError();     }     if (isMaybe) {         return observable.singleElement();     }     if (isCompletable) {         return observable.ignoreElements();     }     return RxJavaPlugins.onAssembly(observable); }   对于Single则调用observable.singleOrError()方法，剩下的就交给RxJava来处理了。  总结     通过自定义接口，通过Retrofit生成对应的接口实例，然后调用接口方法时，会调用InvocationHandler 的 invoke方法   然后执行 loadServiceMethod方法并返回一个 HttpServiceMethod 对象并调用它的 invoke方法   最后执行OkHttpCall的enqueue方法，本质也是在执行okhttp3.Call 的 enqueue方法   当然在这期间会解析方法上的注解，构建 okhttp3.Call 需要的 okhttp3.Request 对象   然后通过 Converter 来解析返回的响应数据，并回调 CallBack 接口"
  },
  
  {
    "title": "Android三方开源库之LeakCanary2.4源码分析",
    "url": "/posts/android-leakcanary/",
    "categories": "Android",
    "tags": "源码分析",
    "date": "2020-06-29 00:00:00 +0800",
    "content": "LeanCanary内部主要使用了Reference以及ReferenceQueue配合来实现对象被回收时的监听，这是它的核心逻辑，因此我们先了解下这部分内容：  Reference  Reference是一个泛型抽象类，其中软引用、弱引用、虚引用都继承自它，它主要有几个成员变量：     泛型引用对象 T：被回收时被赋值为null   引用队列 ReferenceQueue：一个单链表实现的队列，保存即将被回收的引用对象   queueNext：指向下一个待处理的Reference引用对象   pendingNext：指向下一个待入列的Reference引用对象   ReferenceQueue  Reference配合ReferenceQueue就可以实现对象回收监听，示例代码如下：  //创建一个引用队列 ReferenceQueue queue = new ReferenceQueue(); //创建弱引用，并关联引用队列queue WeakReference reference = new WeakReference(new Object(),queue); System.out.println(reference); System.gc(); //当reference被成功回收后，可以从queue中获取到该引用 System.out.println(queue.remove());   被回收后的对象如果在引用队列中找到该引用，则说明对象被回收了，否则就表明该引用有内存泄漏的风险，这也就是LeakCanary的基本原理。  源码分析  LeakCanary在2.0之前版本，通过install方法来完成初始化，但是2.0之后，内部继承ContentProvider完成初始化工作，我们知道App启动后调用一系列声明周期方法：Application-&gt;attachBaseContext =====&gt;ContentProvider-&gt;onCreate =====&gt;Application-&gt;onCreate =====&gt;Activity-&gt;onCreate，可见这里面会调用到ContentProvider的onCreate方法，我们的初始化工作在这里面完成就可以了：  找到leakcanary-object-watcher-android项目的manifest文件，可以看到：  &lt;application&gt;     &lt;provider          android:name=\"leakcanary.internal.AppWatcherInstaller$MainProcess\"          android:authorities=\"${applicationId}.leakcanary-installer\"          android:enabled=\"@bool/leak_canary_watcher_auto_install\"          android:exported=\"false\" /&gt; &lt;/application&gt;   AppWatcherInstaller该类继承自ContentProvider，App启动后调用它的onCreate方法：  // AppWatcherInstaller.kt internal sealed class AppWatcherInstaller : ContentProvider() {   override fun onCreate(): Boolean {     val application = context!!.applicationContext as Application     // 开始初始化工作     AppWatcher.manualInstall(application)     return true   } }   紧接着看下AppWatcher的manualInstall方法：  // AppWatcher.kt  fun manualInstall(application: Application) {     InternalAppWatcher.install(application) }   内部又调用了InternalAppWatcher的install方法：  // InternalAppWatcher.kt  fun install(application: Application) {     checkMainThread()     if (this::application.isInitialized) {         return     }     // 日志初始化     SharkLog.logger = DefaultCanaryLog()     InternalAppWatcher.application = application      val configProvider = { AppWatcher.config }     // Activity内存泄漏监听     ActivityDestroyWatcher.install(application, objectWatcher, configProvider)     // Fragment内存泄漏监听     FragmentDestroyWatcher.install(application, objectWatcher, configProvider)     // 注册内存泄漏事件回调     onAppWatcherInstalled(application) }   这个方法中首先检查是否在主线程中，然后判断Application是否完成初始化，经过一系列配置，进入到Activity和Fragment的内存泄漏监听，最后注册回调事件。  Activity内存泄漏监听  // ActivityDestroyWatcher.kt internal class ActivityDestroyWatcher private constructor(   private val objectWatcher: ObjectWatcher,   private val configProvider: () -&gt; Config ) {    private val lifecycleCallbacks =     object : Application.ActivityLifecycleCallbacks by noOpDelegate() {       override fun onActivityDestroyed(activity: Activity) {         if (configProvider().watchActivities) {           objectWatcher.watch(               activity, \"${activity::class.java.name} received Activity#onDestroy() callback\"           )         }       }     }    companion object {     fun install(       application: Application,       objectWatcher: ObjectWatcher,       configProvider: () -&gt; Config     ) {       val activityDestroyWatcher =         ActivityDestroyWatcher(objectWatcher, configProvider)   application.registerActivityLifecycleCallbacks(activityDestroyWatcher.lifecycleCallbacks)     }   } }   上面代码中，通过调用Application的registerActivityLifecycleCallbacks方法，注册lifecycleCallback，进而可以通过回调获取app的的每一个Activity生命周期变化，这里只重写了onActivityDestroyed方法，原因是在于by noOpDelegate(),通过类委托机制将其他回调实现都交给noOpDelegate，而noOpDelegate是一个空实现的动态代理。在遇到只需要实现接口的部分方法时，就可以这么做，其他方法实现都委托给空实现代理类就好了。  Fragment内存泄漏监听  // FragmentDestroyWatcher.kt  fun install(     application: Application,     objectWatcher: ObjectWatcher,     configProvider: () -&gt; AppWatcher.Config ) {     val fragmentDestroyWatchers = mutableListOf&lt;(Activity) -&gt; Unit&gt;()      // Android O后构建AndroidOFragmentDestroyWatcher     if (SDK_INT &gt;= O) {         fragmentDestroyWatchers.add(             AndroidOFragmentDestroyWatcher(objectWatcher, configProvider)         )     } \t// androidx.fragment.app.Fragment     getWatcherIfAvailable(         ANDROIDX_FRAGMENT_CLASS_NAME,         ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,         objectWatcher,         configProvider     )?.let {         fragmentDestroyWatchers.add(it)     } \t// android.support.v4.app.Fragment     getWatcherIfAvailable(         ANDROID_SUPPORT_FRAGMENT_CLASS_NAME,         ANDROID_SUPPORT_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,         objectWatcher,         configProvider     )?.let {         fragmentDestroyWatchers.add(it)     }      if (fragmentDestroyWatchers.size == 0) {         return     }      // 注册Activity生命周期回调，在Activity的onActivityCreated()方法中遍历这些watcher方法类型，实际调用的是对应的invoke方法     application.registerActivityLifecycleCallbacks(object : Application.ActivityLifecycleCallbacks by noOpDelegate() {         override fun onActivityCreated(             activity: Activity,             savedInstanceState: Bundle?         ) {             for (watcher in fragmentDestroyWatchers) {                 watcher(activity)             }         }     }) }   Fragment要分情况了：     如果系统是Android O以后版本，使用AndroidOFragmentDestroyWatcher   如果App中使用了androidx中的fragment，则添加对应的AndroidXFragmentDestroyWatcher   如果App中使用了support库中的fragment，则添加AndroidSupportFragmentDestroyWatcher   但是最终都会在invoke方法中使用对应的fragmentManager注册Fragment的生命周期回调，在onFragmentViewDestroyed()和onFragmentDestroyed()方法中使用ObjectWatcher来检测fragment。源码如下：  // AndroidOFragmentDestroyWatcher.kt internal class AndroidOFragmentDestroyWatcher(   private val objectWatcher: ObjectWatcher,   private val configProvider: () -&gt; Config ) : (Activity) -&gt; Unit {   private val fragmentLifecycleCallbacks = object : FragmentManager.FragmentLifecycleCallbacks() {      override fun onFragmentViewDestroyed(       fm: FragmentManager,       fragment: Fragment     ) {       val view = fragment.view       if (view != null &amp;&amp; configProvider().watchFragmentViews) {         objectWatcher.watch(             view, \"${fragment::class.java.name} received Fragment#onDestroyView() callback \" +             \"(references to its views should be cleared to prevent leaks)\"         )       }     }      override fun onFragmentDestroyed(       fm: FragmentManager,       fragment: Fragment     ) {       if (configProvider().watchFragments) {         objectWatcher.watch(             fragment, \"${fragment::class.java.name} received Fragment#onDestroy() callback\"         )       }     }   }    override fun invoke(activity: Activity) {     val fragmentManager = activity.fragmentManager     fragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true)   } }    这里拿AndroidOFragmentDestroyWatcher源码来看，其他两个类似，从上面可以看出在onFragmentDestroyed回调里面来处理检查Fragment是否正常被回收的检测逻辑，在onFragmentViewDestroyed回调里面来处理检查Fragment的View是否正常被回收的检测逻辑。另外在AndroidXFragmentDestroyWatcher中，LeakCanary增加了对ViewModel的检测，ViewModelClearedWatcher继承自ViewModel，里面使用viewModelMap来存储ViewModelStoreOwner中的ViewModel,并使用伴生对象来初始化自己，关联到ViewModelStoreOwner；在onCleared()方法中使用ObjectWatcher来监测。源码如下：  // ViewModelClearedWatcher.kt internal class ViewModelClearedWatcher(   storeOwner: ViewModelStoreOwner,   private val objectWatcher: ObjectWatcher,   private val configProvider: () -&gt; Config ) : ViewModel() {    private val viewModelMap: Map&lt;String, ViewModel&gt;?    init {     // We could call ViewModelStore#keys with a package spy in androidx.lifecycle instead,     // however that was added in 2.1.0 and we support AndroidX first stable release. viewmodel-2.0.0     // does not have ViewModelStore#keys. All versions currently have the mMap field.     viewModelMap = try {       val mMapField = ViewModelStore::class.java.getDeclaredField(\"mMap\")       mMapField.isAccessible = true       @Suppress(\"UNCHECKED_CAST\")       mMapField[storeOwner.viewModelStore] as Map&lt;String, ViewModel&gt;     } catch (ignored: Exception) {       null     }   }    override fun onCleared() {     if (viewModelMap != null &amp;&amp; configProvider().watchViewModels) {       viewModelMap.values.forEach { viewModel -&gt;         objectWatcher.watch(             viewModel, \"${viewModel::class.java.name} received ViewModel#onCleared() callback\"         )       }     }   }    companion object {     fun install(       storeOwner: ViewModelStoreOwner,       objectWatcher: ObjectWatcher,       configProvider: () -&gt; Config     ) {       val provider = ViewModelProvider(storeOwner, object : Factory {         @Suppress(\"UNCHECKED_CAST\")         override fun &lt;T : ViewModel?&gt; create(modelClass: Class&lt;T&gt;): T =           ViewModelClearedWatcher(storeOwner, objectWatcher, configProvider) as T       })       provider.get(ViewModelClearedWatcher::class.java)     }   } }    综上，我们发现最后都是交给ObjectWatcher来检测Activity、Fragment、Fragment中的View和ViewModel的，这里以Activity为例来看下：  // ObjectWatcher.kt private val watchedObjects = mutableMapOf&lt;String, KeyedWeakReference&gt;()  private val queue = ReferenceQueue&lt;Any&gt;() @Synchronized fun watch(     watchedObject: Any,     description: String ) {     if (!isEnabled()) {         return     }     removeWeaklyReachableObjects()     val key = UUID.randomUUID()     .toString()     val watchUptimeMillis = clock.uptimeMillis()     val reference =     KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)     SharkLog.d {         \"Watching \" +         (if (watchedObject is Class&lt;*&gt;) watchedObject.toString() else \"instance of ${watchedObject.javaClass.name}\") +         (if (description.isNotEmpty()) \" ($description)\" else \"\") +         \" with key $key\"     }      watchedObjects[key] = reference     checkRetainedExecutor.execute {         moveToRetained(key)     } }  private fun removeWeaklyReachableObjects() {     // WeakReferences are enqueued as soon as the object to which they point to becomes weakly     // reachable. This is before finalization or garbage collection has actually happened.     var ref: KeyedWeakReference?     do {         ref = queue.poll() as KeyedWeakReference?         if (ref != null) {             watchedObjects.remove(ref.key)         }     } while (ref != null) }   上面首先从watchedObjects集合Map中移除之前回收的引用，这里面的key为UUID，value为包装过的引用对象KeyedWeakReference，它继承自WeakReference：  // KeyedWeakReference.kt class KeyedWeakReference(   referent: Any,   val key: String,   val description: String,   val watchUptimeMillis: Long,   referenceQueue: ReferenceQueue&lt;Any&gt; ) : WeakReference&lt;Any&gt;(     referent, referenceQueue ) {   /**    * Time at which the associated object ([referent]) was considered retained, or -1 if it hasn't    * been yet.    */   @Volatile   var retainedUptimeMillis = -1L    companion object {     @Volatile     @JvmStatic var heapDumpUptimeMillis = 0L   }  }   最终会执行一个后台线程来检查在5秒后，引用对象是否回收。  // InternalAppWatcher.kt private val checkRetainedExecutor = Executor {     mainHandler.postDelayed(it, AppWatcher.config.watchDurationMillis) }  // AppWatcher.kt val watchDurationMillis: Long = TimeUnit.SECONDS.toMillis(5)   上面被执行的任务就是moveToRetained方法：  // ObjectWatcher.kt @Synchronized private fun moveToRetained(key: String) {     removeWeaklyReachableObjects()     val retainedRef = watchedObjects[key]     if (retainedRef != null) {         retainedRef.retainedUptimeMillis = clock.uptimeMillis()         onObjectRetainedListeners.forEach { it.onObjectRetained() }     } }   可以看到这里面会再次执行removeWeaklyReachableObjects方法，将引用队列中的引用对象从监听列表watchedObjects中移除，对于没有被移除的对象，则说明该引用对象未被添加到引用队列，即该引用对象可能存在内存泄漏的风险。最后如果有有内存泄露的引用对象，则遍历执行回调OnObjectRetainedListener的onObjectRetained方法。而onObjectRetained方法在哪实现的呢 ？  我们回到前面InternalAppWatcher.install初始化时  // InternalAppWatcher.kt init {     val internalLeakCanary = try {         val leakCanaryListener = Class.forName(\"leakcanary.internal.InternalLeakCanary\")         leakCanaryListener.getDeclaredField(\"INSTANCE\")         .get(null)     } catch (ignored: Throwable) {         NoLeakCanary     }     @kotlin.Suppress(\"UNCHECKED_CAST\")     onAppWatcherInstalled = internalLeakCanary as (Application) -&gt; Unit } fun install(application: Application) {     checkMainThread()     if (this::application.isInitialized) {         return     }     SharkLog.logger = DefaultCanaryLog()     InternalAppWatcher.application = application      val configProvider = { AppWatcher.config }     ActivityDestroyWatcher.install(application, objectWatcher, configProvider)     FragmentDestroyWatcher.install(application, objectWatcher, configProvider)     onAppWatcherInstalled(application) }   通过调用install方法，对应的调用了onAppWatcherInstalled方法，进而调用了leakcanary.internal.InternalLeakCanary类的invoke方法来完成注册监听，其中该类通过反射拿到InternalLeakCanary.INSTANCE单例对象，这个类位于另一个包leakcanary-android-core下：  // InternalLeakCanary.kt internal object InternalLeakCanary : (Application) -&gt; Unit, OnObjectRetainedListener {     ...     override fun invoke(application: Application) {         _application = application          checkRunningInDebuggableBuild() \t\t// 注册监听         AppWatcher.objectWatcher.addOnObjectRetainedListener(this) \t\t// 创建AndroidHeapDumper对象，用于虚拟机dump hprof产生内存快照文件         val heapDumper = AndroidHeapDumper(application, createLeakDirectoryProvider(application)) \t\t// 用来触发GC         val gcTrigger = GcTrigger.Default          val configProvider = { LeakCanary.config } \t\t// 创建子线程及对应looper         val handlerThread = HandlerThread(LEAK_CANARY_THREAD_NAME)         handlerThread.start()         val backgroundHandler = Handler(handlerThread.looper)          // 创建HeapDumpTrigger对象，调用dumpHeap方法来创建hprof文件         heapDumpTrigger = HeapDumpTrigger(             application, backgroundHandler, AppWatcher.objectWatcher, gcTrigger, heapDumper,             configProvider         )         // 注册应用可见监听         application.registerVisibilityListener { applicationVisible -&gt;                                                 this.applicationVisible = applicationVisible                                                 heapDumpTrigger.onApplicationVisibilityChanged(applicationVisible)                                                }         registerResumedActivityListener(application)         addDynamicShortcut(application)          disableDumpHeapInTests()     }     override fun onObjectRetained() {         if (this::heapDumpTrigger.isInitialized) {             heapDumpTrigger.onObjectRetained()         }     } }   而前面执行回调OnObjectRetainedListener的onObjectRetained方法，就是在这里被调用的，它会调用HeapDumpTrigger.onObjectRetained()方法：  // HeapDumpTrigger.kt fun onObjectRetained() {     scheduleRetainedObjectCheck(         reason = \"found new object retained\",         rescheduling = false     ) }  private fun scheduleRetainedObjectCheck(     reason: String,     rescheduling: Boolean,     delayMillis: Long = 0L ) {     val checkCurrentlyScheduledAt = checkScheduledAt     if (checkCurrentlyScheduledAt &gt; 0) {         val scheduledIn = checkCurrentlyScheduledAt - SystemClock.uptimeMillis()         SharkLog.d { \"Ignoring request to check for retained objects ($reason), already scheduled in ${scheduledIn}ms\" }         return     } else {         val verb = if (rescheduling) \"Rescheduling\" else \"Scheduling\"         val delay = if (delayMillis &gt; 0) \" in ${delayMillis}ms\" else \"\"         SharkLog.d { \"$verb check for retained objects${delay} because $reason\" }     }     checkScheduledAt = SystemClock.uptimeMillis() + delayMillis     backgroundHandler.postDelayed({         checkScheduledAt = 0         checkRetainedObjects(reason)     }, delayMillis) }  private fun checkRetainedObjects(reason: String) {     val config = configProvider()     // A tick will be rescheduled when this is turned back on.     if (!config.dumpHeap) {         SharkLog.d { \"Ignoring check for retained objects scheduled because $reason: LeakCanary.Config.dumpHeap is false\" }         return     } \t// 记录未回收对象的数量     var retainedReferenceCount = objectWatcher.retainedObjectCount      if (retainedReferenceCount &gt; 0) {         // 主动触发GC         gcTrigger.runGc()         // 重新更新未回收对象的数量         retainedReferenceCount = objectWatcher.retainedObjectCount     } \t// 如果未回收对象个数未达到阈值5个，就返回     if (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) return      if (!config.dumpHeapWhenDebugging &amp;&amp; DebuggerControl.isDebuggerAttached) {         onRetainInstanceListener.onEvent(DebuggerIsAttached)         showRetainedCountNotification(             objectCount = retainedReferenceCount,             contentText = application.getString(                 R.string.leak_canary_notification_retained_debugger_attached             )         )         scheduleRetainedObjectCheck(             reason = \"debugger is attached\",             rescheduling = true,             delayMillis = WAIT_FOR_DEBUG_MILLIS         )         return     }      val now = SystemClock.uptimeMillis()     val elapsedSinceLastDumpMillis = now - lastHeapDumpUptimeMillis     if (elapsedSinceLastDumpMillis &lt; WAIT_BETWEEN_HEAP_DUMPS_MILLIS) {         onRetainInstanceListener.onEvent(DumpHappenedRecently)         showRetainedCountNotification(             objectCount = retainedReferenceCount,             contentText = application.getString(R.string.leak_canary_notification_retained_dump_wait)         )         // 60s内执行一次         scheduleRetainedObjectCheck(             reason = \"previous heap dump was ${elapsedSinceLastDumpMillis}ms ago (&lt; ${WAIT_BETWEEN_HEAP_DUMPS_MILLIS}ms)\",             rescheduling = true,             delayMillis = WAIT_BETWEEN_HEAP_DUMPS_MILLIS - elapsedSinceLastDumpMillis         )         return     }      SharkLog.d { \"Check for retained objects found $retainedReferenceCount objects, dumping the heap\" }     dismissRetainedCountNotification()     // 获取内存快照     dumpHeap(retainedReferenceCount, retry = true) }  private fun dumpHeap(     retainedReferenceCount: Int,     retry: Boolean   ) { \t...     // 获取当前内存快照文件hprof     val heapDumpFile = heapDumper.dumpHeap()     // 获取失败处理     if (heapDumpFile == null) {       if (retry) {         SharkLog.d { \"Failed to dump heap, will retry in $WAIT_AFTER_DUMP_FAILED_MILLIS ms\" }         scheduleRetainedObjectCheck(             reason = \"failed to dump heap\",             rescheduling = true,             delayMillis = WAIT_AFTER_DUMP_FAILED_MILLIS         )       } else {         SharkLog.d { \"Failed to dump heap, will not automatically retry\" }       }       showRetainedCountNotification(           objectCount = retainedReferenceCount,           contentText = application.getString(               R.string.leak_canary_notification_retained_dump_failed           )       )       return     }     lastDisplayedRetainedObjectCount = 0     lastHeapDumpUptimeMillis = SystemClock.uptimeMillis()     // 清理注册的监听     objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)     // 开启服务分析hprof文件，即解析生成报告     HeapAnalyzerService.runAnalysis(application, heapDumpFile)   }   经过一系列调用，最后会执行到checkRetainedObjects方法，在该方法中先记录未回收对象的数量，然后主动GC一次，并更新该数量，如果未超过阈值5个就返回，否则就每隔60s执行一次，并通过dumpHeap获取内存快照。该方法内会调用AndroidHeapDumper的dumpHeap方法  // AndroidHeapDumper.kt override fun dumpHeap(): File? {     val heapDumpFile = leakDirectoryProvider.newHeapDumpFile() ?: return null      val waitingForToast = FutureResult&lt;Toast?&gt;()     showToast(waitingForToast)      if (!waitingForToast.wait(5, SECONDS)) {         SharkLog.d { \"Did not dump heap, too much time waiting for Toast.\" }         return null     }      val notificationManager =     context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager     if (Notifications.canShowNotification) {         val dumpingHeap = context.getString(R.string.leak_canary_notification_dumping)         val builder = Notification.Builder(context)         .setContentTitle(dumpingHeap)         val notification = Notifications.buildNotification(context, builder, LEAKCANARY_LOW)         notificationManager.notify(R.id.leak_canary_notification_dumping_heap, notification)     }      val toast = waitingForToast.get()      return try {         // 写入数据         Debug.dumpHprofData(heapDumpFile.absolutePath)         if (heapDumpFile.length() == 0L) {             SharkLog.d { \"Dumped heap file is 0 byte length\" }             null         } else {             heapDumpFile         }     } catch (e: Exception) {         SharkLog.d(e) { \"Could not dump heap\" }         // Abort heap dump         null     } finally {         cancelToast(toast)         notificationManager.cancel(R.id.leak_canary_notification_dumping_heap)     } }   在该方法内会调用leakDirectoryProvider的newHeapDumpFile方法生成hprof文件：  // LeakDirectoryProvider.kt fun newHeapDumpFile(): File? {     cleanupOldHeapDumps()      var storageDirectory = externalStorageDirectory()     if (!directoryWritableAfterMkdirs(storageDirectory)) {         if (!hasStoragePermission()) {             if (requestExternalStoragePermission()) {                 SharkLog.d { \"WRITE_EXTERNAL_STORAGE permission not granted, requesting\" }                 requestWritePermissionNotification()             } else {                 SharkLog.d { \"WRITE_EXTERNAL_STORAGE permission not granted, ignoring\" }             }         } else {             val state = Environment.getExternalStorageState()             if (Environment.MEDIA_MOUNTED != state) {                 SharkLog.d { \"External storage not mounted, state: $state\" }             } else {                 SharkLog.d {                     \"Could not create heap dump directory in external storage: [${storageDirectory.absolutePath}]\"                 }             }         }         // Fallback to app storage.         storageDirectory = appStorageDirectory()         if (!directoryWritableAfterMkdirs(storageDirectory)) {             SharkLog.d {                 \"Could not create heap dump directory in app storage: [${storageDirectory.absolutePath}]\"             }             return null         }     }      val fileName = SimpleDateFormat(\"yyyy-MM-dd_HH-mm-ss_SSS'.hprof'\", Locale.US).format(Date())     // 创建hprof文件     return File(storageDirectory, fileName) }   紧接着我们看下hprof文件解析：  // HeapAnalyzerService.kt internal class HeapAnalyzerService : ForegroundService(     HeapAnalyzerService::class.java.simpleName,     R.string.leak_canary_notification_analysing,     R.id.leak_canary_notification_analyzing_heap ), OnAnalysisProgressListener {      override fun onHandleIntentInForeground(intent: Intent?) {         if (intent == null || !intent.hasExtra(HEAPDUMP_FILE_EXTRA)) {             SharkLog.d { \"HeapAnalyzerService received a null or empty intent, ignoring.\" }             return         }          // Since we're running in the main process we should be careful not to impact it.         Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)         // 获取到hprof文件         val heapDumpFile = intent.getSerializableExtra(HEAPDUMP_FILE_EXTRA) as File          val config = LeakCanary.config         val heapAnalysis = if (heapDumpFile.exists()) {             // 解析hprof文件             analyzeHeap(heapDumpFile, config)         } else {             missingFileFailure(heapDumpFile)         }         onAnalysisProgress(REPORTING_HEAP_ANALYSIS)         // 解析完成回调         config.onHeapAnalyzedListener.onHeapAnalyzed(heapAnalysis)     }      private fun analyzeHeap(         heapDumpFile: File,         config: Config     ): HeapAnalysis {         val heapAnalyzer = HeapAnalyzer(this)          val proguardMappingReader = try {             ProguardMappingReader(assets.open(PROGUARD_MAPPING_FILE_NAME))         } catch (e: IOException) {             null         }         return heapAnalyzer.analyze(             heapDumpFile = heapDumpFile,             leakingObjectFinder = config.leakingObjectFinder,             referenceMatchers = config.referenceMatchers,             computeRetainedHeapSize = config.computeRetainedHeapSize,             objectInspectors = config.objectInspectors,             metadataExtractor = config.metadataExtractor,             proguardMapping = proguardMappingReader?.readProguardMapping()         )     }      private fun missingFileFailure(heapDumpFile: File): HeapAnalysisFailure {         val deletedReason = LeakDirectoryProvider.hprofDeleteReason(heapDumpFile)         val exception = IllegalStateException(             \"Hprof file $heapDumpFile missing, deleted because: $deletedReason\"         )         return HeapAnalysisFailure(             heapDumpFile = heapDumpFile,             createdAtTimeMillis = System.currentTimeMillis(),             analysisDurationMillis = 0,             exception = HeapAnalysisException(exception)         )     }      override fun onAnalysisProgress(step: OnAnalysisProgressListener.Step) {         val percent =         (100f * step.ordinal / OnAnalysisProgressListener.Step.values().size).toInt()         SharkLog.d { \"Analysis in progress, working on: ${step.name}\" }         val lowercase = step.name.replace(\"_\", \" \")         .toLowerCase(Locale.US)         val message = lowercase.substring(0, 1).toUpperCase(Locale.US) + lowercase.substring(1)         showForegroundNotification(100, percent, false, message)     }      companion object {         private const val HEAPDUMP_FILE_EXTRA = \"HEAPDUMP_FILE_EXTRA\"         private const val PROGUARD_MAPPING_FILE_NAME = \"leakCanaryObfuscationMapping.txt\"          fun runAnalysis(             context: Context,             heapDumpFile: File         ) {             val intent = Intent(context, HeapAnalyzerService::class.java)             intent.putExtra(HEAPDUMP_FILE_EXTRA, heapDumpFile)             startForegroundService(context, intent)         }          private fun startForegroundService(             context: Context,             intent: Intent         ) {             if (SDK_INT &gt;= 26) {                 context.startForegroundService(intent)             } else {                 // Pre-O behavior.                 context.startService(intent)             }         }     } }   它启动了一个前台服务，该服务继承自ForegroundService，而ForegroundService又继承自IntentService:  // ForegroundService.kt internal abstract class ForegroundService(   name: String,   private val notificationContentTitleResId: Int,   private val notificationId: Int ) : IntentService(name) {    override fun onCreate() {     super.onCreate()     showForegroundNotification(         max = 100, progress = 0, indeterminate = true,         contentText = getString(R.string.leak_canary_notification_foreground_text)     )   }    protected fun showForegroundNotification(     max: Int,     progress: Int,     indeterminate: Boolean,     contentText: String   ) {     val builder = Notification.Builder(this)         .setContentTitle(getString(notificationContentTitleResId))         .setContentText(contentText)         .setProgress(max, progress, indeterminate)     val notification =       Notifications.buildNotification(this, builder, LEAKCANARY_LOW)     startForeground(notificationId, notification)   }    override fun onHandleIntent(intent: Intent?) {     onHandleIntentInForeground(intent)   }    protected abstract fun onHandleIntentInForeground(intent: Intent?)    override fun onDestroy() {     super.onDestroy()     stopForeground(true)   }    override fun onBind(intent: Intent): IBinder? {     return null   } }   IntentService内部会初始化一个HandlerThread，即带有looper的线程，在服务启动时，会发送一个消息到与该线程关联的handler，并调用onHandleIntent方法，所以该方法也执行在子线程，进而又调用到HeapAnalyzerService的onHandleIntentInForeground方法，执行analyzeHeap方法解析文件，在该方法内部创建一个HeapAnalyzer对象，通过调用其analyze方法完成解析：  // HeapAnalyzer.kt fun analyze(     heapDumpFile: File,     leakingObjectFinder: LeakingObjectFinder,     referenceMatchers: List&lt;ReferenceMatcher&gt; = emptyList(),     computeRetainedHeapSize: Boolean = false,     objectInspectors: List&lt;ObjectInspector&gt; = emptyList(),     metadataExtractor: MetadataExtractor = MetadataExtractor.NO_OP,     proguardMapping: ProguardMapping? = null ): HeapAnalysis {     val analysisStartNanoTime = System.nanoTime()      if (!heapDumpFile.exists()) {         val exception = IllegalArgumentException(\"File does not exist: $heapDumpFile\")         return HeapAnalysisFailure(             heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),             HeapAnalysisException(exception)         )     }      return try {         listener.onAnalysisProgress(PARSING_HEAP_DUMP)         Hprof.open(heapDumpFile)         .use { hprof -&gt;               // 从文件中解析获取对象关系图结构graph并获取图中的所有GC roots根节点               val graph = HprofHeapGraph.indexHprof(hprof, proguardMapping)               val helpers =               FindLeakInput(graph, referenceMatchers, computeRetainedHeapSize, objectInspectors)               // 查找内存泄漏对象               helpers.analyzeGraph(                   metadataExtractor, leakingObjectFinder, heapDumpFile, analysisStartNanoTime               )              }     } catch (exception: Throwable) {         HeapAnalysisFailure(             heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),             HeapAnalysisException(exception)         )     } }  private fun FindLeakInput.analyzeGraph(     metadataExtractor: MetadataExtractor,     leakingObjectFinder: LeakingObjectFinder,     heapDumpFile: File,     analysisStartNanoTime: Long ): HeapAnalysisSuccess {     listener.onAnalysisProgress(EXTRACTING_METADATA)     val metadata = metadataExtractor.extractMetadata(graph)      listener.onAnalysisProgress(FINDING_RETAINED_OBJECTS)     // 通过过滤graph中的KeyedWeakReference类型对象来找到对应的内存泄漏对象     val leakingObjectIds = leakingObjectFinder.findLeakingObjectIds(graph)      val (applicationLeaks, libraryLeaks) = findLeaks(leakingObjectIds)      return HeapAnalysisSuccess(         heapDumpFile = heapDumpFile,         createdAtTimeMillis = System.currentTimeMillis(),         analysisDurationMillis = since(analysisStartNanoTime),         metadata = metadata,         applicationLeaks = applicationLeaks,         libraryLeaks = libraryLeaks     ) }   在该方法实现了解析hprof文件找到内存泄漏对象，并计算对象到GC roots的最短路径，输出报告。  上面通过调用KeyedWeakReferenceFinder的findLeakingObjectIds方法过滤出泄露对象，再通过findLeaks方法计算到GC Roots的路径：  // HeapAnalyzer.kt private fun FindLeakInput.findLeaks(leakingObjectIds: Set&lt;Long&gt;): Pair&lt;List&lt;ApplicationLeak&gt;, List&lt;LibraryLeak&gt;&gt; {     val pathFinder = PathFinder(graph, listener, referenceMatchers)     // 计算并获取目标对象到GC roots的最短路径     val pathFindingResults =     pathFinder.findPathsFromGcRoots(leakingObjectIds, computeRetainedHeapSize)      SharkLog.d { \"Found ${leakingObjectIds.size} retained objects\" } \t// 将这些内存泄漏对象的最短路径合并成树结构返回     return buildLeakTraces(pathFindingResults) }   最后通过可视化界面将hprof分析结果HeapAnalysisSuccess展示出来。  而解析完成的回调方法是onHeapAnalyzedListener.onHeapAnalyzed，它的默认实现类是DefaultOnHeapAnalyzedListener，源码如下：  // DefaultOnHeapAnalyzedListener.kt override fun onHeapAnalyzed(heapAnalysis: HeapAnalysis) {     SharkLog.d { \"$heapAnalysis\" }      val id = LeaksDbHelper(application).writableDatabase.use { db -&gt;         HeapAnalysisTable.insert(db, heapAnalysis)                                                              }      val (contentTitle, screenToShow) = when (heapAnalysis) {         is HeapAnalysisFailure -&gt; application.getString(             R.string.leak_canary_analysis_failed         ) to HeapAnalysisFailureScreen(id)             is HeapAnalysisSuccess -&gt; {             val retainedObjectCount = heapAnalysis.allLeaks.sumBy { it.leakTraces.size }             val leakTypeCount = heapAnalysis.applicationLeaks.size + heapAnalysis.libraryLeaks.size                 application.getString(                 R.string.leak_canary_analysis_success_notification, retainedObjectCount, leakTypeCount             ) to HeapDumpScreen(id)         }     }      if (InternalLeakCanary.formFactor == TV) {         // toast展示         showToast(heapAnalysis)             printIntentInfo()     } else {         // 通知展示         showNotification(screenToShow, contentTitle)     } }   总结  首先注册监听Activity的生命周期onDestory，然后在onDestory方法中，通过ObjectWatcher来watch该Activity,在该方法中，创建带有标识的KeyedWeakReference对象，并关联ReferenceQueue，并存在监控集合Map中，延时5秒来检查目标对象是否回收，如果有未回收的对象则主动触发GC，并每60s检查一次，满足5个阈值，就开始dump heap获取内存快照文件，并解析该文件，找到内存泄露对象，然后计算该对象到GC Roots的最短路径，合并所有路径为树结构返回，最后以可视化的方式展示界面。"
  },
  
  {
    "title": "Android三方开源库之BlockCanary源码分析",
    "url": "/posts/android-blockcanary/",
    "categories": "Android",
    "tags": "源码分析",
    "date": "2020-03-05 00:00:00 +0800",
    "content": "我们手机屏幕帧率通常是60，也就意味着每秒钟有60个画面出现，即16.6ms就要有一个画面渲染出来，Android系统每隔16.6ms发出一个Vsync信号，触发对View进行渲染，如果在这个时间内渲染成功，那么画面正常显示，否则就会出现丢帧的情况，如果掉帧频率很高，也就导致了卡顿。  我们回顾一下View刷新机制，App启动时，会通过ActivityThread类的main方法，创建一个主线程Looper，并通过Looper.loop方法不断轮询，从MessageQueue队列中取出Message来更新UI，而UI更新往往会通过ViewRootImpl类的scheduleTraversals方法来进行一次View树的遍历绘制，最终通过Choreographer的postCallback将该绘制任务添加到待执行队列里面，由主线程looper的loop方法不断取出消息执行任务。  // Looper.java  public static void loop() {     final Looper me = myLooper();     ...     // 获取当前Looper的消息队列     final MessageQueue queue = me.mQueue;     ...     for (; ; ) {         // 取出一个消息         Message msg = queue.next(); // might block         ...         // \"此mLogging可通过Looper.getMainLooper().setMessageLogging方法设置自定义\"         final Printer logging = me.mLogging;         if (logging != null) {// 消息处理前             // \"若mLogging不为null，则此处可回调到该类的println方法\"             logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" +                                 msg.callback + \": \" + msg.what);         }          ...         try {            // 消息处理            msg.target.dispatchMessage(msg);            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;         } finally {            if (traceTag != 0) {                Trace.traceEnd(traceTag);            }         }         ...          if (logging != null) {// 消息处理后             // \"消息处理后，也可调用logging的println方法\"             logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback);         }         ...     } }    通过上面方法可以看出，最终的消息处理发生在dispatchMessage方法中，所以对于设置一个Printer可以记录该方法的耗时。那么其实BlockCanary原理其实也是这样，通过自定义Printer来实现println方法，然后在println方法中监控是否有卡顿发生，从上面也可以发现，logging.println成对出现在消息处理方法的前后，那么就可以通过在自定义的pringln方法中定义标识来分辨消息前后，并计算时间差与我们自己设置的阈值进行对比，从而判断卡顿是否发生。  源码分析  BlockCanary通过install方法完成初始化，并执行start方法:  // BlockCanary.java  public static BlockCanary install(Context context, BlockCanaryContext blockCanaryContext) {     // 根据用户配置参数进行初始化     BlockCanaryContext.init(context, blockCanaryContext);     // 开启配置用户消息栏     setEnabled(context, DisplayActivity.class, BlockCanaryContext.get().displayNotification());     return get(); }   上面方法中先根据用户继承的BlockCanaryContext，配置参数初始化，然后开启消息栏，最后通过get方法返回一个BlockCanary单例对象。  在BlockCanary构造方法中：  // BlockCanary.java private BlockCanary() {     BlockCanaryInternals.setContext(BlockCanaryContext.get());     mBlockCanaryCore = BlockCanaryInternals.getInstance();     mBlockCanaryCore.addBlockInterceptor(BlockCanaryContext.get());     if (!BlockCanaryContext.get().displayNotification()) {         return;     }     mBlockCanaryCore.addBlockInterceptor(new DisplayService()); }   上面代码先是初始化blockCanaryInternals调度类，然后为该类添加拦截器责任链，当用户开启消息栏通知，就在卡顿发生时通过DisplayService发送通知栏消息。  紧接着我们看下这个调度类的构造方法：  // BlockCanaryInternals.java public BlockCanaryInternals() {     // 初始化栈采集器     stackSampler = new StackSampler(         Looper.getMainLooper().getThread(),         sContext.provideDumpInterval()); \t// 实例化CPU采集器     cpuSampler = new CpuSampler(sContext.provideDumpInterval());      // 设置LooperMonitor，并实现onBlockEvent回调，在触发阈值时执行     setMonitor(new LooperMonitor(new LooperMonitor.BlockListener() {          @Override         public void onBlockEvent(long realTimeStart, long realTimeEnd,                                  long threadTimeStart, long threadTimeEnd) {             // Get recent thread-stack entries and cpu usage             ArrayList&lt;String&gt; threadStackEntries = stackSampler                 .getThreadStackEntries(realTimeStart, realTimeEnd);             if (!threadStackEntries.isEmpty()) {                 BlockInfo blockInfo = BlockInfo.newInstance()                     .setMainThreadTimeCost(realTimeStart, realTimeEnd, threadTimeStart, threadTimeEnd)                     .setCpuBusyFlag(cpuSampler.isCpuBusy(realTimeStart, realTimeEnd))                     .setRecentCpuRate(cpuSampler.getCpuRateInfo())                     .setThreadStackEntries(threadStackEntries)                     .flushString();                 LogWriter.save(blockInfo.toString());                  if (mInterceptorChain.size() != 0) {                     for (BlockInterceptor interceptor : mInterceptorChain) {                         interceptor.onBlock(getContext().provideContext(), blockInfo);                     }                 }             }         }     }, getContext().provideBlockThreshold(), getContext().stopWhenDebugging()));      LogWriter.cleanObsolete(); }    在该构造函数中进行一系列的初始化操作，初始化栈采集器，初始化CPU采集器，初始化LooperMonitor，当准备工作完成后，就执行BlockCanary的start方法：  // BlockCanary.java public void start() {     if (!mMonitorStarted) {         mMonitorStarted = true;         Looper.getMainLooper().setMessageLogging(mBlockCanaryCore.monitor);     } }   在这里设置了主线程Looper的setMessageLogging方法，参数monitor就是上面创建的LooperMonitor实例。  也就是我们前面介绍的自定义Printer：  class LooperMonitor implements Printer {     ...     @Override     public void println(String x) {         if (mStopWhenDebugging &amp;&amp; Debug.isDebuggerConnected()) {             return;         }         if (!mPrintingStarted) {             // 记录开始时间             mStartTimestamp = System.currentTimeMillis();             mStartThreadTimestamp = SystemClock.currentThreadTimeMillis();             mPrintingStarted = true;             // 开始采集栈和CPU信息             startDump();         } else {             // 记录结束时间             final long endTime = System.currentTimeMillis();             mPrintingStarted = false;             // 判断耗时是否超过阈值             if (isBlock(endTime)) {                 notifyBlockEvent(endTime);             }             stopDump();         }     }     private boolean isBlock(long endTime) {         return endTime - mStartTimestamp &gt; mBlockThresholdMillis;     }     private void notifyBlockEvent(final long endTime) {         final long startTime = mStartTimestamp;         final long startThreadTime = mStartThreadTimestamp;         final long endThreadTime = SystemClock.currentThreadTimeMillis();         HandlerThreadFactory.getWriteLogThreadHandler().post(new Runnable() {             @Override             public void run() {                 mBlockListener.onBlockEvent(startTime, endTime, startThreadTime, endThreadTime);             }         });     }          private void startDump() {         if (null != BlockCanaryInternals.getInstance().stackSampler) {             BlockCanaryInternals.getInstance().stackSampler.start();         }          if (null != BlockCanaryInternals.getInstance().cpuSampler) {             BlockCanaryInternals.getInstance().cpuSampler.start();         }     }      private void stopDump() {         if (null != BlockCanaryInternals.getInstance().stackSampler) {             BlockCanaryInternals.getInstance().stackSampler.stop();         }          if (null != BlockCanaryInternals.getInstance().cpuSampler) {             BlockCanaryInternals.getInstance().cpuSampler.stop();         }     }          }   上面代码通过成员变量mPrintingStarted来判断方法处理前和后，根据我们设置的阈值mBlockThresholdMillis来判断是否产生卡顿，该值默认是3s，如果发生卡顿，则进入notifyBlockEvent方法，通过调用HandlerThread内部创建的Handler的post方法，将任务交给子线程来处理。该任务执行的逻辑即是mBlockListener的onBlockEvent方法  // HandlerThreadFactory.java final class HandlerThreadFactory {      private static HandlerThreadWrapper sLoopThread = new HandlerThreadWrapper(\"loop\");     private static HandlerThreadWrapper sWriteLogThread = new HandlerThreadWrapper(\"writer\");      private HandlerThreadFactory() {         throw new InstantiationError(\"Must not instantiate this class\");     }      public static Handler getTimerThreadHandler() {         return sLoopThread.getHandler();     }      public static Handler getWriteLogThreadHandler() {         return sWriteLogThread.getHandler();     }      private static class HandlerThreadWrapper {         private Handler handler = null;          public HandlerThreadWrapper(String threadName) {             HandlerThread handlerThread = new HandlerThread(\"BlockCanary-\" + threadName);             handlerThread.start();             handler = new Handler(handlerThread.getLooper());         }          public Handler getHandler() {             return handler;         }     } }   紧接着在该方法里面，从栈采集器里面获取记录信息，然后构建BlockInfo对象，并将该对象信息写入日志文件。最后遍历拦截器进行通知，如果还有DisplayService，就会发送前台通知。  另外上面开始后会调用startDump方法，该方法会开启采集栈和CPU信息，处理工作分别是由StackSampler和CpuSampler类负责，通过调用start方法开始处理：  // AbstractSampler.java abstract class AbstractSampler {      private static final int DEFAULT_SAMPLE_INTERVAL = 300;      protected AtomicBoolean mShouldSample = new AtomicBoolean(false);     protected long mSampleInterval;      private Runnable mRunnable = new Runnable() {         @Override         public void run() {             doSample(); \t\t\t// 延迟卡顿阈值执行任务             if (mShouldSample.get()) {                 HandlerThreadFactory.getTimerThreadHandler()                         .postDelayed(mRunnable, mSampleInterval);             }         }     };      public AbstractSampler(long sampleInterval) {         if (0 == sampleInterval) {             sampleInterval = DEFAULT_SAMPLE_INTERVAL;         }         mSampleInterval = sampleInterval;     }      public void start() {         if (mShouldSample.get()) {             return;         }         mShouldSample.set(true);         // 移除上一次任务         HandlerThreadFactory.getTimerThreadHandler().removeCallbacks(mRunnable);         // 延迟卡顿阀值*0.8 的时间执行Runnable         HandlerThreadFactory.getTimerThreadHandler().postDelayed(mRunnable,                 BlockCanaryInternals.getInstance().getSampleDelay());     }      public void stop() {         if (!mShouldSample.get()) {             return;         }         mShouldSample.set(false);         HandlerThreadFactory.getTimerThreadHandler().removeCallbacks(mRunnable);     }      abstract void doSample(); }   在start方法中，会延时执行doSample方法，该方法是抽象方法，由StackSampler和CpuSampluer覆写:  // StackSampler.java protected void doSample() {     StringBuilder stringBuilder = new StringBuilder();      for (StackTraceElement stackTraceElement : mCurrentThread.getStackTrace()) {         stringBuilder             .append(stackTraceElement.toString())             .append(BlockInfo.SEPARATOR);     } \t     // 根据LRU算法来移除最早添加进来的数据     synchronized (sStackMap) {         if (sStackMap.size() == mMaxEntryCount &amp;&amp; mMaxEntryCount &gt; 0) {             sStackMap.remove(sStackMap.keySet().iterator().next());         }         // 以当前时间为key，存储堆栈信息         sStackMap.put(System.currentTimeMillis(), stringBuilder.toString());     } }  // CpuSampler.java @Override protected void doSample() {     BufferedReader cpuReader = null;     BufferedReader pidReader = null;      try {         cpuReader = new BufferedReader(new InputStreamReader(             new FileInputStream(\"/proc/stat\")), BUFFER_SIZE);         String cpuRate = cpuReader.readLine();         if (cpuRate == null) {             cpuRate = \"\";         }          if (mPid == 0) {             mPid = android.os.Process.myPid();         }         pidReader = new BufferedReader(new InputStreamReader(             new FileInputStream(\"/proc/\" + mPid + \"/stat\")), BUFFER_SIZE);         String pidCpuRate = pidReader.readLine();         if (pidCpuRate == null) {             pidCpuRate = \"\";         } \t\t// 解析CPU信息         parse(cpuRate, pidCpuRate);     } catch (Throwable throwable) {         Log.e(TAG, \"doSample: \", throwable);     } finally {         try {             if (cpuReader != null) {                 cpuReader.close();             }             if (pidReader != null) {                 pidReader.close();             }         } catch (IOException exception) {             Log.e(TAG, \"doSample: \", exception);         }     } }  // CpuSampler.java private void parse(String cpuRate, String pidCpuRate) {     String[] cpuInfoArray = cpuRate.split(\" \");     if (cpuInfoArray.length &lt; 9) {         return;     }      long user = Long.parseLong(cpuInfoArray[2]);     long nice = Long.parseLong(cpuInfoArray[3]);     long system = Long.parseLong(cpuInfoArray[4]);     long idle = Long.parseLong(cpuInfoArray[5]);     long ioWait = Long.parseLong(cpuInfoArray[6]);     long total = user + nice + system + idle + ioWait         + Long.parseLong(cpuInfoArray[7])         + Long.parseLong(cpuInfoArray[8]);      String[] pidCpuInfoList = pidCpuRate.split(\" \");     if (pidCpuInfoList.length &lt; 17) {         return;     }      long appCpuTime = Long.parseLong(pidCpuInfoList[13])         + Long.parseLong(pidCpuInfoList[14])         + Long.parseLong(pidCpuInfoList[15])         + Long.parseLong(pidCpuInfoList[16]);      if (mTotalLast != 0) {         StringBuilder stringBuilder = new StringBuilder();         long idleTime = idle - mIdleLast;         long totalTime = total - mTotalLast;          stringBuilder             .append(\"cpu:\")             .append((totalTime - idleTime) * 100L / totalTime)             .append(\"% \")             .append(\"app:\")             .append((appCpuTime - mAppCpuTimeLast) * 100L / totalTime)             .append(\"% \")             .append(\"[\")             .append(\"user:\").append((user - mUserLast) * 100L / totalTime)             .append(\"% \")             .append(\"system:\").append((system - mSystemLast) * 100L / totalTime)             .append(\"% \")             .append(\"ioWait:\").append((ioWait - mIoWaitLast) * 100L / totalTime)             .append(\"% ]\");          synchronized (mCpuInfoEntries) {             mCpuInfoEntries.put(System.currentTimeMillis(), stringBuilder.toString());             if (mCpuInfoEntries.size() &gt; MAX_ENTRY_COUNT) {                 for (Map.Entry&lt;Long, String&gt; entry : mCpuInfoEntries.entrySet()) {                     Long key = entry.getKey();                     mCpuInfoEntries.remove(key);                     break;                 }             }         }     }     mUserLast = user;     mSystemLast = system;     mIdleLast = idle;     mIoWaitLast = ioWait;     mTotalLast = total;      mAppCpuTimeLast = appCpuTime; }   综上，可以看出按照固定时间间隔循环执行采集任务，在结束时调用stop方法移除该任务。  总结  最后用一张图总结其工作流程图："
  },
  
  {
    "title": "Android Framework之Binder原理分析",
    "url": "/posts/android-binder/",
    "categories": "Android",
    "tags": "Framework",
    "date": "2019-07-08 00:00:00 +0800",
    "content": "Binder是Android Framework层一个不可或缺的存在，了解Framework的前提必须先掌握Binder原理，它是Android进程间通信的一种方式，我们在应用程序使用的四大组件，可以运行在同一个进程，也可以运行在不同进程，进程之间通信就依赖Binder，另外我们之前了解到的系统服务，像AMS、PMS、WMS等都是基于Binder IPC 进行通信的。  进程空间  Linux系统对于进程空间的划分，主要分为用户空间和内核空间，用户空间（User Space）是用户程序运行的空间，内核空间（Kernel）是系统内核运行的空间。而如果它们之间需要进行交互时就需要通过系统调用的方式，常见的函数有：     copy_from_user()：将用户空间的数据拷贝到内核空间   copy_to_user()：将内核空间的数据拷贝到用户空间   上面当程序执行系统调用进入内核执行时，此时进程就处于内核态，相反在执行自己的代码时，就处于用户态。  进程隔离与传统IPC  操作系统中，进程与进程间的内存是不共享的，即A 进程无法直接访问 B 进程的数据，B进程也无法访问A进程的数据，如果双方要进行通信，就必须采用特殊的通信机制，即IPC，传统的Linux通信原理可以用下面这张图表示：    上面两个进程如果按照传统IPC进程一次通信的话，步骤如下：     数据发送进程通过系统调用copy_from_user将要发送的数据从用户空间拷贝到内核缓存区   数据接收进程同样通过系统调用copy_to_user将内核缓存区中的数据拷贝到用户空间。   这样一来就完成了一次进程间通信。  但是这样的方式有以下问题：     性能低下，一次通信需要拷贝2次数据   接收数据的缓存由接收方提供，但是它却不知道需要多大的缓存空间才能满足要求，因此只能开辟尽可能大的空间或者先调用API接收消息头来获取消息体的大小，不管哪一种，很显然都很浪费空间。   内存映射  内存映射的实现过程主要是通过Linux系统下的系统调用函数：mmap（），该函数可以创建一块虚拟的内存区域，并且将这块内存区域与共享对象之间建立映射关系    这样以来，就会发现不但减少了数据拷贝的次数，也提高了用户空间和内核空间之间的高校交互，而且用内存读写代替了I/O读写，提高文件读取效率。  Binder  通过上面我们知道，跨进程IPC需要内核空间支持，但是Binder并不是Linux系统的一部分，需要实现IPC就必须依赖Linux的动态内核可加载模块（Loadable Kernel Module）,简称LKM，它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 Binder 驱动（Binder Dirver）。  传统的IPC通信需要两次拷贝，但是Android为了提高效率，就借助上面提到的内存映射，即将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。我们看下面这张图：    它的通信过程大体是这样：     首先 Binder 驱动在内核空间创建一个数据接收缓存区；   接着在内核空间开辟一块内核缓存区，建立内核缓存区和内核中Binder建立的数据接收缓存区之间的映射关系，以及内核中Binder建立的数据接收缓存区和数据接收接收进程用户空间的映射关系；   数据发送进程通过系统调用 copy_from_user() 将数据 copy 到内核中的内核缓存区，由于内核缓存区和数据接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了数据接收进程的用户空间，这样便完成了一次进程间的通信。   Android中的Binder通信模型  在Android中，一次完整的进程间通信，通信的双方我们称为客户端进程和服务端进程，由于进程隔离机制，要实现两者通信就需要借助Binder驱动。它是基于C/S 架构，由一系列组件组成，包括Client、Server、ServiceManager、Binder驱动，其中 Client、Server、Service Manager 运行在用户空间，Binder 驱动运行在内核空间。其中 Service Manager 和 Binder 驱动由系统提供，而 Client、Server 由应用程序来实现。Client、Server 和 ServiceManager 均是通过系统调用 open、mmap 和 ioctl 来访问设备文件 /dev/binder，从而实现与 Binder 驱动的交互来间接的实现跨进程通信。    从上面我们大致梳理出Binder的大体过程:     Server进程向Binder驱动发起服务注册请求   Binder驱动将服务注册请求发送给Service Manager进程   Service Manager进程添加该Server进程，即已注册服务   Client进程向Binder驱动发起获取服务的请求，传递获取服务的名称   Binder驱动将请求转发给Service Manager进程   Service Manager进程根据服务名称查找到Client请求的Server对于服务信息   通过Binder驱动将上述服务信息返回给Client进程   Binder驱动为跨进程通信做准备，实现内存映射   Client进程将数据发送到Server进程   Server进程根据Client进程请求要求，调用对应的目标方法   Server进程将目标方法的结果返回给Client进程   代理模式  当Client进程想要获取Server进程的数据对象时，并不是真的会返回对象给Client进程，而是返回一个和目标对象一模一样的代理对象，这个代理对象有着和目标对象一样的方法，当Client进程获取服务请求，调用对应的方法，这时候代理对象会利用Binder驱动找到真的Binder对象，并通知Server进程调用目标方法。并把结果返回给代理对象的Binder驱动，然后转发给Client进程，一次通信就完成了。    综上，Client进程的操作其实是对代理对象的操作，代理对象利用Binder驱动找到真正的Binder实体，然后通知Server进程调用对应的目标方法完成操作。  Android AIDL  我们通过AIDL文件生成的Java文件，包含一个接口，一个Stub静态的抽象类，一个Proxy的静态类，其中Proxy是Stub的静态内部类，Stub又是借口的静态内部类，Android这样设计的目的是为了避免当有多个AIDL文件时，放在同一个文件夹Stub、Proxy会产生重名问题。     IBinder : IBinder 是一个接口，代表了一种跨进程通信的能力。只要实现了这个借口，这个对象就能跨进程传输。   IInterface : IInterface 代表的就是 Server 进程对象具备什么样的能力（能提供哪些方法，其实对应的就是 AIDL 文件中定义的接口）   Binder : Java 层的 Binder 类，代表的其实就是 Binder 本地对象。BinderProxy 类是 Binder 类的一个内部类，它代表远程进程的 Binder 对象的本地代理；这两个类都继承自 IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder 驱动会自动完成这两个对象的转换。   Stub : AIDL 的时候，编译工具会给我们生成一个名为 Stub 的静态内部类；这个类继承了 Binder, 说明它是一个 Binder 本地对象，它实现了 IInterface 接口，表明它具有 Server 承诺给 Client 的能力；Stub 是一个抽象类，具体的 IInterface 的相关实现需要开发者自己实现。   总结  对Binder一个相对完整的解释：  从进程间通信的角度看，Binder 是一种进程间通信的机制；  从 Server 进程的角度看，Binder 指的是 Server 中的 Binder 实体对象；  从 Client 进程的角度看，Binder 指的是对 Binder 代理对象，是 Binder 实体对象的一个远程代理  从传输过程的角度看，Binder 是一个可以跨进程传输的对象；Binder 驱动会对这个跨越进程边界的对象对一点点特殊处理，自动完成代理对象和本地对象之间的转换。  相比其他进程间通信方式来说，它有以下优点：     性能上只需要一次数据拷贝，而Socket需要两次，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。管道、消息队列采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少也需要两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用   安全性上为每个App分配UID/PID，进程的UID/PID是鉴别进程身份的标识，而传统的 IPC 没有任何安全措施，完全依赖上层协议来确保   稳定性上基于C/S架构，职责明确，架构清晰，方便使用"
  },
  
  {
    "title": "Android Framework源码分析之屏幕刷新机制以及Choreographer",
    "url": "/posts/android-framework-choreographer/",
    "categories": "Android",
    "tags": "源码分析, framework",
    "date": "2019-06-18 00:00:00 +0800",
    "content": "生活中，我们经常遇到别人说手机画面卡，这里的卡对应我们开发者来说，表示的就是掉帧（jank）或者画面撕裂（tearing），我们先来说说一些概念：          帧（Frame）：动画中的单幅画面，相当于电影胶片中的一个镜头，一帧就是一幅静止的画面，连续帧动起来就是我们看到的动画。           帧率（Frame Rate）：每秒传输的图片画面的帧数，也可以理解为画面每秒钟刷新几次，通常用FPS（Frames Per Second）表示           刷新率（Refresh Rate）: 每秒屏幕刷新次数，这取决去硬件固定参数，常用Hz表示。           掉帧（jank）: 一个帧在屏幕上连续出现2次，看起来就像画面静止了一样。           撕裂（tearing）：一个画面的数据来自2个不同的帧，导致画面出现错误。            我们都知道一个图形显示系统，往往涉及的这三部分：CPU、GPU、屏幕Display。它们的作用分别是：     CPU擅长复杂的逻辑运算，用作计算数据和信息处理，然后交给GPU   GPU擅长数学计算，用作图形处理绘制，然后存储到缓存区   屏幕Display用于显示从缓存区读取出来的数据   每一帧都重复上面的这个过程，然后1秒钟如果重复60次，每个过程所花费的时间就是16.6ms，也就是Android中常说的每隔16.6ms刷新一次屏幕。  首先我们看看画面撕裂原因，屏幕显示画面并不是一下子把整个图像完整的显示出来，这里有一个词叫逐行扫描，就是一行一行显示，只不过显示过快，我们肉眼看不出来而已。前面说如果屏幕Display要从缓存区buffer取的数据在屏幕逐行读取数据过程中发生变化了，就有可能读取到下一帧的画面数据，导致出现错误。这种情况一般是因为显卡输出帧的速率高于屏幕显示器的刷新速率导致显示器并不能及时处理输出的帧，而最终出现了多个帧的画面都留在了显示器上的问题  同样，如果掉帧， 即图像绘制的速度低于屏幕显示器的刷新速率，就会出现卡顿，即下一帧要显示了，可是图像数据还没准备好，就只能仍然显示上一帧的数据。  垂直同步信号Vsync  一般为了解决这个问题，显示系统通常会引入垂直同步信号（Vsync）的概念：通俗点讲就是讲GPU的速率限制和屏幕Display的FPS一样。  系统会在屏幕Display绘制完一帧之后发送一个垂直同步信号（Vsync），然后CPU和GPU就准备下一帧的内容，等待屏幕Display下一帧绘制完，又会发送一个垂直同步信号（Vsync）。如此反复，这样就保证了GPU的工作效率和屏幕Display保持同步，我们先来看下没有Vsync的情况：    这个图中有三个元素，Display 是显示屏幕，GPU 和 CPU 负责渲染帧数据，每个帧以方框表示，并以数字进行编号，如0、1、2等等     Display显示第0帧数据，此时CPU和GPU渲染第1帧画面，而且赶在Display显示下一帧前完成。   因为渲染及时，Display在第0帧显示完成后，也就是第1个VSync后，正常显示第1帧。   由于某些原因，比如CPU资源被占用，系统没有及时地开始处理第2帧，直到第2个VSync快来前才开始处理   第2个VSync来时，由于第2帧数据还没有准备就绪，显示的还是第1帧。   当第2帧数据准备完成后，它并不会马上被显示，而是要等待下一个VSync的到来。   我们可以从图中看出，是因为新的一帧开始的时候，CPU 在处理其他任务，并没有马上执行下一帧的任务，而等第2帧的数据准备好后，并不能马上显示需要等第3个Vsync信号到来才可以显示，这样第2个Vsync到来只能仍然显示第1帧的画面。所以我们看下引入Vsync后的情况：    引入了Vsync后，一旦VSync到来，立刻就开始执行下一帧的绘制工作，这样就可以大大降低Jank出现的概率。另外，Vsync引入后，要求绘制也只能在收到Vsync消息之后才能进行，因此，也就杜绝了另外一种极端情况的出现:CPU（GPU）一直不停的进行绘制，帧的生成速度高于屏幕的刷新速度，导致生成的帧不能被显示，只能丢弃，这样就出现了丢帧的情况，这样引入Vsync后，绘制的速度就和屏幕刷新的速度保持一致了。  我们现在Android设备主流的刷新率还在60Hz，即每一帧最多需要1/60=16.6ms要准备完成。如果CPU/GPU性能差一些，达不到这个要求会出现什么情况？  双缓冲  主要是两个缓冲区组成，缓存区backBuffer用于CPU/GPU图形处理 ，缓存区frameBuffer用于显示器显示，这样分工明确之后，屏幕只会读取framebuffer的内容，是一帧完整的画面。而CPU/GPU计算的新一帧内容会放到backbuffer中，不会影响到framebuffer的内容。  只有当屏幕绘制完一帧内容之后，才会将CPU/GPU计算好的新一帧内容也就是backbuffer内容和framebuffer进行交换，这一过程也叫Swap。所以当屏幕显示完第1帧画面后，系统发生Vsync信号，接着三个步骤：     交换两个缓存区（framebuffer、backbuffer）数据内容。   显示器开始显示第2帧内容，也就是交换后的framebuffer内容。   CPU/GPU开始计算处理第三帧的内容，并在处理好内容后放到backbuffer中。   下面A和B分别代表两个缓冲区，它们不断地交换来正确显示画面。    而这时问题其实还没有解决，正如前面所说，如果 CPU/GPU性能不好，其帧率小于 Display 的帧率，就会出现下面的情况：    当CPU/GPU的处理时间超过16.6ms时，第一个VSync到来时，缓冲区B中的数据还没有准备好，于是只能继续显示之前A缓冲区中的内容。而B完成后，又因为这时候没有VSync信号到来，所以它只能等待下一个信号的来临。于是在这一过程中，有一大段时间是被浪费的。当下一个VSync出现时，CPU/GPU马上执行操作，此时它可操作的buffer是A，相应的显示屏对应的就是B。这时看起来就是正常的。只不过由于执行时间仍然超过16ms，导致下一次应该执行的缓冲区交换又被推迟了——如此循环反复，便出现了越来越多的“Jank”，即我们所说的卡顿。很显然，第一次的Jank看起来是没有办法的，除非升级硬件配置来加快FPS。但是后面其他的Jank，我们其实有办法可以减少的，仔细分析原因，会发现主要是由于当前已经没有可用的buffer了，因为 A Buffer 被 Display 在使用。B Buffer 被 GPU 在使用，而一旦过了 VSync 时间点，CPU 就不能被触发以处理绘制工作了，其实主要就是提高CPU/GPU的利用率。  为了解决这个问题，Android引入了Triple Buffer 机制。  Triple Buffer  它主要由3个缓冲区组成，除了前面介绍的2个缓冲区外，又增加了一个Triple Buffer，即：  1、缓存区backBuffer用于CPU/GPU图形处理  2、缓存区TripleBuffer用于CPU/GPU图形处理  3、缓存区frameBuffer用于屏幕Display显示  前面说的由于在第2个VSync信号来的时候，backBuffer被GPU占用，导致CPU无法去开始新一帧的计算，加入了第3个缓冲区，那么在第2个VSync信号来的时候，CPU就可以利用TripleBuffer开始新一帧的计算，而无视正在被GPU占用的backBuffer。  而三缓存和Vsync垂直同步信号都是Android4.1以后引入的，该项目也被称为黄油计划（Project Butter）    Choreographer（编舞者）  在Android中View 的绘制会经过 Measure、Layout、Draw 这 3 个阶段，而这 3 个阶段的工作都是由 CPU 来负责完成，另外CPU也会负责一些用户输入、动画等事件，这些都是在UI线程完成的。当CPU计算好数据后，会在 RenderThread 线程中将这部分数据提交给 GPU并被缓存到Back Buffer中。GPU 负责对这些数据进行栅格化（Rasterization）操作，完成之后将其交换（swap）到 Frame Buffer 中，最后屏幕从 Frame Buffer 中读取数据显示，实际上真正对 Buffer 中的数据进行合成显示到屏幕上的是 SurfaceFlinger。  Choreographer 的引入，主要是配合 Vsync 为上层消息处理有一个稳定的时机。Vsync 信号到来唤醒 Choreographer 来做 App 的绘制操作 ，如果每个 Vsync 周期应用都能渲染完成，那么画面就会感觉到很流畅。所以它在这里扮演着调度者的角色，一方面负责接收和处理 App 的各种更新消息和回调，等到 Vsync 到来的时候统一处理。比如集中处理 Input(主要是 Input 事件的处理) 、Animation(动画相关)、Traversal(包括 measure、layout、draw 等操作)，另一方面负责请求和接收 Vsync 信号。接收 Vsync 事件回调(通过 FrameDisplayEventReceiver.onVsync )；请求 Vsync(FrameDisplayEventReceiver.scheduleVsync)。  我们先来看下View的invalidate过程，最终都会走到ViewRootImpl的scheduleTraversals方法中：  // ViewRootImpl.java @UnsupportedAppUsage void scheduleTraversals() {     if (!mTraversalScheduled) {         mTraversalScheduled = true;         mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();         mChoreographer.postCallback(             Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);         if (!mUnbufferedInputDispatch) {             scheduleConsumeBatchedInput();         }         notifyRendererOfFramePending();         pokeDrawLockIfNeeded();     } }   在这个方法里我们可以看到mChoreographer.postCallback 方法，这个方法将 TraversalRunnable 以参数的形式传递给 Choreographer  // Choreographer.java public void postCallback(int callbackType, Runnable action, Object token) {     postCallbackDelayed(callbackType, action, token, 0); } public void postCallbackDelayed(int callbackType,                                 Runnable action, Object token, long delayMillis) {     if (action == null) {         throw new IllegalArgumentException(\"action must not be null\");     }     if (callbackType &lt; 0 || callbackType &gt; CALLBACK_LAST) {         throw new IllegalArgumentException(\"callbackType is invalid\");     }      postCallbackDelayedInternal(callbackType, action, token, delayMillis); }  private void postCallbackDelayedInternal(int callbackType,                                          Object action, Object token, long delayMillis) {     if (DEBUG_FRAMES) {         Log.d(TAG, \"PostCallback: type=\" + callbackType               + \", action=\" + action + \", token=\" + token               + \", delayMillis=\" + delayMillis);     }      synchronized (mLock) {         final long now = SystemClock.uptimeMillis();         final long dueTime = now + delayMillis;         // 将Runnable加入到队列中         mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);          if (dueTime &lt;= now) {             // 订阅信号             scheduleFrameLocked(now);         } else {             Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);             msg.arg1 = callbackType;             msg.setAsynchronous(true);             mHandler.sendMessageAtTime(msg, dueTime);         }     } }   经过一系列调用将传入的 TraversalRunnable 插入到一个 CallbackQueue 中。后续当 Choreographer 接收到 vsync 信号时，会将此 TraversalRunnable 从队列中取出执行  另外接着看下sheduleFrameLocked方法：  // Choreographer.java private void scheduleFrameLocked(long now) {     if (!mFrameScheduled) {         mFrameScheduled = true;         if (USE_VSYNC) {             if (DEBUG_FRAMES) {                 Log.d(TAG, \"Scheduling next frame on vsync.\");             }              // If running on the Looper thread, then schedule the vsync immediately,             // otherwise post a message to schedule the vsync from the UI thread             // as soon as possible.             if (isRunningOnLooperThreadLocked()) {                 scheduleVsyncLocked();             } else {                 Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);                 msg.setAsynchronous(true);                 mHandler.sendMessageAtFrontOfQueue(msg);             }         } else {             final long nextFrameTime = Math.max(                 mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);             if (DEBUG_FRAMES) {                 Log.d(TAG, \"Scheduling next frame in \" + (nextFrameTime - now) + \" ms.\");             }             Message msg = mHandler.obtainMessage(MSG_DO_FRAME);             msg.setAsynchronous(true);             mHandler.sendMessageAtTime(msg, nextFrameTime);         }     } }  private void scheduleVsyncLocked() {     mDisplayEventReceiver.scheduleVsync(); }  private final class FrameHandler extends Handler {     public FrameHandler(Looper looper) {         super(looper);     }      @Override     public void handleMessage(Message msg) {         switch (msg.what) {             case MSG_DO_FRAME:                 doFrame(System.nanoTime(), 0);                 break;             case MSG_DO_SCHEDULE_VSYNC:                 doScheduleVsync();                 break;             case MSG_DO_SCHEDULE_CALLBACK:                 doScheduleCallback(msg.arg1);                 break;         }     } }  void doScheduleVsync() {     synchronized (mLock) {         if (mFrameScheduled) {             scheduleVsyncLocked();         }     } }   上面总会执行到scheduleVsyncLocked方法，它会执行FrameDisplayEventReceiver的scheduleVsync方法，FrameDisplayEventReceiver是Choreographer的内部类，继承于DisplayEventReceiver这个抽象类，  即会调用DisplayEventReceiver的scheduleVsync方法：  // DisplayEventReceiver.java public void scheduleVsync() {     if (mReceiverPtr == 0) {         Log.w(TAG, \"Attempted to schedule a vertical sync pulse but the display event \"               + \"receiver has already been disposed.\");     } else {         nativeScheduleVsync(mReceiverPtr);     } }   该方法会调用一个本地方法nativeScheduleVsync来向系统订阅Vsync信号，Android 系统每过 16.6ms 会发送一个 vsync 信号。但这个信号并不是所有 App 都能收到的，只有订阅的才能收到。这样设计的合理之处在于，当 UI 没有变化的时候就不会去调用 nativeScheduleVsync 去订阅，也就不会收到 vsync 信号，减少了不必要的绘制操作。需要注意的是每次订阅只能收到一次 vsync 信号，如果需要收到下次信号需要重新订阅。比如 Animation 的实现就是在订阅一次信号之后，紧接着再次调用 nativeScheduleVsync 方法订阅下次 vsync 信号，因此会不断地刷新 UI。  而Vsync信号的接收，其实也是由FrameDisplayEventReceiver来完成的，它回调了onVsync方法：  // Choreographer#FrameDisplayEventReceiver.java  @Override public void onVsync(long timestampNanos, int builtInDisplayId, int frame) { \t...      // Post the vsync event to the Handler.     // The idea is to prevent incoming vsync events from completely starving     // the message queue.  If there are no messages in the queue with timestamps     // earlier than the frame time, then the vsync event will be processed immediately.     // Otherwise, messages that predate the vsync event will be handled first.     long now = System.nanoTime();     if (timestampNanos &gt; now) {         Log.w(TAG, \"Frame time is \" + ((timestampNanos - now) * 0.000001f)               + \" ms in the future!  Check that graphics HAL is generating vsync \"               + \"timestamps using the correct timebase.\");         timestampNanos = now;     }      if (mHavePendingVsync) {         Log.w(TAG, \"Already have a pending vsync event.  There should only be \"               + \"one at a time.\");     } else {         mHavePendingVsync = true;     }      mTimestampNanos = timestampNanos;     mFrame = frame;     Message msg = Message.obtain(mHandler, this);     msg.setAsynchronous(true);     mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS); }   该方法会将FrameDisplayEventReceiver自身通过异步消息的方式发送到MessageQueue，所以查看其run方法：  @Override public void run() {     mHavePendingVsync = false;     doFrame(mTimestampNanos, mFrame); }   最终调用了Choreographer的doFrame方法，其实也就是在这个方法中将之前插入到 CallbackQueue 中的 Runnable 取出来执行：  // Choreographer.java  void doFrame(long frameTimeNanos, int frame) {     final long startNanos;     synchronized (mLock) {         ...           \t\t// 掉帧逻辑计算         long intendedFrameTimeNanos = frameTimeNanos;         startNanos = System.nanoTime();         final long jitterNanos = startNanos - frameTimeNanos;         if (jitterNanos &gt;= mFrameIntervalNanos) {             final long skippedFrames = jitterNanos / mFrameIntervalNanos;             if (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) {                 Log.i(TAG, \"Skipped \" + skippedFrames + \" frames!  \"                       + \"The application may be doing too much work on its main thread.\");             }             final long lastFrameOffset = jitterNanos % mFrameIntervalNanos;             if (DEBUG_JANK) {                 Log.d(TAG, \"Missed vsync by \" + (jitterNanos * 0.000001f) + \" ms \"                       + \"which is more than the frame interval of \"                       + (mFrameIntervalNanos * 0.000001f) + \" ms!  \"                       + \"Skipping \" + skippedFrames + \" frames and setting frame \"                       + \"time to \" + (lastFrameOffset * 0.000001f) + \" ms in the past.\");             }             frameTimeNanos = startNanos - lastFrameOffset;         }          if (frameTimeNanos &lt; mLastFrameTimeNanos) {             if (DEBUG_JANK) {                 Log.d(TAG, \"Frame time appears to be going backwards.  May be due to a \"                       + \"previously skipped frame.  Waiting for next vsync.\");             }             scheduleVsyncLocked();             return;         }          if (mFPSDivisor &gt; 1) {             long timeSinceVsync = frameTimeNanos - mLastFrameTimeNanos;             if (timeSinceVsync &lt; (mFrameIntervalNanos * mFPSDivisor) &amp;&amp; timeSinceVsync &gt; 0) {                 scheduleVsyncLocked();                 return;             }         }          mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);         mFrameScheduled = false;         mLastFrameTimeNanos = frameTimeNanos;     }      try {         // 执行这一帧做的事情         Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"Choreographer#doFrame\");         AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);          mFrameInfo.markInputHandlingStart();         doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);          mFrameInfo.markAnimationsStart();         doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);          mFrameInfo.markPerformTraversalsStart();         doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);          doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);     } finally {         AnimationUtils.unlockAnimationClock();         Trace.traceEnd(Trace.TRACE_TAG_VIEW);     }      if (DEBUG_FRAMES) {         final long endNanos = System.nanoTime();         Log.d(TAG, \"Frame \" + frame + \": Finished, took \"               + (endNanos - startNanos) * 0.000001f + \" ms, latency \"               + (startNanos - frameTimeNanos) * 0.000001f + \" ms.\");     } }   上面主要完成2部分工作，第一部分是计算掉帧的逻辑，第二部分就是执行我们一帧完成的工作，主要就是前面说的Input(主要是 Input 事件的处理) 、Animation(动画相关)、Traversal(包括 measure、layout、draw 等操作)等工作。  我们看下doCallbacks方法：  // Choreographer.java void doCallbacks(int callbackType, long frameTimeNanos) {     CallbackRecord callbacks;     synchronized (mLock) {         // We use \"now\" to determine when callbacks become due because it's possible         // for earlier processing phases in a frame to post callbacks that should run         // in a following phase, such as an input event that causes an animation to start.         final long now = System.nanoTime();         // 从队列中取出来Runnable         callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(             now / TimeUtils.NANOS_PER_MS);         if (callbacks == null) {             return;         }         mCallbacksRunning = true;          ...     }     try {         Trace.traceBegin(Trace.TRACE_TAG_VIEW, CALLBACK_TRACE_TITLES[callbackType]);         for (CallbackRecord c = callbacks; c != null; c = c.next) {             if (DEBUG_FRAMES) {                 Log.d(TAG, \"RunCallback: type=\" + callbackType                       + \", action=\" + c.action + \", token=\" + c.token                       + \", latencyMillis=\" + (SystemClock.uptimeMillis() - c.dueTime));             }             // 开始执行Runnable             c.run(frameTimeNanos);         }     } finally {         synchronized (mLock) {             mCallbacksRunning = false;             do {                 final CallbackRecord next = callbacks.next;                 recycleCallbackLocked(callbacks);                 callbacks = next;             } while (callbacks != null);         }         Trace.traceEnd(Trace.TRACE_TAG_VIEW);     } }    从上面代码也可以看出前面Choreographer保存到队列中的Runnable，从这里取出来然后被立即执行。  综上，Choreographer起着承上启下的作用：          承上：接收应用层的各种 callback 输入，包括 input、animation、traversal 绘制。但是这些 callback 并不会被立即执行。而是会缓存在 Choreographer 中的 CallbackQueue 中。           启下：内部的 FrameDisplayEventReceiver 负责接收硬件层发送的 vsync 信号。当接收到 vsync 信号之后，会调用 onVsync 方法，进而调用 doFrame方法，最终到 doCallbacks，在 doCallbacks方法 中从 CallbackQueue 中取出先前保存的Runnable，并调用其 run 方法开始执行工作。      另外Choreographer也向外部提供一个 FrameCallback 接口，来监听 doFrame 方法的执行过程。  // Choreographer.java public interface FrameCallback {     public void doFrame(long frameTimeNanos); }   这个接口中的 doFrame 方法会在绘制每一帧时被调用，所以我们可以在 App 层主动向 Choreographer 中添加 Callback，然后通过检测两次 doFrame 方法执行的时间间隔来判断是否发生“丢帧”。  Choreographer.getInstance().postFrameCallback(new Choreographer.FrameCallback() {     long lastFrameTimeNanos = 0;     long currentFrameTimeNanos = 0;      @Override     public void doFrame(long frameTimeNanos) {         Log.i(\"DemoActivity\", \"DoFrame\");         if(lastFrameTimeNanos == 0) {             lastFrameTimeNanos = frameTimeNanos;         }          currentFrameTimeNanos = frameTimeNanos;         long diffMs = TimeUnit.MICROSECONDS.convert(currentFrameTimeNanos - lastFrameTimeNanos, TimeUnit.NANOSECONDS);         if(diffMs &gt; 16.6f){             long droppedFrameCount = (long) (diffMs / 16.6f);             Log.w(\"DemoActivity\", \"发生丢帧\");         }         Choreographer.getInstance().postFrameCallback(this);     } });   这里每一次订阅都只会接收一次 vsync 信号，而我们需要一直监听 doFrame 的回调，因此在方法最后需要递归的执行 postFrameCallback 方法。事实上，市面上很多APM工具都利用了这一特性。  另外还有细节需要注意的就是同步屏障消息。  我们在前面的scheduleTraversals 方法  // ViewRootImpl.java @UnsupportedAppUsage void scheduleTraversals() {     if (!mTraversalScheduled) {         mTraversalScheduled = true;         mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();         mChoreographer.postCallback(             Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);         if (!mUnbufferedInputDispatch) {             scheduleConsumeBatchedInput();         }         notifyRendererOfFramePending();         pokeDrawLockIfNeeded();     } }   可以看到在插入Callback之前执行了postSyncBarrier方法来设置同步屏障。Android中Message类型分为2类，同步消息和异步消息 ，默认情况是同步消息，只有在创建Handler时传入了第二个参数为true时，该handler发送的消息才是异步消息：  // Handler.java public Handler(Callback callback, boolean async) {     if (FIND_POTENTIAL_LEAKS) {         final Class&lt;? extends Handler&gt; klass = getClass();         if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;             (klass.getModifiers() &amp; Modifier.STATIC) == 0) {             Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" +                   klass.getCanonicalName());         }     }      mLooper = Looper.myLooper();     if (mLooper == null) {         throw new RuntimeException(             \"Can't create handler inside thread \" + Thread.currentThread()             + \" that has not called Looper.prepare()\");     }     mQueue = mLooper.mQueue;     mCallback = callback;     mAsynchronous = async; }    还有一种是通过Message方法来设置：  // Message.java public void setAsynchronous(boolean async) {     if (async) {         flags |= FLAG_ASYNCHRONOUS;     } else {         flags &amp;= ~FLAG_ASYNCHRONOUS;     } }   一般情况下，Looper 从 MessageQueue 取消息时对这两者并不会做区别对待。但是如果 MessageQueue 设置了同步屏障就会出现差异。 当 MessageQueue 设置同步屏障之后，在 next 方法获取消息时会忽略所有的同步消息，只取异步消息，也就是说异步消息在此时的优先级更高。而 TraversalRunnable 会被封装到一个异步的 Message 中，因此 View 绘制的一系列操作会被优先执行，这也是提高渲染性能，优化的一种手段。  // MessageQueue.java Message next() {     // Return here if the message loop has already quit and been disposed.     // This can happen if the application tries to restart a looper after quit     // which is not supported.     final long ptr = mPtr;     if (ptr == 0) {         return null;     }      int pendingIdleHandlerCount = -1; // -1 only during first iteration     int nextPollTimeoutMillis = 0;     for (;;) {         if (nextPollTimeoutMillis != 0) {             Binder.flushPendingCommands();         }          nativePollOnce(ptr, nextPollTimeoutMillis);          synchronized (this) {             // Try to retrieve the next message.  Return if found.             final long now = SystemClock.uptimeMillis();             Message prevMsg = null;             Message msg = mMessages;             if (msg != null &amp;&amp; msg.target == null) {                 // Stalled by a barrier.  Find the next asynchronous message in the queue.                 do {                     prevMsg = msg;                     msg = msg.next;                 } while (msg != null &amp;&amp; !msg.isAsynchronous());             }             ...         }         ...     } }    可以看到上面do while循环外面的条件，如果是异步消息就结束循环，取出该Message先处理。"
  },
  
  {
    "title": "Android Framework源码分析之View的绘制流程",
    "url": "/posts/android-framework-view-traverse/",
    "categories": "Android",
    "tags": "源码分析, framework",
    "date": "2019-06-13 00:00:00 +0800",
    "content": "通过分析Activity的启动过程，我们知道，View的绘制开始是从ViewRootImpl类中通过调用setView方法执行了requestLayout后开始的。  requestLayout过程  // ViewRootImpl.java public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) { \t// Schedule the first layout -before- adding to the window     // manager, to make sure we do the relayout before receiving     // any other events from the system.     requestLayout();     if ((mWindowAttributes.inputFeatures          &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {         mInputChannel = new InputChannel();     }     mForceDecorViewVisibility = (mWindowAttributes.privateFlags                                  &amp; PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY) != 0;     try {         mOrigWindowType = mWindowAttributes.type;         mAttachInfo.mRecomputeGlobalAttributes = true;         collectViewAttributes();         res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,                                           getHostVisibility(), mDisplay.getDisplayId(), mWinFrame,                                           mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,                                           mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel);     } catch (RemoteException e) {         mAdded = false;         mView = null;         mAttachInfo.mRootView = null;         mInputChannel = null;         mFallbackEventHandler.setView(null);         unscheduleTraversals();         setAccessibilityFocus(null, null);         throw new RuntimeException(\"Adding window failed\", e);     } finally {         if (restore) {             attrs.restore();         }     }  ... }   requestLayout第一次调用是在setView方法中，从它开始执行View的测量、布局、绘制。  // ViewRootImpl.java @Override public void requestLayout() {     if (!mHandlingLayoutInLayoutRequest) {         checkThread();         mLayoutRequested = true;         scheduleTraversals();     } }   上面代码先是检查线程是否为合法线程，即是否为主线程，然后设置请求布局标示符设置为true，这个参数决定了后续是否执行measure和layout操作。最后执行scheduleTraversals()方法：  // ViewRootImpl.java @UnsupportedAppUsage void scheduleTraversals() {     if (!mTraversalScheduled) {         mTraversalScheduled = true;         mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();         mChoreographer.postCallback(             Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);         if (!mUnbufferedInputDispatch) {             scheduleConsumeBatchedInput();         }         notifyRendererOfFramePending();         pokeDrawLockIfNeeded();     } }   首先向主线程消息队列插入同步屏障消息，该方法发送了一个没有 target 的 Message 到 MessageQueue 中，在 next 方法中获取消息时，如果发现没有 target 的 Message，则在一定的时间内跳过同步消息，优先执行异步消息。这里通过调用此方法，保证 UI 绘制操作优先执行。  紧接着调用Choreographer的postCallback方法，发送一个Message到主线程消息队列：  // Choreographer.java public void postCallback(int callbackType, Runnable action, Object token) {     postCallbackDelayed(callbackType, action, token, 0); } @TestApi public void postCallbackDelayed(int callbackType,                                 Runnable action, Object token, long delayMillis) {     if (action == null) {         throw new IllegalArgumentException(\"action must not be null\");     }     if (callbackType &lt; 0 || callbackType &gt; CALLBACK_LAST) {         throw new IllegalArgumentException(\"callbackType is invalid\");     }      postCallbackDelayedInternal(callbackType, action, token, delayMillis); }  private void postCallbackDelayedInternal(int callbackType,                                          Object action, Object token, long delayMillis) {     if (DEBUG_FRAMES) {         Log.d(TAG, \"PostCallback: type=\" + callbackType               + \", action=\" + action + \", token=\" + token               + \", delayMillis=\" + delayMillis);     }      synchronized (mLock) {         final long now = SystemClock.uptimeMillis();         final long dueTime = now + delayMillis;         mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);          if (dueTime &lt;= now) {             scheduleFrameLocked(now);         } else {             Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);             msg.arg1 = callbackType;             msg.setAsynchronous(true);             mHandler.sendMessageAtTime(msg, dueTime);         }     } }   最终通过Message的setAsynchronous设置为一个异步消息，然后发送到MessageQueue中去。  另外，mTraversalRunnable是TraversalRunnable类型对象，它实现了一个Runnable的接口，内部执行doTraversal()方法：  // ViewRootImpl.java final class TraversalRunnable implements Runnable {     @Override     public void run() {         doTraversal();     } }  void doTraversal() {     if (mTraversalScheduled) {         mTraversalScheduled = false;         mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);          if (mProfile) {             Debug.startMethodTracing(\"ViewAncestor\");         }          performTraversals();          if (mProfile) {             Debug.stopMethodTracing();             mProfile = false;         }     } }   最终执行了perforTraversals()方法，而View的绘制也是从这个方法开始的：  // ViewRootImpl.java  private void performTraversals() {     ...     if (layoutRequested) {         ...         // 执行perforMeasure进行测量工作         windowSizeMayChange |= measureHierarchy(host, lp, res,                     desiredWindowWidth, desiredWindowHeight);        }          ...              if (didLayout) {         // 执行布局工作         performLayout(lp, mWidth, mHeight);     }     ...              boolean cancelDraw = mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;      if (!cancelDraw &amp;&amp; !newSurface) {         if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) {             for (int i = 0; i &lt; mPendingTransitions.size(); ++i) {                 mPendingTransitions.get(i).startChangingAnimations();             }             mPendingTransitions.clear();         } \t\t// 执行绘制工作         performDraw();     } else {         if (isViewVisible) {             // Try again             scheduleTraversals();         } else if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) {             for (int i = 0; i &lt; mPendingTransitions.size(); ++i) {                 mPendingTransitions.get(i).endChangingAnimations();             }             mPendingTransitions.clear();         }     }      }    首先看measureHierarchy方法：  // ViewRootImpl.java private boolean measureHierarchy(final View host, final WindowManager.LayoutParams lp,             final Resources res, final int desiredWindowWidth, final int desiredWindowHeight) { \tint childWidthMeasureSpec;     int childHeightMeasureSpec;     boolean windowSizeMayChange = false;     ...      if (!goodMeasure) {         childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);         childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);         // 执行测量工作         performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);         if (mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) {             windowSizeMayChange = true;         }     }     ...  }   在这个方法中，通过 getRootMeasureSpec 方法获取了根 View的MeasureSpec，实际上 MeasureSpec 中的宽高此处获取的值是 Window 的宽高。紧接着 调用performMeasure方法：  // ViewRootImpl.java private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {     if (mView == null) {         return;     }     Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"measure\");     try {         mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);     } finally {         Trace.traceEnd(Trace.TRACE_TAG_VIEW);     } }   这个方法只是执行了mView的measure方法，这个mView就是DecorView，其中DecorView的measure方法中会调用View的measure 方法，measure() 这个方法是 final 的，所以 View 子类只能通过重载 onMeasure()来实现自己的测量逻辑。  // View.java public final void measure(int widthMeasureSpec, int heightMeasureSpec) {     boolean optical = isLayoutModeOptical(this);     if (optical != isLayoutModeOptical(mParent)) {         Insets insets = getOpticalInsets();         int oWidth  = insets.left + insets.right;         int oHeight = insets.top  + insets.bottom;         widthMeasureSpec  = MeasureSpec.adjust(widthMeasureSpec,  optical ? -oWidth  : oWidth);         heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);     }     ...      if (forceLayout || needsLayout) {         // first clears the measured dimension flag         mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;          resolveRtlPropertiesIfNeeded();          int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key);         if (cacheIndex &lt; 0 || sIgnoreMeasureCache) {             // measure ourselves, this should set the measured dimension flag back             // 执行onMeasure方法             onMeasure(widthMeasureSpec, heightMeasureSpec);             mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;         } else {             long value = mMeasureCache.valueAt(cacheIndex);             // Casting a long to int drops the high 32 bits, no mask needed             setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value);             mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;         }          // flag not set, setMeasuredDimension() was not invoked, we raise         // an exception to warn the developer         if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) {             throw new IllegalStateException(\"View with id \" + getId() + \": \"                                             + getClass().getName() + \"#onMeasure() did not set the\"                                             + \" measured dimension by calling\"                                             + \" setMeasuredDimension()\");         }          mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;     }      mOldWidthMeasureSpec = widthMeasureSpec;     mOldHeightMeasureSpec = heightMeasureSpec;      mMeasureCache.put(key, ((long) mMeasuredWidth) &lt;&lt; 32 |                       (long) mMeasuredHeight &amp; 0xffffffffL); // suppress sign extension }   进而执行DecorView的onMeasure方法:  // DecorView.java protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {     final DisplayMetrics metrics = getContext().getResources().getDisplayMetrics();     final boolean isPortrait =         getResources().getConfiguration().orientation == ORIENTATION_PORTRAIT;      final int widthMode = getMode(widthMeasureSpec);     final int heightMode = getMode(heightMeasureSpec);      ...     super.onMeasure(widthMeasureSpec, heightMeasureSpec);      int width = getMeasuredWidth();     boolean measure = false;      widthMeasureSpec = MeasureSpec.makeMeasureSpec(width, EXACTLY);      if (!fixedWidth &amp;&amp; widthMode == AT_MOST) {         final TypedValue tv = isPortrait ? mWindow.mMinWidthMinor : mWindow.mMinWidthMajor;         if (tv.type != TypedValue.TYPE_NULL) {             final int min;             if (tv.type == TypedValue.TYPE_DIMENSION) {                 min = (int)tv.getDimension(metrics);             } else if (tv.type == TypedValue.TYPE_FRACTION) {                 min = (int)tv.getFraction(mAvailableWidth, mAvailableWidth);             } else {                 min = 0;             }             if (DEBUG_MEASURE) Log.d(mLogTag, \"Adjust for min width: \" + min + \", value::\"                                      + tv.coerceToString() + \", mAvailableWidth=\" + mAvailableWidth);              if (width &lt; min) {                 widthMeasureSpec = MeasureSpec.makeMeasureSpec(min, EXACTLY);                 measure = true;             }         }     }      // TODO: Support height?      if (measure) {         super.onMeasure(widthMeasureSpec, heightMeasureSpec);     } }    又因为DecorView继承自FrameLayout，因此最终会执行FrameLayout的onMeasure方法，递归调用子 View 的 onMeasure 方法。  // FrameLayout.java @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {     int count = getChildCount();      final boolean measureMatchParentChildren =         MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||         MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;     mMatchParentChildren.clear();      int maxHeight = 0;     int maxWidth = 0;     int childState = 0;      for (int i = 0; i &lt; count; i++) {         final View child = getChildAt(i);         if (mMeasureAllChildren || child.getVisibility() != GONE) {             measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);             final LayoutParams lp = (LayoutParams) child.getLayoutParams();             maxWidth = Math.max(maxWidth,                                 child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);             maxHeight = Math.max(maxHeight,                                  child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);             childState = combineMeasuredStates(childState, child.getMeasuredState());             if (measureMatchParentChildren) {                 if (lp.width == LayoutParams.MATCH_PARENT ||                     lp.height == LayoutParams.MATCH_PARENT) {                     mMatchParentChildren.add(child);                 }             }         }     }      // Account for padding too     maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();     maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();      // Check against our minimum height and width     maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());     maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());      // Check against our foreground's minimum height and width     final Drawable drawable = getForeground();     if (drawable != null) {         maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());         maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());     }      setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),                          resolveSizeAndState(maxHeight, heightMeasureSpec,                                              childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));      count = mMatchParentChildren.size();     if (count &gt; 1) {         for (int i = 0; i &lt; count; i++) {             final View child = mMatchParentChildren.get(i);             final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();              final int childWidthMeasureSpec;             if (lp.width == LayoutParams.MATCH_PARENT) {                 final int width = Math.max(0, getMeasuredWidth()                                            - getPaddingLeftWithForeground() - getPaddingRightWithForeground()                                            - lp.leftMargin - lp.rightMargin);                 childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(                     width, MeasureSpec.EXACTLY);             } else {                 childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,                                                             getPaddingLeftWithForeground() + getPaddingRightWithForeground() +                                                             lp.leftMargin + lp.rightMargin,                                                             lp.width);             }              final int childHeightMeasureSpec;             if (lp.height == LayoutParams.MATCH_PARENT) {                 final int height = Math.max(0, getMeasuredHeight()                                             - getPaddingTopWithForeground() - getPaddingBottomWithForeground()                                             - lp.topMargin - lp.bottomMargin);                 childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(                     height, MeasureSpec.EXACTLY);             } else {                 childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,                                                              getPaddingTopWithForeground() + getPaddingBottomWithForeground() +                                                              lp.topMargin + lp.bottomMargin,                                                              lp.height);             }              child.measure(childWidthMeasureSpec, childHeightMeasureSpec);         }     } }   performLayout与上面流程类似。  接着看performDraw方法：  // ViewRootImpl.java private void performDraw() { \t...     try {         boolean canUseAsync = draw(fullRedrawNeeded);         if (usingAsyncReport &amp;&amp; !canUseAsync) {             mAttachInfo.mThreadedRenderer.setFrameCompleteCallback(null);             usingAsyncReport = false;         }     } finally {         mIsDrawing = false;         Trace.traceEnd(Trace.TRACE_TAG_VIEW);     }     ...          }   private boolean draw(boolean fullRedrawNeeded) { \tSurface surface = mSurface;     if (!surface.isValid()) {         return false;     }     ...     if (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) {         if (mAttachInfo.mThreadedRenderer != null &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) {             ...             // 开启硬件加速 ，启动硬件加速绘制             mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, this, callback);         } else {             ...               \t\t\t// 使用软件绘制             if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset,                               scalingRequired, dirty, surfaceInsets)) {                 return false;             }         } \t} }   ViewRootImpl 中有一个非常重要的对象 Surface，之所以说 ViewRootImpl 的一个核心功能就是负责 UI 渲染，原因就在于在 ViewRootImpl 中会将我们在 draw 方法中绘制的 UI 元素，绑定到这个 Surface 上。Surface 中的内容最终会被传递给底层的 SurfaceFlinger，最终将 Surface 中的内容进行合成并显示的屏幕上。  接下来看drawSoftware:  // ViewRootImpl.java private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,                              boolean scalingRequired, Rect dirty, Rect surfaceInsets) {     // Draw with software renderer.     final Canvas canvas;      ...      canvas = mSurface.lockCanvas(dirty);     ...     try {         ...         mView.draw(canvas);         ...     } finally {         surface.unlockCanvasAndPost(canvas);     }       \t... }   上面代码中调用 DecorView 的 draw 方法将 UI 元素绘制到画布 Canvas 对象中，最后请求将 Canvas 中的内容显示到屏幕上，实际上就是将 Canvas 中的内容提交给 SurfaceFlinger 进行合成处理。  默认情况下软件绘制没有采用 GPU 渲染的方式，drawSoftware 工作完全由 CPU 来完成。因为DecorView 并没有复写 draw 方法，因此实际是调用的顶层 View 的 draw 方法：  // View.java @CallSuper public void draw(Canvas canvas) {     final int privateFlags = mPrivateFlags;     final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;         (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);     mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;      /*          * Draw traversal performs several drawing steps which must be executed          * in the appropriate order:          *          *      1. Draw the background          *      2. If necessary, save the canvas' layers to prepare for fading          *      3. Draw view's content          *      4. Draw children          *      5. If necessary, draw the fading edges and restore layers          *      6. Draw decorations (scrollbars for instance)          */      // Step 1, draw the background, if needed     int saveCount;      if (!dirtyOpaque) {         // 绘制View的背景         drawBackground(canvas);     }      // skip step 2 &amp; 5 if possible (common case)     final int viewFlags = mViewFlags;     boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;     boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;     if (!verticalEdges &amp;&amp; !horizontalEdges) {         // Step 3, draw the content         // 绘制View自身内容         if (!dirtyOpaque) onDraw(canvas);          // Step 4, draw the children         // 进行事件分发，实际调用的是ViewGroup的方法，并递归调用子View的draw方法         dispatchDraw(canvas);          drawAutofilledHighlight(canvas);          // Overlay is part of the content and draws beneath Foreground         if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) {             mOverlay.getOverlayView().dispatchDraw(canvas);         }          // Step 6, draw decorations (foreground, scrollbars)         onDrawForeground(canvas);          // Step 7, draw the default focus highlight         drawDefaultFocusHighlight(canvas);          if (debugDraw()) {             debugDrawFocus(canvas);         }          // we're done...         return;     }     ... }   上面代码最终会调用ViewGroup的dispatchDraw方法，进而递归调用到子View的draw方法。  启用硬件加速  可以在 ViewRootImpl 的 draw 方法中，通过如下方法判断是否启用硬件加速：  // ViewRootImpl.java if (mAttachInfo.mThreadedRenderer != null &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()){     // 执行硬件加速绘制 }    我们可以在 AndroidManifest 清单文件中，指定 Application 或者某一个 Activity 支持硬件加速，如下：  &lt;application android:hardwareAccelerated=\"true\"&gt; \t&lt;activity ... /&gt;     &lt;activity android:hardwareAccelerated=\"false\"&gt; &lt;/application&gt;   另外也可以更加细粒度的进行硬件加速配置  // window级别 getWindow().setFlags( \tWindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,     WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED );  // view级别 View.setLayerType(View.LAYER_TYPE_SOFTWARE, null);   之所以会有这么多级的支持区分，主要是因为并不是所有的 2D 绘制操作都支持硬件加速，当在自定义 View 中使用了如下 API，则有可能造成程序工作不正常：  // Canvas  clipPath() clipRegion() drawPicture() drawPosText() drawTextOnPath() drawVertices()  // Paint  setLinearText() setMaskFilter() setRasterizer()   invalidate与postInvalidate  上面方法与requestLayout的区别是它们不一定会触发 View 的 measure 和 layout 的操作，多数情况下只会执行 draw 操作。  在View的measure方法中，可以看下：  public final void measure(int widthMeasureSpec, int heightMeasureSpec) { \t...     final boolean forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;     ...     if (forceLayout || needsLayout) {         // first clears the measured dimension flag         mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;          resolveRtlPropertiesIfNeeded();          int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key);         if (cacheIndex &lt; 0 || sIgnoreMeasureCache) {             // measure ourselves, this should set the measured dimension flag back             onMeasure(widthMeasureSpec, heightMeasureSpec);             mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;         } else {             long value = mMeasureCache.valueAt(cacheIndex);             // Casting a long to int drops the high 32 bits, no mask needed             setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value);             mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;         }          // flag not set, setMeasuredDimension() was not invoked, we raise         // an exception to warn the developer         if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) {             throw new IllegalStateException(\"View with id \" + getId() + \": \"                                             + getClass().getName() + \"#onMeasure() did not set the\"                                             + \" measured dimension by calling\"                                             + \" setMeasuredDimension()\");         }          mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;     } \t... }    可以看出，如果要触发 onMeasure 方法，需要对 View 设置 PFLAG_FORCE_LAYOUT 标志位，而这个标志位在 requestLayout 方法中被设置，invalidate 并没有设置此标志位。  onLayout方法也是如此：  // View.java public void layout(int l, int t, int r, int b) {     ...     if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {         onLayout(changed, l, t, r, b);     }     ... }    可以看出，当 View 的位置发送改变，或者添加 PFLAG_LAYOUT_REQUIRED 标志位后 onLayout 才会被执行。当调用 invalidate 方法时，如果 View 的位置并没有发生改变，则 View 不会触发重新布局的操作。  而postInvalidate与它类似，不过有一点区别： invalidate 是在 UI 线程调用，postInvalidate 是在非 UI 线程调用  // View.java  public void postInvalidate() {     postInvalidateDelayed(0); } public void postInvalidateDelayed(long delayMilliseconds) {     // We try only with the AttachInfo because there's no point in invalidating     // if we are not attached to our window     final AttachInfo attachInfo = mAttachInfo;     if (attachInfo != null) {         attachInfo.mViewRootImpl.dispatchInvalidateDelayed(this, delayMilliseconds);     } }   最终交给了ViewRootImpl来执行：  // ViewRootImpl.java public void dispatchInvalidateDelayed(View view, long delayMilliseconds) {     Message msg = mHandler.obtainMessage(MSG_INVALIDATE, view);     mHandler.sendMessageDelayed(msg, delayMilliseconds); }  final class ViewRootHandler extends Handler {     @Override     public void handleMessage(Message msg) {         switch (msg.what) {             case MSG_INVALIDATE:                 ((View) msg.obj).invalidate();                 break;                 ...         }     } }   在非 UI 线程中，通过 Handler 发送了一个延时 Message，因为 Handler 是在主线程中创建的，所以最终 handlerMessage 会在主线程中被执行， msg.obj 就是发送 postInvalidate 的 View 对象，可以看出最终还是回到 UI 线程执行了 View 的 invalidate 方法。  子线程可以更新UI吗？  我们知道通常子线程不会更新UI，因为现在屏幕刷新率最低是 60Hz，意味着最多每 16ms 就会刷新一次屏幕，所以 UI 更新要尽可能快速，否则会丢帧导致卡顿。另外如果多个子线程更新，那么 UI 更新操作就需要加锁，频繁的加锁释放锁可能会延长 UI 渲染时间，但是不加锁如果允许子线程更新 UI 会导致多个线程对 UI 同时更新，造成线程不安全而导致 UI 最终效果无法想象，所以 Android 直接限制了子线程更新 UI，那么有没有办法可以更新UI呢？从源码中来看下：  // ViewRootImpl.java  @Override public void requestLayout() {     if (!mHandlingLayoutInLayoutRequest) {         checkThread();         mLayoutRequested = true;         scheduleTraversals();     } }  void checkThread() {     if (mThread != Thread.currentThread()) {         throw new CalledFromWrongThreadException(             \"Only the original thread that created a view hierarchy can touch its views.\");     } }   上面是导致有时候子线程更新UI时异常崩溃的直接原因。  另外我们也看下View的requestLayout方法：  public void requestLayout(){     ...     // 如果当前 View 存在 ViewParent，且 isLayoutRequested() 为 false 则调用 ViewParent 的 requestLayout()    if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) {       mParent.requestLayout();    }     ... }   上面代码中View 的 requestLayout() 会调用其父布局的 requestLayout()，ViewGrop 并没有重写这个方法，所以还是调用的 View 的 requestLayout()，即一直递归到最上层。最上层的View就是DecorView，而DecorView其实也有mParent，即ViewRootImpl:  // ViewRootImpl.java public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView,       int userId) {    synchronized (this) {       if (mView == null) {          ...          view.assignParent(this);          ...       }    } }   这里的view即为参数传进来的DecorView，其调用了View的assignParent方法：  // View.java void assignParent(ViewParent parent) {    if (mParent == null) {       mParent = parent;    } else if (parent == null) {       mParent = null;    } else {       throw new RuntimeException(\"view \" + this + \" being added, but\"                + \" it already has a parent\");    } }   分析后总结：     子线程更新 View 会调用 View的requestLayout()，然后开始递归查找父 View，找到了 Activity 的顶层 View 是 DecorView。   DecorView 的 ViewParent 是 ViewRootImpl，所以调用了 ViewRootImpl的requestLayout()，继而调用了 ViewRootImpl的checkThread()。   由于ViewRootImpl 在主线程初始化，因此子线程调用检查线程会抛出异常。   所以这要让上述几个条件不成立就可以不让程序崩溃掉：  打破mParent == null或者mParent.isLayoutRequested() 为true          在DecorView和ViewRootImpl关联之前，更新View，比如onResume及以前更新View      这时候mParent为null，所以条件不成立           在子线程更新 View 之前先 requestLayout      // View.java public boolean isLayoutRequested() {    return (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT; }    public void requetLayout(){     ...     mPrivateFlags |= PFLAG_FORCE_LAYOUT;     mPrivateFlags |= PFLAG_INVALIDATED;        ...     if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) {        mParent.requestLayout();     }     ... }    public void layout(int l, int t, int r, int b) {     ...     mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;     ... }           上面方法的结果与mPrivateFlags 是否存在 PFLAG_FORCE_LAYOUT 有关，而第一层请求requestLayout时就会在 mPrivateFlags 加入 PFLAG_FORCE_LAYOUT,在 View的layout() 里会去掉该标志，所以我们可以先在主线程调用requestLayout方法，然后马上调用子线程更新View就不会发生异常了。           子线程初始化ViewRootImpl      这个比价好理解，让ViewRootImpl和更新View的线程在一个线程即可：      new Thread(new Runnable() {     Looper.prepare()     val imageView = ImageView(this)     windowManager.addView(imageView, WindowManager.LayoutParams())     // 更新View     Looper.loop() })                在硬件加速的情况下只调用 View的invalidate()不会触发线程检查。      // View.java public void invalidate(boolean invalidateCache) {    invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true); }    void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache,       boolean fullInvalidate) {    ...    if ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)             || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)             || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED             || (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)) {       ...       final AttachInfo ai = mAttachInfo;       final ViewParent p = mParent;       if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) {             final Rect damage = ai.mTmpInvalRect;             damage.set(l, t, r, b);             p.invalidateChild(this, damage);       }    } }           p.invalidateChild(this, damage) 表示使 ViewParent 重绘这个 View，所以看下这个方法：      // ViewGroup.java public final void invalidateChild(View child, final Rect dirty) {    final AttachInfo attachInfo = mAttachInfo;    if (attachInfo != null &amp;&amp; attachInfo.mHardwareAccelerated) {       // HW accelerated fast path       onDescendantInvalidated(child, child);       return;    }    ... } public void onDescendantInvalidated(@NonNull View child, @NonNull View target) {    ...    if (mParent != null) {       mParent.onDescendantInvalidated(this, target);    } }           首先就会判断是否开启了硬件加速，如果开启了会进入onDescendantInvalidated这个方法：      // ViewRootImpl.java public void onDescendantInvalidated(@NonNull View child, @NonNull View descendant) {    if ((descendant.mPrivateFlags &amp; PFLAG_DRAW_ANIMATION) != 0) {       mIsAnimating = true;    }    invalidate(); }    @UnsupportedAppUsage void invalidate() {    mDirty.set(0, 0, mWidth, mHeight);    if (!mWillDrawSoon) {       scheduleTraversals();    } }              最终调用了ViewRootImpl的onDescendantInvalidated方法，这里执行了scheduleTraversals方法但是没有checkThread。           如果不修改 Drawable 的固有宽高不变就不会调用 requestLayout()      mDrawableWidth 和 mDrawableHeight 的改变在 updateDrawable()中。           TextView 在固定尺寸下更新文本，它的setText方法会调用checkForRelayout()方法：      // TextView.java private void checkForRelayout() {    if ((mLayoutParams.width != LayoutParams.WRAP_CONTENT          || (mMaxWidthMode == mMinWidthMode &amp;&amp; mMaxWidth == mMinWidth))          &amp;&amp; (mHint == null || mHintLayout != null)          &amp;&amp; (mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight() &gt; 0)) {       // 上述三个条件为：       // TextView 的宽度是固定的       // 没有设置提示文本，或者提示文本已经被渲染完成       // TextView 的宽度大于 0          int oldht = mLayout.getHeight();       int want = mLayout.getWidth();       int hintWant = mHintLayout == null ? 0 : mHintLayout.getWidth();          makeNewLayout(want, hintWant, UNKNOWN_BORING, UNKNOWN_BORING,                mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight(),                false);          if (mEllipsize != TextUtils.TruncateAt.MARQUEE) {          // 不是跑马灯模式          if (mLayoutParams.height != LayoutParams.WRAP_CONTENT                &amp;&amp; mLayoutParams.height != LayoutParams.MATCH_PARENT) {             // TextView 的高度是固定的             autoSizeText();             invalidate();             return;          }             if (mLayout.getHeight() == oldht                &amp;&amp; (mHintLayout == null || mHintLayout.getHeight() == oldht)) {             // 没有改变高度             autoSizeText();             invalidate();             return;          }       }          requestLayout();       invalidate();    } else {       nullLayouts();       requestLayout();       invalidate();    } }           可以看到满足源码中注释的条件就不会触发 View#requestLayout()。           SurfaceView使用自带 Surface 去做画面渲染 ， TextureView可以通过 lockCanvas()使用临时的 Surface，所以都不会触发 View的requestLayout()方法。      上面分享只是为了熟悉底层原理，了解了 Activity View 树的构建流程、更新 UI 的基础流程。但是根据 Android 的设计理念，还是不应使用在子线程中更新 UI，以免造成未知的异常出现。"
  },
  
  {
    "title": "Android Framework源码分析之Activity、Window、View之间的关系",
    "url": "/posts/android-framework-activity-window-view/",
    "categories": "Android",
    "tags": "源码分析, framework",
    "date": "2019-05-27 00:00:00 +0800",
    "content": "每当我们显示一个界面的时候，都是通过start一个Activity的方式，对于显示布局内容，也只是通过在onCreate方法里面setContentView就可以，剩下的都是Activity帮我们做了，我们自始至终也没有创建过window或者view，那么这背后都发生了什么 ？这篇文章梳理一下这三者的关系  setContentView  我们从setContentView源码开始：  // Activity.java public void setContentView(@LayoutRes int layoutResID) {     getWindow().setContentView(layoutResID);     initWindowDecorActionBar(); }   这里直接把操作交给了window来处理，getWindow返回的是Activity中的全局变量mWindow，它是Window类型，在分析startActivity过程时，还记得最后会调用到 ActivityThread 中的 performLaunchActivity 方法。通过反射创建Activity对象，并执行其attach方法，mWindow就是在这个方法中被创建：  // ActivityThread.java     @UnsupportedAppUsage final void attach(Context context, ActivityThread aThread,                   Instrumentation instr, IBinder token, int ident,                   Application application, Intent intent, ActivityInfo info,                   CharSequence title, Activity parent, String id,                   NonConfigurationInstances lastNonConfigurationInstances,                   Configuration config, String referrer, IVoiceInteractor voiceInteractor,                   Window window, ActivityConfigCallback activityConfigCallback) {     attachBaseContext(context);      mFragments.attachHost(null /*parent*/); \t// 创建window对象     mWindow = new PhoneWindow(this, window, activityConfigCallback);     mWindow.setWindowControllerCallback(this);     // 设置callback     mWindow.setCallback(this);     mWindow.setOnWindowDismissedCallback(this);     mWindow.getLayoutInflater().setPrivateFactory(this);     if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) {         mWindow.setSoftInputMode(info.softInputMode);     }     if (info.uiOptions != 0) {         mWindow.setUiOptions(info.uiOptions);     }     mUiThread = Thread.currentThread();      mMainThread = aThread;     mInstrumentation = instr;     mToken = token;     mIdent = ident;     mApplication = application;     mIntent = intent;     mReferrer = referrer;     mComponent = intent.getComponent();     mActivityInfo = info;     mTitle = title;     mParent = parent;     mEmbeddedID = id;     mLastNonConfigurationInstances = lastNonConfigurationInstances;     if (voiceInteractor != null) {         if (lastNonConfigurationInstances != null) {             mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor;         } else {             mVoiceInteractor = new VoiceInteractor(voiceInteractor, this, this,                                                    Looper.myLooper());         }     } \t// 绑定windowManager引用     mWindow.setWindowManager(         (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),         mToken, mComponent.flattenToString(),         (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);     if (mParent != null) {         mWindow.setContainer(mParent.getWindow());     }     mWindowManager = mWindow.getWindowManager();     mCurrentConfig = config;      mWindow.setColorMode(info.colorMode);      setAutofillCompatibilityEnabled(application.isAutofillCompatibilityEnabled()); }   从上面代码中，我们可以看出mWindow被赋值为一个PhoneWindow对象，实际上它也是整个Android系统中Window的一个唯一的实现类。  紧接着调用setWindowManager方法，将WindowManager传给PhoneWindow：  // PhoneWindow.java public void setWindowManager(WindowManager wm, IBinder appToken, String appName,                              boolean hardwareAccelerated) {     mAppToken = appToken;     mAppName = appName;     mHardwareAccelerated = hardwareAccelerated         || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false);     if (wm == null) {         wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);     }     mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this); }   最终，交给了WindowManagerImpl来创建一个实例对象，即PhoneWindow持有了WindowManagerImpl的引用。  紧接着上面看PhoneWindow的setContentView方法：  // PhoneWindow.java  @Override public void setContentView(int layoutResID) {     // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window     // decor, when theme attributes and the like are crystalized. Do not check the feature     // before this happens.     if (mContentParent == null) {         installDecor();     } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {         mContentParent.removeAllViews();     }      if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {         final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,                                                        getContext());         transitionTo(newScene);     } else {         mLayoutInflater.inflate(layoutResID, mContentParent);     }     mContentParent.requestApplyInsets();     final Callback cb = getCallback();     if (cb != null &amp;&amp; !isDestroyed()) {         cb.onContentChanged();     }     mContentParentExplicitlySet = true; }   上面代码中档mContentParent为null时，会执行installDecor方法来初始化DecorView和mContentParent：  // PhoneWindow.java      private void installDecor() {         mForceDecorInstall = false;         if (mDecor == null) {             // 创建DecorView             mDecor = generateDecor(-1);             mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);             mDecor.setIsRootNamespace(true);             if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) {                 mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);             }         } else {             mDecor.setWindow(this);         }         if (mContentParent == null) {             // 创建FrameLayout布局             mContentParent = generateLayout(mDecor);              // Set up decor part of UI to ignore fitsSystemWindows if appropriate.             mDecor.makeOptionalFitsSystemWindows();              final DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById(                     R.id.decor_content_parent);              if (decorContentParent != null) {                 mDecorContentParent = decorContentParent;                 mDecorContentParent.setWindowCallback(getCallback());                 if (mDecorContentParent.getTitle() == null) {                     mDecorContentParent.setWindowTitle(mTitle);                 }                  final int localFeatures = getLocalFeatures();                 for (int i = 0; i &lt; FEATURE_MAX; i++) {                     if ((localFeatures &amp; (1 &lt;&lt; i)) != 0) {                         mDecorContentParent.initFeature(i);                     }                 }                  mDecorContentParent.setUiOptions(mUiOptions);                  if ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_ICON) != 0 ||                         (mIconRes != 0 &amp;&amp; !mDecorContentParent.hasIcon())) {                     mDecorContentParent.setIcon(mIconRes);                 } else if ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_ICON) == 0 &amp;&amp;                         mIconRes == 0 &amp;&amp; !mDecorContentParent.hasIcon()) {                     mDecorContentParent.setIcon(                             getContext().getPackageManager().getDefaultActivityIcon());                     mResourcesSetFlags |= FLAG_RESOURCE_SET_ICON_FALLBACK;                 }                 if ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_LOGO) != 0 ||                         (mLogoRes != 0 &amp;&amp; !mDecorContentParent.hasLogo())) {                     mDecorContentParent.setLogo(mLogoRes);                 }                  // Invalidate if the panel menu hasn't been created before this.                 // Panel menu invalidation is deferred avoiding application onCreateOptionsMenu                 // being called in the middle of onCreate or similar.                 // A pending invalidation will typically be resolved before the posted message                 // would run normally in order to satisfy instance state restoration.                 PanelFeatureState st = getPanelState(FEATURE_OPTIONS_PANEL, false);                 if (!isDestroyed() &amp;&amp; (st == null || st.menu == null) &amp;&amp; !mIsStartingWindow) {                     invalidatePanelMenu(FEATURE_ACTION_BAR);                 }             } else {                 mTitleView = findViewById(R.id.title);                 if (mTitleView != null) {                     if ((getLocalFeatures() &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) != 0) {                         final View titleContainer = findViewById(R.id.title_container);                         if (titleContainer != null) {                             titleContainer.setVisibility(View.GONE);                         } else {                             mTitleView.setVisibility(View.GONE);                         }                         mContentParent.setForeground(null);                     } else {                         mTitleView.setText(mTitle);                     }                 }             }              if (mDecor.getBackground() == null &amp;&amp; mBackgroundFallbackResource != 0) {                 mDecor.setBackgroundFallback(mBackgroundFallbackResource);             }              ...         }     }    可以看到上面代码通过generateDecor方法和generateLayout方法分别创建出了DecorView和FrameLayout布局:  // PhoneWindow.java protected DecorView generateDecor(int featureId) {     // System process doesn't have application context and in that case we need to directly use     // the context we have. Otherwise we want the application context, so we don't cling to the     // activity.     Context context;     if (mUseDecorContext) {         Context applicationContext = getContext().getApplicationContext();         if (applicationContext == null) {             context = getContext();         } else {             context = new DecorContext(applicationContext, getContext());             if (mTheme != -1) {                 context.setTheme(mTheme);             }         }     } else {         context = getContext();     }     return new DecorView(context, featureId, this, getAttributes()); }  protected ViewGroup generateLayout(DecorView decor) {         // Apply data from current theme.          TypedArray a = getWindowStyle();          ...          WindowManager.LayoutParams params = getAttributes();          ...           // Inflate the window decor.          int layoutResource;         int features = getLocalFeatures();         ...          mDecor.startChanging();         mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);          // 通过findViewById创建FrameLayout布局         ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);         if (contentParent == null) {             throw new RuntimeException(\"Window couldn't find content container view\");         }          if ((features &amp; (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS)) != 0) {             ProgressBar progress = getCircularProgressBar(false);             if (progress != null) {                 progress.setIndeterminate(true);             }         }          if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) {             registerSwipeCallbacks(contentParent);         }          // Remaining setup -- of background and title -- that only applies         // to top-level windows.         if (getContainer() == null) {             final Drawable background;             if (mBackgroundResource != 0) {                 background = getContext().getDrawable(mBackgroundResource);             } else {                 background = mBackgroundDrawable;             }             mDecor.setWindowBackground(background);              final Drawable frame;             if (mFrameResource != 0) {                 frame = getContext().getDrawable(mFrameResource);             } else {                 frame = null;             }             mDecor.setWindowFrame(frame);              mDecor.setElevation(mElevation);             mDecor.setClipToOutline(mClipToOutline);              if (mTitle != null) {                 setTitle(mTitle);             }              if (mTitleColor == 0) {                 mTitleColor = mTextColor;             }             setTitleColor(mTitleColor);         }          mDecor.finishChanging();          return contentParent;     }    其中mContentParent就是通过findViewById被创建出来，就是com.android.internal.R.id.content这个FrameLayout。  紧接着PhoneWindow的setContentView方法往下看，通过mLayoutInflater.inflate(layoutResID, mContentParent)方法将我们自己创建的布局添加到mContentParent布局上。最后，它们的关系如下图：    onResume  上面只是创建了 PhoneWindow，和DecorView，但目前二者真正产生关系是在ActivityThread.performResumeActivity 中，再调用 r.activity.performResume()，调用 r.activity.makeVisible，将 DecorView 添加到当前的 Window 上。  // ActivityThread.java @Override public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,                                  String reason) { \t...       if (a.mVisibleFromClient) {          if (!a.mWindowAdded) {              a.mWindowAdded = true;              wm.addView(decor, l);          } else {              // The activity will get a callback for this {@link LayoutParams} change              // earlier. However, at that time the decor will not be set (this is set              // in this method), so no action will be taken. This call ensures the              // callback occurs with the decor set.              a.onWindowAttributesChanged(l);          }      }          ...     if (r.activity.mVisibleFromClient) {         // 添加视图         r.activity.makeVisible();     }  }    在Activity的makeVisible方法中，我们调用了windowManager的addView方法：  // Activity.java void makeVisible() {     if (!mWindowAdded) {         ViewManager wm = getWindowManager();         wm.addView(mDecor, getWindow().getAttributes());         mWindowAdded = true;     }     mDecor.setVisibility(View.VISIBLE); }   WindowManager 的 addView 的具体实现在 WindowManagerImpl 中，而 WindowManagerImpl 的 addView 又会调用 WindowManagerGlobal.addView()，其中WindowManagerGlobal是WindowManagerImpl的一个单例对象。  public void addView(View view, ViewGroup.LayoutParams params,                     Display display, Window parentWindow) {     ...      final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;     if (parentWindow != null) {         parentWindow.adjustLayoutParamsForSubWindow(wparams);     } else {         // If there's no parent, then hardware acceleration for this view is         // set from the application's hardware acceleration setting.         final Context context = view.getContext();         if (context != null             &amp;&amp; (context.getApplicationInfo().flags                 &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != 0) {             wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;         }     }      ViewRootImpl root;     View panelParentView = null;      synchronized (mLock) {         ...          root = new ViewRootImpl(view.getContext(), display);          view.setLayoutParams(wparams);          mViews.add(view);         mRoots.add(root);         mParams.add(wparams);          // do this last because it fires off messages to start doing things         try {             root.setView(view, wparams, panelParentView);         } catch (RuntimeException e) {             // BadTokenException or InvalidDisplayException, clean up.             if (index &gt;= 0) {                 removeViewLocked(index, true);             }             throw e;         }     } }   这个过程创建一个 ViewRootImpl对象，并通过setView方法将之前创建的 DecorView 作为参数传入，以后 DecorView 的事件都由 ViewRootImpl 来管理了，比如，DecorView 上添加和删除View。ViewRootImpl 实现了 ViewParent 这个接口，这个接口最常见的一个方法是 requestLayout()。  ViewRootImpl 是个 ViewParent，在 DecoView 添加View 时，就会将 View 中的 ViewParent 设为 DecoView 所在的 ViewRootImpl，View 的 ViewParent 相同时，理解为这些 View 在一个 View 链上。所以每当调用 View 的 requestLayout()时，其实是调用到 ViewRootImpl，ViewRootImpl 会控制整个事件的流程。可以看出一个 ViewRootImpl 对添加到 DecoView 的所有 View 进行事件管理。  // ViewRootImpl.java public ViewRootImpl(Context context, Display display) {     mContext = context;          // 获取WindowSession的代理类     mWindowSession = WindowManagerGlobal.getWindowSession();     mDisplay = display;     mBasePackageName = context.getBasePackageName();     mThread = Thread.currentThread();     ...     mWindow = new W(this);     ...     mViewVisibility = View.GONE;     mFirst = true; // true for the first time the view is added     mAdded = false;     mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display, this, mHandler, this,                                       context);     ...     // 初始化Choreographer对象     mChoreographer = Choreographer.getInstance();     mDisplayManager = (DisplayManager)context.getSystemService(Context.DISPLAY_SERVICE);      if (!sCompatibilityDone) {         sAlwaysAssignFocus = mTargetSdkVersion &lt; Build.VERSION_CODES.P;          sCompatibilityDone = true;     }      loadSystemProperties(); }   public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {     synchronized (this) {         if (mView == null) {             mView = view;              ...             mAdded = true;             int res; /* = WindowManagerImpl.ADD_OKAY; */              // Schedule the first layout -before- adding to the window             // manager, to make sure we do the relayout before receiving             // any other events from the system.             // View的绘制流程             requestLayout();             if ((mWindowAttributes.inputFeatures                  &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {                 mInputChannel = new InputChannel();             }             mForceDecorViewVisibility = (mWindowAttributes.privateFlags                                          &amp; PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY) != 0;             try {                 mOrigWindowType = mWindowAttributes.type;                 mAttachInfo.mRecomputeGlobalAttributes = true;                 collectViewAttributes();                 // binder调用，实际上是System的Session类                 res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,                                                   getHostVisibility(), mDisplay.getDisplayId(), mWinFrame,                                                   mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,                                                   mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel);             } catch (RemoteException e) {                 mAdded = false;                 mView = null;                 mAttachInfo.mRootView = null;                 mInputChannel = null;                 mFallbackEventHandler.setView(null);                 unscheduleTraversals();                 setAccessibilityFocus(null, null);                 throw new RuntimeException(\"Adding window failed\", e);             } finally {                 if (restore) {                     attrs.restore();                 }             }                            if (view instanceof RootViewSurfaceTaker) {                 mInputQueueCallback =                     ((RootViewSurfaceTaker)view).willYouTakeTheInputQueue();             }             if (mInputChannel != null) {                 if (mInputQueueCallback != null) {                     mInputQueue = new InputQueue();                     mInputQueueCallback.onInputQueueCreated(mInputQueue);                 }                 mInputEventReceiver = new WindowInputEventReceiver(mInputChannel,                                                                    Looper.myLooper());             }              view.assignParent(this);             mAddedTouchMode = (res &amp; WindowManagerGlobal.ADD_FLAG_IN_TOUCH_MODE) != 0;             mAppVisible = (res &amp; WindowManagerGlobal.ADD_FLAG_APP_VISIBLE) != 0;              if (mAccessibilityManager.isEnabled()) {                 mAccessibilityInteractionConnectionManager.ensureConnection();             }              if (view.getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {                 view.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);             }              // Set up the input pipeline.             CharSequence counterSuffix = attrs.getTitle();             mSyntheticInputStage = new SyntheticInputStage();             InputStage viewPostImeStage = new ViewPostImeInputStage(mSyntheticInputStage);             InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage,                                                                         \"aq:native-post-ime:\" + counterSuffix);             InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage);             InputStage imeStage = new ImeInputStage(earlyPostImeStage,                                                     \"aq:ime:\" + counterSuffix);             InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage);             InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage,                                                                       \"aq:native-pre-ime:\" + counterSuffix);              mFirstInputStage = nativePreImeStage;             mFirstPostImeInputStage = earlyPostImeStage;             mPendingInputEventQueueLengthCounterName = \"aq:pending:\" + counterSuffix;         }     } }   上面的mWindowSession类是通过WindowManagerGlobal.getWindowSession()方法创建的，mWindowSession 实际上是 IWindowSession 类型，是一个 Binder 类型，真正的实现类是 System 进程中的 Session，可从下面分析看出：  // WindowManagerGlobal.java @UnsupportedAppUsage public static IWindowSession getWindowSession() {     synchronized (WindowManagerGlobal.class) {         if (sWindowSession == null) {             try {                 InputMethodManager imm = InputMethodManager.getInstance();                 IWindowManager windowManager = getWindowManagerService();                 sWindowSession = windowManager.openSession(                     new IWindowSessionCallback.Stub() {                         @Override                         public void onAnimatorScaleChanged(float scale) {                             ValueAnimator.setDurationScale(scale);                         }                     },                     imm.getClient(), imm.getInputContext());             } catch (RemoteException e) {                 throw e.rethrowFromSystemServer();             }         }         return sWindowSession;     } }  @UnsupportedAppUsage public static IWindowManager getWindowManagerService() {     synchronized (WindowManagerGlobal.class) {         if (sWindowManagerService == null) {             sWindowManagerService = IWindowManager.Stub.asInterface(                 ServiceManager.getService(\"window\"));             try {                 if (sWindowManagerService != null) {                     ValueAnimator.setDurationScale(                         sWindowManagerService.getCurrentAnimatorScale());                 }             } catch (RemoteException e) {                 throw e.rethrowFromSystemServer();             }         }         return sWindowMannagerService;     } }   上面IWindowManager是WMS的代理对象，openSession其实现如下：  // WindowManagerService.java @Override public IWindowSession openSession(IWindowSessionCallback callback, IInputMethodClient client,                                   IInputContext inputContext) {     if (client == null) throw new IllegalArgumentException(\"null client\");     if (inputContext == null) throw new IllegalArgumentException(\"null inputContext\");     Session session = new Session(this, callback, client, inputContext);     return session; }   由此可见，IWindowSession其实就是Session类，然后调用它的addToDisplay方法：  // Session.java @Override public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs,                         int viewVisibility, int displayId, Rect outFrame, Rect outContentInsets,                         Rect outStableInsets, Rect outOutsets,                         DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel) {     return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId, outFrame,                               outContentInsets, outStableInsets, outOutsets, outDisplayCutout, outInputChannel); }   方法中的mService 就是 WMS，该方法直接调用了WMS的addWindow方法。至此，Window 已经成功的被传递给了 WMS。  事件传递  再回看ViewRootImpl的setView方法：  // ViewRootImpl.java   public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {     synchronized (this) {         if (mView == null) {             mView = view;              ...             mAdded = true;             int res; /* = WindowManagerImpl.ADD_OKAY; */              // Schedule the first layout -before- adding to the window             // manager, to make sure we do the relayout before receiving             // any other events from the system.             // View的绘制流程             requestLayout();             if ((mWindowAttributes.inputFeatures                  &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {                 mInputChannel = new InputChannel();             }             mForceDecorViewVisibility = (mWindowAttributes.privateFlags                                          &amp; PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY) != 0;             try {                 mOrigWindowType = mWindowAttributes.type;                 mAttachInfo.mRecomputeGlobalAttributes = true;                 collectViewAttributes();                 // binder调用，实际上是System的Session类                 res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,                                                   getHostVisibility(), mDisplay.getDisplayId(), mWinFrame,                                                   mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,                                                   mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel);             } catch (RemoteException e) {                 mAdded = false;                 mView = null;                 mAttachInfo.mRootView = null;                 mInputChannel = null;                 mFallbackEventHandler.setView(null);                 unscheduleTraversals();                 setAccessibilityFocus(null, null);                 throw new RuntimeException(\"Adding window failed\", e);             } finally {                 if (restore) {                     attrs.restore();                 }             }                            if (view instanceof RootViewSurfaceTaker) {                 mInputQueueCallback =                     ((RootViewSurfaceTaker)view).willYouTakeTheInputQueue();             }             if (mInputChannel != null) {                 if (mInputQueueCallback != null) {                     mInputQueue = new InputQueue();                     mInputQueueCallback.onInputQueueCreated(mInputQueue);                 }                 mInputEventReceiver = new WindowInputEventReceiver(mInputChannel,                                                                    Looper.myLooper());             }              view.assignParent(this);             mAddedTouchMode = (res &amp; WindowManagerGlobal.ADD_FLAG_IN_TOUCH_MODE) != 0;             mAppVisible = (res &amp; WindowManagerGlobal.ADD_FLAG_APP_VISIBLE) != 0;              if (mAccessibilityManager.isEnabled()) {                 mAccessibilityInteractionConnectionManager.ensureConnection();             }              if (view.getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {                 view.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);             }              // Set up the input pipeline.             CharSequence counterSuffix = attrs.getTitle();             mSyntheticInputStage = new SyntheticInputStage();             InputStage viewPostImeStage = new ViewPostImeInputStage(mSyntheticInputStage);             InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage,                                                                         \"aq:native-post-ime:\" + counterSuffix);             InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage);             InputStage imeStage = new ImeInputStage(earlyPostImeStage,                                                     \"aq:ime:\" + counterSuffix);             InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage);             InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage,                                                                       \"aq:native-pre-ime:\" + counterSuffix);              mFirstInputStage = nativePreImeStage;             mFirstPostImeInputStage = earlyPostImeStage;             mPendingInputEventQueueLengthCounterName = \"aq:pending:\" + counterSuffix;         }     } }    看上面最后面几行，设置一系列的输入管道，一个触屏事件的发生是由屏幕发起，然后经过驱动层一系列的优化计算通过 Socket 跨进程通知 Android Framework 层（实际上就是 WMS），最终屏幕的触摸事件会被发送到上面的输入管道中。  当某一个屏幕触摸事件到达其中的 ViewPostImeInputState 时，会经过 onProcess 来处理：  // ViewPostImeInputState.java @Override protected int onProcess(QueuedInputEvent q) {     if (q.mEvent instanceof KeyEvent) {         return processKeyEvent(q);     } else {         final int source = q.mEvent.getSource();         if ((source &amp; InputDevice.SOURCE_CLASS_POINTER) != 0) {             return processPointerEvent(q);         } else if ((source &amp; InputDevice.SOURCE_CLASS_TRACKBALL) != 0) {             return processTrackballEvent(q);         } else {             return processGenericMotionEvent(q);         }     } }  private int processPointerEvent(QueuedInputEvent q) {     final MotionEvent event = (MotionEvent)q.mEvent;      mAttachInfo.mUnbufferedDispatchRequested = false;     mAttachInfo.mHandlingPointerEvent = true;     // 调用到了mView的方法     boolean handled = mView.dispatchPointerEvent(event);     maybeUpdatePointerIcon(event);     maybeUpdateTooltip(event);     mAttachInfo.mHandlingPointerEvent = false;     if (mAttachInfo.mUnbufferedDispatchRequested &amp;&amp; !mUnbufferedInputDispatch) {         mUnbufferedInputDispatch = true;         if (mConsumeBatchedInputScheduled) {             scheduleConsumeBatchedInputImmediately();         }     }     return handled ? FINISH_HANDLED : FORWARD; }    可以看到在 onProcess 中最终调用了一个 mView的dispatchPointerEvent 方法，mView 实际上就是 PhoneWindow 中的 DecorView，而 dispatchPointerEvent 是被 View.java 实现的：  // View.java @UnsupportedAppUsage public final boolean dispatchPointerEvent(MotionEvent event) {     if (event.isTouchEvent()) {         return dispatchTouchEvent(event);     } else {         return dispatchGenericMotionEvent(event);     } }   在dispatchPointerEvent方法中调用了DecorView的dispatchTouchEvent方法：  // DecorView.java @Override public boolean dispatchTouchEvent(MotionEvent ev) {     final Window.Callback cb = mWindow.getCallback();     return cb != null &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; 0         ? cb.dispatchTouchEvent(ev) : super.dispatchTouchEvent(ev); }   热这里的callback是在Activity启动阶段，实例化Activity对象后通过其attach方法设置callback：  // Activity.java @UnsupportedAppUsage final void attach(Context context, ActivityThread aThread,                   Instrumentation instr, IBinder token, int ident,                   Application application, Intent intent, ActivityInfo info,                   CharSequence title, Activity parent, String id,                   NonConfigurationInstances lastNonConfigurationInstances,                   Configuration config, String referrer, IVoiceInteractor voiceInteractor,                   Window window, ActivityConfigCallback activityConfigCallback) {     attachBaseContext(context);      mFragments.attachHost(null /*parent*/);      mWindow = new PhoneWindow(this, window, activityConfigCallback);     mWindow.setWindowControllerCallback(this);     // 设置callback     mWindow.setCallback(this);     mWindow.setOnWindowDismissedCallback(this);     mWindow.getLayoutInflater().setPrivateFactory(this);     ... }   至此，事件由DecorView传递到了Activity中，交由其dispatchTouchEvent来处理：  // Activity.java public boolean dispatchTouchEvent(MotionEvent ev) {     if (ev.getAction() == MotionEvent.ACTION_DOWN) {         onUserInteraction();     }     if (getWindow().superDispatchTouchEvent(ev)) {         return true;     }     return onTouchEvent(ev); }   Touch 事件在 Activity 中只是绕了一圈最后还是回到了 PhoneWindow 中的 DecorView 来处理:  // PhoneWindow.java @Override public boolean superDispatchTouchEvent(MotionEvent event) {     return mDecor.superDispatchTouchEvent(event); }   接下来就是从DecorView往下开始交给子View进行事件传递了。  总结  上面整个过程，大部分View的操作都被添加到Window中，而Activity中有一个 window，也就是 PhoneWindow 对象，在 PhoneWindow 中有一个 DecorView，在 setContentView 中会将 layout 填充到此 DecorView 中。  而Window对View的操作是通过WindowManager来处理的。WindowManager提供在Window上添加View、移除View和更新View的操作。  从上面可以看出addView的操作是通过ViewRootImpl完成Window的添加工作的，即WindowMangerGlobal 通过调用 ViewRootImpl 的 setView 方法，在其方法中通过WindowSession完成 window 的添加过程，这期间经历了一次IPC调用。setView 方法中主要完成两件事情：View 渲染（requestLayout）以及接收触屏事件。"
  },
  
  {
    "title": "Android Framework源码分析-Activity的启动过程",
    "url": "/posts/android-framework-start-activity/",
    "categories": "Android",
    "tags": "源码分析, framework",
    "date": "2019-05-18 00:00:00 +0800",
    "content": "Activity是我们平时用到最多的一个组件之一，它提供给用户一个可以交互的页面，通常启动一个Activity可以使用下面代码：  Intent intent = new Intent(this, DemoActivity.class); this.startActivity(intent);   可以看出代码很简洁，但是背后有着复杂的执行流程，这篇文章就介绍下Activity启动的执行过程和工作原理。  流程分析  Activity启动  我们先从Activity的startActivity说起：  // Activity.java @Override public void startActivity(Intent intent, @Nullable Bundle options) {     if (options != null) {         startActivityForResult(intent, -1, options);     } else {         // Note we want to go through this call for compatibility with         // applications that may have overridden the method.         startActivityForResult(intent, -1);     } } public void startActivityForResult(@RequiresPermission Intent intent, int requestCode) {     startActivityForResult(intent, requestCode, null); }   最终调用到了Activity的startActivityForResult方法，我们烂了看喜爱这个方法：  // Activity.java public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,                                    @Nullable Bundle options) {     if (mParent == null) {         options = transferSpringboardActivityOptions(options);         Instrumentation.ActivityResult ar =             mInstrumentation.execStartActivity(             this, mMainThread.getApplicationThread(), mToken, this,             intent, requestCode, options);         if (ar != null) {             mMainThread.sendActivityResult(                 mToken, mEmbeddedID, requestCode, ar.getResultCode(),                 ar.getResultData());         }         if (requestCode &gt;= 0) {             // If this start is requesting a result, we can avoid making             // the activity visible until the result is received.  Setting             // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the             // activity hidden during this time, to avoid flickering.             // This can only be done when a result is requested because             // that guarantees we will get information back when the             // activity is finished, no matter what happens to it.             mStartedActivity = true;         }          cancelInputsAndStartExitTransition(options);         // TODO Consider clearing/flushing other event sources and events for child windows.     } else {         if (options != null) {             mParent.startActivityFromChild(this, intent, requestCode, options);         } else {             // Note we want to go through this method for compatibility with             // existing applications that may have overridden it.             mParent.startActivityFromChild(this, intent, requestCode);         }     } }   这里调用了调用了mInstrumentation.execStartActivity方法，其中第一个参数mMainThread.getApplicationThread()，它返回的类型是ApplicationThread，ApplicationThread是ActivityThread的内部类，继承IApplicationThread.Stub，也是个Binder对象，用来实现进程间通信，具体来说就是AMS所在系统进程通知应用程序进程进行一系列操作，而mInstrumentation常用来跟踪Application和Activity生命周期，一般我们会在Android应用测试框架中看到它。  // Instrumentation.java public ActivityResult execStartActivity(     Context who, IBinder contextThread, IBinder token, Activity target,     Intent intent, int requestCode, Bundle options) {     IApplicationThread whoThread = (IApplicationThread) contextThread;     Uri referrer = target != null ? target.onProvideReferrer() : null;     if (referrer != null) {         intent.putExtra(Intent.EXTRA_REFERRER, referrer);     }     ...     try {         intent.migrateExtraStreamToClipData();         intent.prepareToLeaveProcess(who);         int result = ActivityManager.getService()             .startActivity(whoThread, who.getBasePackageName(), intent,                            intent.resolveTypeIfNeeded(who.getContentResolver()),                            token, target != null ? target.mEmbeddedID : null,                            requestCode, 0, null, options);         checkStartActivityResult(result, intent);     } catch (RemoteException e) {         throw new RuntimeException(\"Failure from system\", e);     }     return null; }   在 Instrumentation 中，会通过 ActivityManger.getService 获取 AMS 的实例，然后调用其 startActivity 方法  // ActivityManager.java @UnsupportedAppUsage public static IActivityManager getService() {     return IActivityManagerSingleton.get(); }  @UnsupportedAppUsage private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =     new Singleton&lt;IActivityManager&gt;() {     @Override     protected IActivityManager create() {         final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);         final IActivityManager am = IActivityManager.Stub.asInterface(b);         return am;     } };   从上面代码可以看出，这里获取一个跨进程的系统调用，返回一个binder实例，通过IActivityManager.Stub.asInterface方法返回一个AMS的代理对象，从而调用AMS 的startActivity方法。  而下面的checkStartActivityResult(result, intent)方法则是检查Activity启动结果：  @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023) public static void checkStartActivityResult(int res, Object intent) {     if (!ActivityManager.isStartResultFatalError(res)) {         return;     }      switch (res) {         case ActivityManager.START_INTENT_NOT_RESOLVED:         case ActivityManager.START_CLASS_NOT_FOUND:             if (intent instanceof Intent &amp;&amp; ((Intent)intent).getComponent() != null)                 throw new ActivityNotFoundException(                 \"Unable to find explicit activity class \"                 + ((Intent)intent).getComponent().toShortString()                 + \"; have you declared this activity in your AndroidManifest.xml?\");             throw new ActivityNotFoundException(                 \"No Activity found to handle \" + intent);         case ActivityManager.START_PERMISSION_DENIED:             throw new SecurityException(\"Not allowed to start activity \"                                         + intent);         case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:             throw new AndroidRuntimeException(                 \"FORWARD_RESULT_FLAG used while also requesting a result\");         case ActivityManager.START_NOT_ACTIVITY:             throw new IllegalArgumentException(                 \"PendingIntent is not an activity\");         case ActivityManager.START_NOT_VOICE_COMPATIBLE:             throw new SecurityException(                 \"Starting under voice control not allowed for: \" + intent);         case ActivityManager.START_VOICE_NOT_ACTIVE_SESSION:             throw new IllegalStateException(                 \"Session calling startVoiceActivity does not match active session\");         case ActivityManager.START_VOICE_HIDDEN_SESSION:             throw new IllegalStateException(                 \"Cannot start voice activity on a hidden session\");         case ActivityManager.START_ASSISTANT_NOT_ACTIVE_SESSION:             throw new IllegalStateException(                 \"Session calling startAssistantActivity does not match active session\");         case ActivityManager.START_ASSISTANT_HIDDEN_SESSION:             throw new IllegalStateException(                 \"Cannot start assistant activity on a hidden session\");         case ActivityManager.START_CANCELED:             throw new AndroidRuntimeException(\"Activity could not be started for \"                                               + intent);         default:             throw new AndroidRuntimeException(\"Unknown error code \"                                               + res + \" when starting \" + intent);     } }   里面比较熟悉的就是我们没有在清单文件注册Activity时报的错误：ActivityManager.START_CLASS_NOT_FOUND:  Unable to find explicit activity class XXX; have you declared this activity in your AndroidManifest.xml?  ActivityManagerService  接下来我们一起看下AMS的startActivity方法：  // ActivityManagerService.java @Override public final int startActivity(IApplicationThread caller, String callingPackage,                                Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,                                int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) {     return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,                                resultWho, requestCode, startFlags, profilerInfo, bOptions,                                UserHandle.getCallingUserId()); }  @Override public final int startActivityAsUser(IApplicationThread caller, String callingPackage,                                      Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,                                      int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {     return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,                                resultWho, requestCode, startFlags, profilerInfo, bOptions, userId,                                true /*validateIncomingUser*/); }  public final int startActivityAsUser(IApplicationThread caller, String callingPackage,                                      Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,                                      int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId,                                      boolean validateIncomingUser) {     enforceNotIsolatedCaller(\"startActivity\");      userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser,                                                       Binder.getCallingPid(), Binder.getCallingUid(), \"startActivityAsUser\");      // TODO: Switch to user app stacks here.     return mActivityStartController.obtainStarter(intent, \"startActivityAsUser\")         .setCaller(caller)         .setCallingPackage(callingPackage)         .setResolvedType(resolvedType)         .setResultTo(resultTo)         .setResultWho(resultWho)         .setRequestCode(requestCode)         .setStartFlags(startFlags)         .setProfilerInfo(profilerInfo)         .setActivityOptions(bOptions)         .setMayWait(userId)         .execute();  }   这里经过一系列调用，最终通过getActivityStartController().obtainStarter方法获取ActivityStarter实例，然后经过方法调用，最后执行execute启动Activity。  // ActivityStarter.java int execute() {     try {         // TODO(b/64750076): Look into passing request directly to these methods to allow         // for transactional diffs and preprocessing.         if (mRequest.mayWait) {             return startActivityMayWait(mRequest.caller, mRequest.callingUid,              mRequest.callingPackage, mRequest.intent, mRequest.resolvedType,              mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,              mRequest.resultWho, mRequest.requestCode, mRequest.startFlags,              mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig,              mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId,              mRequest.inTask, mRequest.reason,              mRequest.allowPendingRemoteAnimationRegistryLookup,              mRequest.originatingPendingIntent);         } else {             return startActivity(mRequest.caller, mRequest.intent, \t\t\t                mRequest.ephemeralIntent,                                  mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo,                                  mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,                                  mRequest.resultWho, mRequest.requestCode, mRequest.callingPid,                                  mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid,                                  mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions,                                  mRequest.ignoreTargetSecurity, mRequest.componentSpecified,                                  mRequest.outActivity, mRequest.inTask, mRequest.reason,                                  mRequest.allowPendingRemoteAnimationRegistryLookup,                                  mRequest.originatingPendingIntent);         }     } finally {         onExecutionComplete();     } }   分了两种情况，不过不论startActivityMayWait还是startActivity最终都是走到下面这个startActivity方法:  // ActivityStarter.java private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent,                           String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,                           IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,                           IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,                           String callingPackage, int realCallingPid, int realCallingUid, int startFlags,                           SafeActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,                           ActivityRecord[] outActivity, TaskRecord inTask, String reason,                           boolean allowPendingRemoteAnimationRegistryLookup,                           PendingIntentRecord originatingPendingIntent) {      if (TextUtils.isEmpty(reason)) {         throw new IllegalArgumentException(\"Need to specify a reason.\");     }     mLastStartReason = reason;     mLastStartActivityTimeMs = System.currentTimeMillis();     mLastStartActivityRecord[0] = null;      mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType,                                              aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode,                                              callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,                                              options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord,                                              inTask, allowPendingRemoteAnimationRegistryLookup, originatingPendingIntent);      if (outActivity != null) {         // mLastStartActivityRecord[0] is set in the call to startActivity above.         outActivity[0] = mLastStartActivityRecord[0];     }      return getExternalResult(mLastStartActivityResult); }   在这里调用了重载的startActivity方法，而最终会调用的 ActivityStarter 中的 startActivityUnchecked 方法来获取启动 Activity 的结果:  // ActivityStarter.java private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord,                           IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,                           int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,                           ActivityRecord[] outActivity) {     int result = START_CANCELED;     try {         mService.mWindowManager.deferSurfaceLayout();         result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,                                         startFlags, doResume, options, inTask, outActivity);     } finally {         // If we are not able to proceed, disassociate the activity from the task. Leaving an         // activity in an incomplete state can lead to issues, such as performing operations         // without a window container.         final ActivityStack stack = mStartActivity.getStack();         if (!ActivityManager.isStartResultSuccessful(result) &amp;&amp; stack != null) {             stack.finishActivityLocked(mStartActivity, RESULT_CANCELED,                                        null /* intentResultData */, \"startActivity\", true /* oomAdj */);         }         mService.mWindowManager.continueSurfaceLayout();     }      postStartActivityProcessing(r, result, mTargetStack);      return result; }   进入到startActivityUnchecked方法里：  // ActivityStarter.java private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,                                    IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,                                    int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,                                    ActivityRecord[] outActivity) { setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,                 voiceInteractor);      computeLaunchingTaskFlags();     computeSourceStack();     mIntent.setFlags(mLaunchFlags);     ActivityRecord reusedActivity = getReusableIntentActivity();          ...              mTargetStack.startActivityLocked(mStartActivity, topFocused, newTask, mKeepCurTransition,mOptions);     mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,                         mOptions); \t... }   上面方法最后会调用ActivityStack的resumeTopActivityUncheckedLocked方法：  // ActivityStack.java boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) {     if (mStackSupervisor.inResumeTopActivity) {         // Don't even start recursing.         return false;     }      boolean result = false;     try {         // Protect against recursion.         mStackSupervisor.inResumeTopActivity = true;         result = resumeTopActivityInnerLocked(prev, options);          // When resuming the top activity, it may be necessary to pause the top activity (for         // example, returning to the lock screen. We suppress the normal pause logic in         // {@link #resumeTopActivityUncheckedLocked}, since the top activity is resumed at the         // end. We call the {@link ActivityStackSupervisor#checkReadyForSleepLocked} again here         // to ensure any necessary pause logic occurs. In the case where the Activity will be         // shown regardless of the lock screen, the call to         // {@link ActivityStackSupervisor#checkReadyForSleepLocked} is skipped.         final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */);         if (next == null || !next.canTurnScreenOn()) {             checkReadyForSleep();         }     } finally {         mStackSupervisor.inResumeTopActivity = false;     }      return result; }   在上面方法里会执行resumeTopActivityInnerLocked(prev, options)方法：  // ActivityStack.java private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) {     ...              boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, false);     if (mResumedActivity != null) {         if (DEBUG_STATES) Slog.d(TAG_STATES,\"resumeTopActivityLocked: Pausing \" + mResumedActivity);         // 暂停上一个Activity         pausing |= startPausingLocked(userLeaving, false, next, false);     }          ...              if (next.app != null &amp;&amp; next.app.thread != null) {         ...          try {                          final ClientTransaction transaction = ClientTransaction.obtain(next.app.thread,                                                             next.appToken);             // Deliver all pending results.             ArrayList&lt;ResultInfo&gt; a = next.results;             if (a != null) {                 final int N = a.size();                 if (!next.finishing &amp;&amp; N &gt; 0) {                     if (DEBUG_RESULTS) Slog.v(TAG_RESULTS,                        \"Delivering results to \" + next + \": \" + a);                     transaction.addCallback(ActivityResultItem.obtain(a));                 }             }              if (next.newIntents != null) {                 transaction.addCallback(NewIntentItem.obtain(next.newIntents,                                                              false /* andPause */));             }              // Well the app will no longer be stopped.             // Clear app token stopped state in window manager if needed.             next.notifyAppResumed(next.stopped);             EventLog.writeEvent(EventLogTags.AM_RESUME_ACTIVITY, next.userId,                             System.identityHashCode(next), next.getTask().taskId,                             next.shortComponentName);              next.sleeping = false;             mService.getAppWarningsLocked().onResumeActivity(next);             mService.showAskCompatModeDialogLocked(next);             next.app.pendingUiClean = true;             next.app.forceProcessStateUpTo(mService.mTopProcessState);             next.clearOptionsLocked();             transaction.setLifecycleStateRequest(                 ResumeActivityItem.obtain(next.app.repProcState,                                           mService.isNextTransitionForward()));                          mService.getLifecycleManager().scheduleTransaction(transaction);     }  else {             ....             if (SHOW_APP_STARTING_PREVIEW) {             \t    // 冷启动时展示的白屏窗口                     next.showStartingWindow(null , false ,false);                 }             ...             mStackSupervisor.startSpecificActivityLocked(next, true, true);         }     }      }   上面流程先对上一个Activity暂停，再执行创建操作最终进入到ActivityStackSupervisor.startSpecificActivityLocked方法中，这里有一个地方需要注意下，就是在启动前先展示了一个白屏窗口。  // ActivityStackSupervisor.java void startSpecificActivityLocked(ActivityRecord r,             boolean andResume, boolean checkConfig) {     // Is this activity's application already running?     ProcessRecord app = mService.getProcessRecordLocked(r.processName,                                                         r.info.applicationInfo.uid, true);      if (app != null &amp;&amp; app.thread != null) {         try {             if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0                 || !\"android\".equals(r.info.packageName)) {                 // Don't add this if it is a platform component that is marked                 // to run in multiple processes, because this is actually                 // part of the framework so doesn't make sense to track as a                 // separate apk in the process.                 app.addPackage(r.info.packageName, r.info.applicationInfo.longVersionCode,                                mService.mProcessStats);             }             realStartActivityLocked(r, app, andResume, checkConfig);             return;         } catch (RemoteException e) {             Slog.w(TAG, \"Exception when starting activity \"                    + r.intent.getComponent().flattenToShortString(), e);         }          // If a dead object exception was thrown -- fall through to         // restart the application.     }      mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,                                 \"activity\", r.intent.getComponent(), false, false, true); }    在上面这个方法中调用了realStartActivityLocked方法:  // ActivityStackSupervisor.java final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,                                       boolean andResume, boolean checkConfig) throws RemoteException { \t...              // Create activity launch transaction.         final ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread,                                                                              r.appToken);     clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),                                                             System.identityHashCode(r), r.info,                                                             // TODO: Have this take the merged configuration instead of separate global                                                             // and override configs.                                                             mergedConfiguration.getGlobalConfiguration(),                                                             mergedConfiguration.getOverrideConfiguration(), r.compat,                                                             r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,                                                             r.persistentState, results, newIntents, mService.isNextTransitionForward(),                                                             profilerInfo));      // Set desired final state.     final ActivityLifecycleItem lifecycleItem;     if (andResume) {         lifecycleItem = ResumeActivityItem.obtain(mService.isNextTransitionForward());     } else {         lifecycleItem = PauseActivityItem.obtain();     }     clientTransaction.setLifecycleStateRequest(lifecycleItem);      // Schedule transaction.     mService.getLifecycleManager().scheduleTranssaction(clientTransaction);          ... }   上面方法中创建了Activity启动事务，并传入 app.thread 参数，它是 ApplicationThread 类型。在上文 startActivity 阶段已经提过 ApplicationThread 是为了实现进程间通信的，是 ActivityThread 的一个内部类。  我们看下obtain方法：  // ClientTransaction.java public static ClientTransaction obtain(IApplicationThread client, IBinder activityToken) {     ClientTransaction instance = ObjectPool.obtain(ClientTransaction.class);     if (instance == null) {         instance = new ClientTransaction();     }          // 在这里把IApplicationThread 赋值给了mClient成员变量     instance.mClient = client;     instance.mActivityToken = activityToken;      return instance; }   而ClientTransaction是包含一系列的待客户端处理的事务的容器，客户端接收后取出事务并执行。  紧接着使用clientTransaction.addCallback添加了LaunchActivityItem实例：  // ClientTransaction.java private List&lt;ClientTransactionItem&gt; mActivityCallbacks; ... public void addCallback(ClientTransactionItem activityCallback) {     if (mActivityCallbacks == null) {         mActivityCallbacks = new ArrayList&lt;&gt;();     }     mActivityCallbacks.add(activityCallback); }   LaunchActivityItem实例的获取：  // LaunchActivityItem.java /** Obtain an instance initialized with provided params. */ public static LaunchActivityItem obtain(Intent intent, int ident, ActivityInfo info,                                         Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo,                                         String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state,                                         PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults,                                         List&lt;ReferrerIntent&gt; pendingNewIntents, boolean isForward, ProfilerInfo profilerInfo) {     LaunchActivityItem instance = ObjectPool.obtain(LaunchActivityItem.class);     if (instance == null) {         instance = new LaunchActivityItem();     }     setValues(instance, intent, ident, info, curConfig, overrideConfig, compatInfo, referrer,               voiceInteractor, procState, state, persistentState, pendingResults,               pendingNewIntents, isForward, profilerInfo);      return instance; }   最后调用了mService.getLifecycleManager().scheduleTransaction(clientTransaction)，其中mService是ActivityManagerService，getLifecycleManager()方法获取的是ClientLifecycleManager实例：  // ClientLifecycleManager.java void scheduleTransaction(ClientTransaction transaction) throws RemoteException {     final IApplicationThread client = transaction.getClient();     transaction.schedule();     if (!(client instanceof Binder)) {         // If client is not an instance of Binder - it's a remote call and at this point it is         // safe to recycle the object. All objects used for local calls will be recycled after         // the transaction is executed on client in ActivityThread.         transaction.recycle();     } }   上面就是调用ClientTransaction的schedule方法：  // ClientTransaction.java public void schedule() throws RemoteException {     mClient.scheduleTransaction(this); }   这里的mClient就是上面被赋值的IApplicationThread对象，然后调用IApplicationThread的scheduleTransaction方法。由于IApplicationThread是ApplicationThread所在系统进程的代理，所以真正执行的地方就是 客户端的ApplicationThread中了。所以到这里startActivity操作又从AMS转移到了应用进程ApplicationThread中。  ApplicationThread  接着分析scheduleTransaction方法，ApplicationThread是ActivityThread的一个内部类  private class ApplicationThread extends IApplicationThread.Stub {     @Override     public void scheduleTransaction(ClientTransaction transaction) throws RemoteException {         ActivityThread.this.scheduleTransaction(transaction);     } }   可以看出，这里还是调用了ActivityThread 的 scheduleTransaction 方法。但是这个方法实际上是在 ActivityThread 的父类 ClientTransactionHandler 中实现：  // ClientTransactionHandler.java void scheduleTransaction(ClientTransaction transaction) {     transaction.preExecute(this);     sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction); }   调用 sendMessage 方法，向 Handler 中发送了一个 EXECUTE_TRANSACTION 的消息，并且 Message 中的 obj 就是启动 Activity 的事务对象。而这个 Handler 的具体实现是 ActivityThread 中的 mH 对象：  // ActivityThread.java class H extends Handler {          public void handleMessage(Message msg) {     \t...                      case EXECUTE_TRANSACTION:         final ClientTransaction transaction = (ClientTransaction) msg.obj;         mTransactionExecutor.execute(transaction);         if (isSystem()) {             // Client transactions inside system process are recycled on the client side             // instead of ClientLifecycleManager to avoid being cleared before this             // message is handled.             transaction.recycle();         }        } }   最终调用了事务的 execute 方法，execute 方法如下：  // TransactionExecutor.java public void execute(ClientTransaction transaction) {     final IBinder token = transaction.getActivityToken();     log(\"Start resolving transaction for client: \" + mTransactionHandler + \", token: \" + token);      executeCallbacks(transaction);      executeLifecycleState(transaction);     mPendingActions.clear();     log(\"End resolving transaction\"); }   接着看下executeCallbacks方法：  // TransactionExecutor.java public void executeCallbacks(ClientTransaction transaction) {     final List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks();     if (callbacks == null) {         // No callbacks to execute, return early.         return;     }     log(\"Resolving callbacks\");      final IBinder token = transaction.getActivityToken();     ActivityClientRecord r = mTransactionHandler.getActivityClient(token);      // In case when post-execution state of the last callback matches the final state requested     // for the activity in this transaction, we won't do the last transition here and do it when     // moving to final state instead (because it may contain additional parameters from server).     final ActivityLifecycleItem finalStateRequest = transaction.getLifecycleStateRequest();     final int finalState = finalStateRequest != null ? finalStateRequest.getTargetState()         : UNDEFINED;     // Index of the last callback that requests some post-execution state.     final int lastCallbackRequestingState = lastCallbackRequestingState(transaction);      final int size = callbacks.size();     for (int i = 0; i &lt; size; ++i) {         final ClientTransactionItem item = callbacks.get(i);         log(\"Resolving callback: \" + item);         final int postExecutionState = item.getPostExecutionState();         final int closestPreExecutionState = mHelper.getClosestPreExecutionState(r,                                                                                  item.getPostExecutionState());         if (closestPreExecutionState != UNDEFINED) {             cycleToPath(r, closestPreExecutionState);         }          item.execute(mTransactionHandler, token, mPendingActions);         item.postExecute(mTransactionHandler, token, mPendingActions);         if (r == null) {             // Launch activity request will create an activity record.             r = mTransactionHandler.getActivityClient(token);         }          if (postExecutionState != UNDEFINED &amp;&amp; r != null) {             // Skip the very last transition and perform it by explicit state request instead.             final boolean shouldExcludeLastTransition =                 i == lastCallbackRequestingState &amp;&amp; finalState == postExecutionState;             cycleToPath(r, postExecutionState, shouldExcludeLastTransition);         }     } }   在这个方法里，遍历事务中的callback，执行了item.execute(mTransactionHandler, token, mPendingActions)方法，这里的item也就是上面通过ClientTransaction.obtain方法获取到ClientTransaction对象后，添加的LaunchActivityItem对象。所以看下LaunchActivityItem的execute方法：  // LaunchActivityItem.java @Override public void execute(ClientTransactionHandler client, IBinder token,                     PendingTransactionActions pendingActions) {     Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, \"activityStart\");     ActivityClientRecord r = new ActivityClientRecord(token, mIntent, mIdent, mInfo,                                                       mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,                                                       mPendingResults, mPendingNewIntents, mIsForward,                                                       mProfilerInfo, client);     client.handleLaunchActivity(r, pendingActions, null /* customIntent */);     Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER); }   在该方法中执行了ClientTransactionHandler的handleLaunchActivity方法，其实现类就是ActivityThread，因此最终又回到了ActivityThread类。  ActivityThread  我们进入到handleLaunchActivity方法：  // ActivityThread.java @Override public Activity handleLaunchActivity(ActivityClientRecord r,                                      PendingTransactionActions pendingActions, Intent customIntent) {     ...         WindowManagerGlobal.initialize();      final Activity a = performLaunchActivity(r, customIntent);      ...         return a; }   这里初始化了WindowManager，即每一个Activity都会对应一个窗口，并调用了performLaunchActivity方法：  // ActivityThread.java private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {  \t...     // 创建Context的实现ContextImpl上下文对象     ContextImpl appContext = createBaseContextForActivity(r);     Activity activity = null;     try {         java.lang.ClassLoader cl = appContext.getClassLoader();         // 创建Activity对象         activity = mInstrumentation.newActivity(             cl, component.getClassName(), r.intent);         StrictMode.incrementExpectedActivityCount(activity.getClass());         r.intent.setExtrasClassLoader(cl);         r.intent.prepareToEnterProcess();         if (r.state != null) {             r.state.setClassLoader(cl);         }     } catch (Exception e) {         if (!mInstrumentation.onException(activity, e)) {             throw new RuntimeException(                 \"Unable to instantiate activity \" + component                 + \": \" + e.toString(), e);         }     }          ...     // 创建Application对象     Application app = r.packageInfo.makeApplication(false, mInstrumentation);          Window window = null;     if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) {         window = r.mPendingRemoveWindow;         r.mPendingRemoveWindow = null;         r.mPendingRemoveWindowManager = null;     }     appContext.setOuterContext(activity);     // 为activity关联上下文环境     activity.attach(appContext, this, getInstrumentation(), r.token,                     r.ident, app, r.intent, r.activityInfo, title, r.parent,                     r.embeddedID, r.lastNonConfigurationInstances, config,                     r.referrer, r.voiceInteractor, window, r.configCallback);     ...     // 调用生命周期onCreate     if (r.isPersistable()) {         mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);     } else {         mInstrumentation.callActivityOnCreate(activity, r.state);     } }    上面代码通过反射常见目标Activity对象，紧接着通过activity的attach方法，建立了Activity与Context的联系，并且创建了PhoneWindow对象，最后通过Instrumentation的callActivityOnCreate调用Activity的onCreate方法：  // Instrumentation.java public void callActivityOnCreate(Activity activity, Bundle icicle,                                  PersistableBundle persistentState) {     prePerformCreate(activity);     activity.performCreate(icicle, persistentState);     postPerformCreate(activity); }   // Activity.java final void performCreate(Bundle icicle, PersistableBundle persistentState) {     mCanEnterPictureInPicture = true;     restoreHasCurrentPermissionRequest(icicle);     if (persistentState != null) {         onCreate(icicle, persistentState);     } else {         onCreate(icicle);     }     writeEventLog(LOG_AM_ON_CREATE_CALLED, \"performCreate\");     mActivityTransitionState.readState(icicle);      mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(         com.android.internal.R.styleable.Window_windowNoDisplay, false);     mFragments.dispatchActivityCreated();     mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions()); }   至此，目标Activity已经被创建成功并执行生命周期方法。  onResume  上面方法执行到了onCreate方法，那么接下来会跟进onStart、onResume方法：其实这里有几个类：          LaunchActivityItem 远程App端的onCreate生命周期事务           ResumeActivityItem 远程App端的onResume生命周期事务           PauseActivityItem 远程App端的onPause生命周期事务           StopActivityItem 远程App端的onStop生命周期事务           DestroyActivityItem 远程App端onDestroy生命周期事务      还记得上面ActivityStackSupervisor的realStartActivityLocked方法：  // ActivityStackSupervisor.java final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,                                       boolean andResume, boolean checkConfig) throws RemoteException { \t...              // Create activity launch transaction.         final ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread,                                                                              r.appToken);     clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),                                                             System.identityHashCode(r), r.info,                                                             // TODO: Have this take the merged configuration instead of separate global                                                             // and override configs.                                                             mergedConfiguration.getGlobalConfiguration(),                                                             mergedConfiguration.getOverrideConfiguration(), r.compat,                                                             r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,                                                             r.persistentState, results, newIntents, mService.isNextTransitionForward(),                                                             profilerInfo));      // Set desired final state.     final ActivityLifecycleItem lifecycleItem;     // 返回ResumeActivityItem实例     if (andResume) {         lifecycleItem = ResumeActivityItem.obtain(mService.isNextTransitionForward());     } else {         lifecycleItem = PauseActivityItem.obtain();     }     clientTransaction.setLifecycleStateRequest(lifecycleItem);      // Schedule transaction.     mService.getLifecycleManager().scheduleTranssaction(clientTransaction);          ... }   在上面的clientTransaction.setLifecycleStateRequest(lifecycleItem)方法中，lifecycleItem是ResumeActivityItem或PauseActivityItem实例，这里我们关注ResumeActivityItem，先看下setLifecycleStateRequest方法：  // ClientTransaction.java public void setLifecycleStateRequest(ActivityLifecycleItem stateRequest) {     mLifecycleStateRequest = stateRequest; }   mLifecycleStateRequest表示执行transaction后的最终的生命周期状态。继续看处理ActivityThread.H.EXECUTE_TRANSACTION这个消息的处理，即TransactionExecutor的execute方法：  // TransactionExecutor.java public void execute(ClientTransaction transaction) {     final IBinder token = transaction.getActivityToken();     log(\"Start resolving transaction for client: \" + mTransactionHandler + \", token: \" + token);      executeCallbacks(transaction);      executeLifecycleState(transaction);     mPendingActions.clear();     log(\"End resolving transaction\"); }   进入到executeLifecycleState方法中：  // TransactionExecutor.java private void executeLifecycleState(ClientTransaction transaction) {     final ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();     if (lifecycleItem == null) {         // No lifecycle request, return early.         return;     }     log(\"Resolving lifecycle state: \" + lifecycleItem);      final IBinder token = transaction.getActivityToken();     final ActivityClientRecord r = mTransactionHandler.getActivityClient(token);      if (r == null) {         // Ignore requests for non-existent client records for now.         return;     }      // Cycle to the state right before the final requested state.     cycleToPath(r, lifecycleItem.getTargetState(), true /* excludeLastState */);      // Execute the final transition with proper parameters.     lifecycleItem.execute(mTransactionHandler, token, mPendingActions);     lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions); }    最终取到了ActivityLifecycleItem对象，即上面的ResumeActivityItem 对象，然后执行其execute方法：  // ResumeActivityItem.java @Override public void execute(ClientTransactionHandler client, IBinder token,                     PendingTransactionActions pendingActions) {     Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, \"activityResume\");     client.handleResumeActivity(token, true /* finalStateRequest */, mIsForward,                                 \"RESUME_ACTIVITY\");     Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER); }   和上面类似，这里其实又调用了ActivityThread的handleResumeActivity方法：  // ActivityThread.java public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,String reason) {     ...     // TODO Push resumeArgs into the activity for consideration     // 这里会执行onStart 、 onResume方法     final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);     ...     if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) {         r.window = r.activity.getWindow();         View decor = r.window.getDecorView();         decor.setVisibility(View.INVISIBLE);         ViewManager wm = a.getWindowManager();         WindowManager.LayoutParams l = r.window.getAttributes();         a.mDecor = decor;         l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;         l.softInputMode |= forwardBit;         if (r.mPreserveWindow) {             a.mWindowAdded = true;             r.mPreserveWindow = false;             // Normally the ViewRoot sets up callbacks with the Activity             // in addView-&gt;ViewRootImpl#setView. If we are instead reusing             // the decor view we have to notify the view root that the             // callbacks may have changed.             ViewRootImpl impl = decor.getViewRootImpl();             if (impl != null) {                 impl.notifyChildRebuilt();             }         }         if (a.mVisibleFromClient) {             if (!a.mWindowAdded) {                 a.mWindowAdded = true;                 wm.addView(decor, l);             } else {                 // The activity will get a callback for this {@link LayoutParams} change                 // earlier. However, at that time the decor will not be set (this is set                 // in this method), so no action will be taken. This call ensures the                 // callback occurs with the decor set.                 a.onWindowAttributesChanged(l);             }         }          // If the window has already been added, but during resume         // we started another activity, then don't yet make the         // window visible.     } else if (!willBeVisible) {         if (localLOGV) Slog.v(TAG, \"Launch \" + r + \" mStartedActivity set\");         r.hideForNow = true;     }          ...              if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) {         if (r.newConfig != null) {             performConfigurationChangedForActivity(r, r.newConfig);             if (DEBUG_CONFIGURATION) {                 Slog.v(TAG, \"Resuming activity \" + r.activityInfo.name + \" with newConfig \"                        + r.activity.mCurrentConfig);             }             r.newConfig = null;         }         if (localLOGV) Slog.v(TAG, \"Resuming \" + r + \" with isForward=\" + isForward);         WindowManager.LayoutParams l = r.window.getAttributes();         if ((l.softInputMode              &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)             != forwardBit) {             l.softInputMode = (l.softInputMode                                &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))                 | forwardBit;             if (r.activity.mVisibleFromClient) {                 ViewManager wm = a.getWindowManager();                 View decor = r.window.getDecorView();                 wm.updateViewLayout(decor, l);             }         }          r.activity.mVisibleFromServer = true;         mNumVisibleActivities++;         if (r.activity.mVisibleFromClient) {             // 添加window并设置为可见             r.activity.makeVisible();         }     } }   上面我们看下r.activity.makeVisible()方法：  // Activity.java void makeVisible() {     if (!mWindowAdded) {         ViewManager wm = getWindowManager();         wm.addView(mDecor, getWindow().getAttributes());         mWindowAdded = true;     }     mDecor.setVisibility(View.VISIBLE); }    这里把Activity的顶级布局mDecor通过windowManager的addView方法，添加到window，并设置mDecor可见，所以到这里，我们的视图才是真正可见了，即onResume方法调用后。另外Activity视图渲染到Window后，会设置window焦点变化，先走到DecorView的onWindowFocusChanged方法，最后是到Activity的onWindowFocusChanged方法，表示首帧绘制完成，此时Activity可交互。  接着我们看下performResumeActivity方法：  // ActivityThread.java public ActivityClientRecord performResumeActivity(IBinder token, boolean finalStateRequest,                                                   String reason) {     final ActivityClientRecord r = mActivities.get(token);          ...              r.activity.performResume(r.startsNotResumed, reason);     ... }   内部执行了Activity的performResume方法：  final void performResume(boolean followedByPause, String reason) {     performRestart(true /* start */, reason);      ...     // mResumed is set by the instrumentation     mInstrumentation.callActivityOnResume(this);     ... }   这里先调用了performRestart()，performRestart()又会调用performStart()，performStart()内部调用了mInstrumentation.callActivityOnStart(this)，也就是Activity的onStart()方法了。  然后是mInstrumentation.callActivityOnResume，即调用Activity的onResume()方法了，到这里启动后的生命周期走完了。  总结  最后我们把这一启动过程用图梳理出来：    涉及的类：                 类       作用                       ActivityThread       应用的入口类，系统通过调用main函数，开启消息循环队列。ActivityThread所在线程被称为应用的主线程（UI线程）                 ApplicationThread       是ActivityThread的内部类，继承IApplicationThread.Stub，是一个IBinder，是ActiivtyThread和AMS通信的桥梁，AMS则通过代理调用此App进程的本地方法，运行在Binder线程池                 H       继承Handler，在ActivityThread中初始化，即主线程Handler，用于主线程所有消息的处理。本片中主要用于把消息从Binder线程池切换到主线程                 Intrumentation       追踪application及activity生命周期的功能，用于监控app和系统的交互                 ActivityManagerService       Android中最核心的服务之一，负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在Android中非常重要，它本身也是一个Binder的实现类。                 ActivityStarter       用于解释如何启动Activity。该类收集所有逻辑，用于确定Intent和flag应如何转换为Activity以及相关的任务和堆栈                 ActivityStack       用来管理系统所有的Activity，内部维护了Activity的所有状态和Activity相关的列表等数据                 ActivityStackSupervisor       负责所有Activity栈的管理。AMS的stack管理主要有三个类，ActivityStackSupervisor，ActivityStack和TaskRecord                 ClientLifecycleManager       客户端生命周期执行请求管理                 ClientTransaction       是包含一系列的 待客户端处理的事务 的容器，客户端接收后取出事务并执行                 LaunchActivityItem       继承ClientTransactionItem，客户端要执行的事务信息，启动activity                 ResumeActivityItem       继承ClientTransactionItem，客户端要执行的事务信息，启动activity"
  },
  
  {
    "title": "Java同步实现原理与锁优化",
    "url": "/posts/java-lock/",
    "categories": "Java",
    "tags": "多线程",
    "date": "2019-05-07 00:00:00 +0800",
    "content": "我们知道，Java中通过synchronized关键字来实现同步，而同步的基础：Java中每一个对象都可以作为锁，表现在以下3个方面：     对于普通同步方法，锁是当前实例对象。   对于静态同步方法，锁是当前类的Class对象。   对于同步方法块，锁是Synchonized括号里配置的对象。   当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。  synchronized实现原理  synchronized是基于monitor来实现的，也就是我们常说的监视器，在说它之前，我们先了解下对象头，对象在内存中的布局分为3部分：     对象头：Java对象头一般占用2个字宽，但是如果对象是数组类型，则需要3个字宽，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。（1字宽在32位虚拟机中表示4个字节，也就是32bit，在64位虚拟机中表示8个字节，也就是64位）。   实例数据：存放类的属性数据信息，包括父类的属性信息。   对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。   当我们在Java代码中，使用new关键字创建一个对象时，JVM会再堆中创建一个instanceOopDesc对象，这个对象中包含了对象头和实例数据，而instanceOopDesc的积累oopDesc结构如下：  class oopDesc {     friend class VMStructs;     private:     \tvolative markOop _mark;         union _metadata { \t\t\twideKlassOop _klass; \t\t\tnarrowOop _compressed_klass;         } _metadata }   其中上面代码中_mark和_metadata一起组成了对象头。这里重点介绍_mark_属性，_mark 是 markOop 类型数据，一般称它为标记字段（Mark Word），其中主要存储了对象的 hashCode、分代年龄、锁标志位，是否偏向锁等。它的存储结构如下：                 锁状态       25bit       4bit       1bit是否是偏向锁       2bit锁标志位                       无锁状态       对象的hashcode       对象分代年龄       0       01           默认情况下，没有线程进行加锁操作，所以锁对象中的 Mark Word 处于无锁状态。但是考虑到 JVM 的空间效率，Mark Word 被设计成为一个非固定的数据结构，以便存储更多的有效数据，它会根据对象本身的状态复用自己的存储空间，如 32 位 JVM 下，除了上述列出的 Mark Word 默认存储结构外，还有如下可能变化的结构：    从图中可以看出，根据”锁标志位”以及”是否为偏向锁”，Java 中的锁可以分为以下几种状态：                 是否偏向锁       锁标志位       锁状态                       0       01       无锁                 1       01       偏向锁                 0       00       轻量级锁                 0       10       重量级锁                 0       11       GC标记           在 Java 6 之前，并没有轻量级锁和偏向锁，只有重量级锁，也就是通常所说 synchronized 的对象锁，锁标志位为 10。从图中的描述可以看出：当锁是重量级锁时，对象头中 Mark Word 会用 30 bit 来指向一个“互斥量”，而这个互斥量就是 Monitor。  在Java虚拟机中，ObjectMonitor是Monitor的具体实现，因此Java中的每一个对象都有一个对应的ObjectMonitor，这也是Java中所有对象都可以作为锁的原因。  ObjectMonitor类中有几个比较重要的属性：     _owner：指向持有ObjectMonitor对象的线程   _WaitSet：存放处于wait状态的线程队列   _EntryList：存放处于等待锁block状态的线程队列   _recursions：锁的重入次数   _count：用来记录该线程获取锁的次数   当多个线程同时访问一段同步代码时，首先会进入 _EntryList 队列中，当某个线程通过竞争获取到对象的 monitor 后，monitor 会把 _owner 变量设置为当前线程，同时 monitor 中的计数器 _count 加 1，即获得对象锁。 若持有 monitor 的线程调用 wait() 方法，将释放当前持有的 monitor，_owner 变量恢复为 null， _count 自减 1，同时该线程进入 _WaitSet 集合中等待被唤醒。若当前线程执行完毕也将释放 monitor（锁）并复位变量的值，以便其他线程进入获取 monitor（锁）。  synchronized具体实现  1、同步代码块采用monitorenter、monitorexit指令显式的实现。  2、同步方法则使用ACC_SYNCHRONIZED标记符隐式的实现。  示例如下：  public class Test {     public synchronized void method1() {         System.out.println(\"synchronized method\");     }     public void method2() {         synchronized(this) {             System.out.println(\"synchronized block\");         }     } }   将上面代码采用javac编译成字节码指令后，使用javap -v查看字节码  public synchronized void method1();     descriptor: ()V     flags: (0x0021) ACC_PUBLIC, ACC_SYNCHRONIZED     Code:       stack=2, locals=1, args_size=1          0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;          3: ldc           #3                  // String synchronized method          5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V          8: return       LineNumberTable:         line 3: 0         line 4: 8              public void method2();     descriptor: ()V     flags: (0x0001) ACC_PUBLIC     Code:       stack=2, locals=3, args_size=1          0: aload_0          1: dup          2: astore_1          3: monitorenter          4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;          7: ldc           #5                  // String synchronized block          9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V         12: aload_1         13: monitorexit         14: goto          22         17: astore_2         18: aload_1         19: monitorexit         20: aload_2         21: athrow         22: return       Exception table:          from    to  target type              4    14    17   any             17    20    17   any       LineNumberTable:         line 6: 0         line 7: 4         line 8: 12         line 9: 22       StackMapTable: number_of_entries = 2         frame_type = 255 /* full_frame */           offset_delta = 17           locals = [ class Test, class java/lang/Object ]           stack = [ class java/lang/Throwable ]         frame_type = 250 /* chop */           offset_delta = 4 }   上面可以看出method1的flag多了一个ACC_SYNCHRONIZED标志，而method2方法在第22行、27行、31行，分别有1个monitorenter和2个monitorexit指令，而多出来的这个退出指令也是为了保证在异常时也能够正常释放锁。  每一个对象都有一个monitor，一个monitor只能被一个线程拥有。当一个线程执行到monitorenter指令时会尝试获取相应对象的monitor，获取规则如下：     如果monitor的进入数为0，则该线程可以进入monitor，并将monitor进入数设置为1，该线程即为monitor的拥有者。   如果当前线程已经拥有该monitor，只是重新进入，则进入monitor的进入数加1，所以synchronized关键字实现的锁是可重入的锁。   如果monitor已被其他线程拥有，则当前线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor。   只有拥有相应对象的monitor的线程才能执行monitorexit指令。每执行一次该指令monitor进入数减1，当进入数为0时当前线程释放monitor，此时其他阻塞的线程将可以尝试获取该monitor。  锁升级  JavaSE1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。此时锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级（膨胀）。  锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。  偏向锁  所谓偏向锁，就是锁会偏向于已经占有锁的线程，这种锁容易出现在没有竞争的情况下。在没有竞争的情况下，当第 1 个线程第一次访问同步块时，会先检测对象头 Mark Word 中的标志位（Tag）是否为 01，以此来判断此时对象锁是否处于无锁状态或者偏向锁状态（匿名偏向锁）。当获得锁的线程再次进入同步块时，不需要做同步处理。这也是锁默认的状态，线程一旦获取了这把锁，就会把自己的线程 ID 写到 Mark Word 中，在其他线程来获取这把锁之前，该线程都处于偏向锁状态。 JVM使用：-XX:+UseBiasedLocking参数启用偏向锁（1.6以后默认启用）。但是需要注意一点的是：在竞争激烈的场景下，开启偏向锁会增加系统的负担。 当下一个线程参与到偏向锁竞争时，会先判断 Mark Word 中保存的线程 ID 是否与这个线程 ID 相等，如果不相等，则会立即撤销偏向锁，升级为轻量级锁。  轻量级锁  当偏向锁失效时，线程间会竞争轻量级锁。参与竞争的每个线程，会在自己的线程栈中生成一个 Lock Record ( LR )，然后每个线程通过 CAS（自旋）的操作将锁对象头中的 Mark Word 设置为指向自己的 LR 指针，哪个线程设置成功，就意味着哪个线程获得锁，并将标志位（Tag）改为00。在这种情况下，JVM 不会依赖内核进行线程调度。若获取不到，自旋操作后，升级为重量级锁。  自旋锁  当线程竞争轻量级锁失败后，此时并不会立即在操作系统层面挂起，而是做一些空循环，也就是所谓的自旋锁。系统希望在自旋的过程中可以获得锁。如果若干次之后还未获得到，则进入阻塞状态，加重量级锁。所以说轻量级锁适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。  重量级锁  这里就是指上面锁竞争的最后一道关卡，进入了线程挂起的状态。此时如果获取不到锁，线程就会被挂起，进入到操作系统内核态，等待操作系统的调度，然后再映射回用户态。系统调用是昂贵的，重量级锁的名称也由此而来。  以上便是锁膨胀的过程  锁消除  锁消除相关联的一项技术就是基于Java对象的逃逸分析。就是分析某一个变量会不会在一个作用域外部引用。例如我们在方法内部的变量中，使用了StringBuffer sb处理了字符串。那么在实际的执行过程中，虚拟机会消除StringBuffer内部的同步控制，意思就是这个过程不需要加锁。还有一点需要注意的是String str = a + b; 这种字符串拼接代码，在JDK1.5以前会转化为StringBuffer的append()处理；在1.5及以后版本，会转化为StringBuilder的append()处理。  可以使用-XX:+DoEscapeAnalysis打开逃逸分析；使用-XX:+EliminateLocks打开锁消除。  锁优化  另外Java针对高并发场景的锁优化，做了很多实现。  减少锁的持有时间  比如避免给整个方法加锁，这个常见就是我们可以从同步方法调整为同步代码块，如下面从method1到method2的优化。  public class Test {     public synchronized void method1() {         // 其它代码         // 同步代码         // 其它代码     }     public void method2() {         // 其它代码         synchronized(this) {             // 其它代码         }         // 其它代码     } }   减小锁的粒度  将大对象，拆成小对象，大大增加并行度，降低锁竞争。如此一来偏向锁，轻量级锁成功率提高.。一个简单的例子就是 jdk 内置的 ConcurrentHashMap 与 SynchronizedMap。Collections.synchronizedMap 其本质是在读写 map 操作上都加了锁，在高并发下性能一般。ConcurrentHashMap 内部使用分区 Segment 来表示不同的部分,每个分区其实就是一个小的 hashtable，各自有自己的锁。  只要多个修改发生在不同的分区，他们就可以并发的进行。把一个整体分成了 16 个 Segment，最高支持 16 个线程并发修改。此外代码中还运用了很多 volatile 声明共享变量，第一时间获取修改的内容，性能较好。  读写分离锁替代独占锁  顾名思义，用 ReentrantReadWriteLock 将读写的锁分离开来，尤其在读多写少的场合，可以有效提升系统的并发能力。     读-读不互斥：读读之间不阻塞，因为读操作不影响多线程并发访问，不会造成脏数据，不一致等情况。   读-写互斥：读阻塞写，写也会阻塞读。   写-写互斥：写写阻塞。   锁分离  在读写锁的思想上做进一步的延伸，根据不同的功能拆分不同的锁，进行有效的锁分离。一个典型的示例便是 LinkedBlockingQueue，在它内部，take 和 put 操作本身是隔离的。有若干个元素的时候，一个在 queue 的头部操作，一个在 queue 的尾部操作，因此分别持有一把独立的锁。  锁粗化  通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短。  即在使用完公共资源后，应该立即释放锁。只有这样，等待在这个锁上的其他线程才能尽早的获得资源执行任务。  而凡事都有一个度，如果对同一个锁不停的进行请求同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化。  一个极端的例子如下，在一个循环中不停的请求同一个锁。  Object lock = new Object(); for(int i = 0; i &lt; 1000; i++){     synchronized(lock){      } } // 优化后 synchronized(lock){     for(int i = 0;i &lt; 1000; i++){      } }   锁粗化与减少锁的持有时间，两者是截然相反的，需要在实际应用中根据不同的场合权衡使用。  ThreadLocal  除了控制有限资源访问外，我们还可以增加资源来保证对象线程安全。  对于一些线程不安全的对象，例如 SimpleDateFormat，与其加锁让 100 个线程来竞争获取。  不如准备 100 个 SimpleDateFormat，每个线程各自为营，很快的完成 format 工作。  无锁/乐观锁/自旋锁  与锁相比，使用 CAS 操作，由于其非阻塞性，因此不存在死锁问题，同时线程之间的相互影响，也远小于锁的方式。自旋锁优点在于它避免一些线程的挂起和恢复操作，因为挂起线程和恢复线程都需要从用户态转入内核态，这个过程是比较慢的，所以通过自旋的方式可以一定程度上避免线程挂起和恢复所造成的性能开销。"
  },
  
  {
    "title": "Java内存模型JMM与多线程",
    "url": "/posts/java-jmm/",
    "categories": "Java",
    "tags": "JMM",
    "date": "2019-04-20 00:00:00 +0800",
    "content": "首先注意的是JMM（Java Memory Model）Java内存模型与JVM的内存结构不是一个概念，前者常和多线程相关。  缓存一致性  我们知道线程是CPU调度的最小单元，线程中的字节码指令最终都会在CPU中被执行，所以它免不了和各种数据打交道，而Java中所有的数据是存放在主内存（RAM）中的，随着CPU技术的发展，CPU的执行速度越来越快，但内存的技术并没有太大的变化，所以在内存中读取和写入数据的过程和CPU执行的速度比起来，差距越来越大，CPU对主存的访问需要等待较长时间，降低了CPU的执行效率。因此后来，为了弥补这个问题，在CPU中加入了高速缓存作为缓冲，在执行任务时，CPU会先将运算所需要使用到的数据复制到高速缓存中，让运算能够快速执行，当运算完成之后，再将缓存中的结果刷回到主内存，这样CPU就不用等待主内存的读写操作了。  然而，每个处理器都有自己的高速缓存，同时又操作同一块主存，当多个处理器同时操作主内存时，可能就会导致数据不一致，这就是缓存一致性问题。  指令重排  另外除了上面缓存一致性问题以外，处理器或者编译器为了提高运算效率，可能会对输入的字节码指令进行重新排序，也就是优化  int a = 1; int b = 2; a = a + 1;  // 多上面三行语句使用javap编译成字节码后： public static void main(java.lang.String[]);     descriptor: ([Ljava/lang/String;)V     flags: (0x0009) ACC_PUBLIC, ACC_STATIC     Code:       stack=2, locals=3, args_size=1          0: iconst_1          1: istore_1          2: iconst_2          3: istore_2          4: iload_1          5: iconst_1          6: iadd          7: istore_1          8: return        …… } // 优化后： 0: iconst_1 1: iconst_1 2: iadd 3: istore_1 4: iconst_2 5: istore_2  // 相当于： int a = 1; a = a + 1; int b = 2;            上面指令7 并不依赖指令2和指令3，这样CPU就会对其进行优化，也就是说，CPU或编译器指令的重排，可能对执行结果产生影响，最后导致在不同平台、硬件、操作系统输出结果不一致。  为了解决上面问题，Java虚拟机提出了一套机制——Java内存模型  JMM  内存模型是一套共享内存系统中多线程读写操作行为的规范，这套规范屏蔽了底层各种硬件和操作系统的内存访问差异，解决了 CPU 多级缓存、CPU 优化、指令重排等导致的内存访问问题，从而保证 Java 程序（尤其是多线程程序）在各种平台下对内存的访问效果一致。  JMM分为主内存和工作内存两种，其中工作内存是对CPU中寄存器或者高速缓存的抽象，而线程之间的共享变量存储在主内存，每个线程都有一个工作内存，本地工作内存存储了该线程读/写变量的副本。    Java中采用的共享内存的方式完成两个线程之间通信：     线程A把工作内存A中更新过的共享变量刷新到主内存中去。   线程B到主内存中去读取线程A之前已更新过的共享变量。   这样一来，就完成了线程A到线程B的通信。JMM通过主内存与每个线程工作内存的交互来为Java程序提供内存可见性保证。  为了支持 JMM，Java 定义了 8 种原子操作（Action），用来控制主存与工作内存之间的交互。          read（读取）作用于主内存，它把变量从主内存传动到线程的工作内存中，供后面的 load 动作使用。           load（载入）作用于工作内存，它把 read 操作的值放入到工作内存中的变量副本中。           store（存储）作用于工作内存，它把工作内存中的一个变量传送给主内存中，以备随后的 write 操作使用。           write （写入）作用于主内存，它把 store 传送值放到主内存中的变量中。           use（使用）作用于工作内存，它把工作内存中的值传递给执行引擎，每当虚拟机遇到一个需要使用这个变量的指令时，将会执行这个动作。           assign（赋值）作用于工作内存，它把从执行引擎获取的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的指令时，执行该操作。           lock（锁定）作用于主内存，把变量标记为线程独占状态。           unlock（解锁）作用于主内存，它将释放独占状态。            三大特征  原子性  原子性指的是一个操作是不可分割，不可中断的，一个线程在执行时不会被其他线程干扰。  JMM 保证了 read、load、assign、use、store 和 write 六个操作具有原子性，可以认为除了 long 和 double 类型以外，对其他基本数据类型所对应的内存单元的访问读写都是原子的。  如果要保证一个代码块的原子性，提供了monitorenter 和 moniterexit 两个字节码指令，也就是 synchronized 关键字。因此在 synchronized 块之间的操作都是原子性的。另外也可以用锁。  可见性  可见性是指当一个线程修改了共享变量的值，其他线程也能立即感知到这种变化。  Java是利用volatile关键字来提供可见性的。 当变量被volatile修饰时，这个变量被修改后会立刻刷新到主内存，当其它线程需要读取该变量时，会去主内存中读取新值。而普通变量则不能保证这一点。  除此之外，final和synchronized以及锁也能实现可见性。  synchronized以及锁是把更多个操作转化为原子化的过程，在执行完，进入unlock之前，必须将共享变量同步到主内存中。  final修饰的字段，一旦初始化完成，如果没有对象逸出（指对象为初始化完成就可以被别的线程使用），那么对于其他线程都是可见的。  有序性  文章开头提到过，除了多线程间无序性，还有一个造成无序的原因就是指令重排，而Java中，可以使用synchronized和锁或者volatile保证多线程之间操作的有序性。  synchronized和锁的原理是，一个线程lock之后，必须unlock后，其他线程才可以重新lock，使得被synchronized或者锁包住的代码块在多线程之间是串行执行的。  volatile关键字是使用内存屏障达到禁止指令重排序，以保证有序性。  内存屏障（Memory Barrier）用于控制在特定条件下的重排序和内存可见性问题。JMM 内存屏障可分为读屏障和写屏障，Java 的内存屏障实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。Java 编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。它分为这4类：     LoadLoad 屏障：对于这样的语句Load1，LoadLoad，Load2。在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。   StoreStore屏障：对于这样的语句Store1， StoreStore， Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。   LoadStore 屏障：对于这样的语句Load1， LoadStore，Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。   StoreLoad 屏障：对于这样的语句Store1， StoreLoad，Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。      在每个volatile读操作后插入LoadLoad屏障，在读操作后插入LoadStore屏障。        在每个volatile写操作的前面插入一个StoreStore屏障，后面插入一个StreLoad屏障。     指令重排序是 JVM 为了优化指令，来提高程序运行效率的，在不影响单线程程序执行结果的前提下，按照一定的规则进行指令优化。在某些情况下，这种优化会带来一些执行的逻辑问题，在并发执行的情况下，按照不同的逻辑会得到不同的结果。  这里JMM有一个非常重要的原则：happens-before 即先行发生原则  它用于描述两个操作的内存可见性，通过保证可见性的机制可以让应用程序免于数据竞争干扰。即如果一个操作 A happens-before 另一个操作 B，那么操作 A 的执行结果将对操作 B 可见。上述定义我们也可以反过来理解：如果操作 A 的结果需要对另外一个操作 B 可见，那么操作 A 必须 happens-before 操作 B。  JMM默认定义了一些符合先行发生原则的规则：     程序次序规则：一个线程内，按照代码顺序，写在前面的操作先行发生于写在后面的操作。   监视器锁定规则：unLock 操作先行发生于后面对同一个锁的 lock 操作。   volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作。   传递规则：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C。   线程启动规则：对线程 start() 的操作先行发生于线程内的任何操作。   线程中断规则：对线程 interrupt() 的调用先行发生于线程代码中检测到中断事件的发生，可以通过 Thread.interrupted() 方法检测是否发生中断。   线程终结规则：线程中的所有操作先行发生于检测到线程终止，可以通过 Thread.join()、Thread.isAlive() 的返回值检测线程是否已经终止。   对象终结规则：一个对象的初始化完成先行发生于它的 finalize() 方法的开始。   综上，JMM 可以说是 Java 并发的基础，它的定义将直接影响多线程实现的机制。而原子性、可见性、有序性这三大特征几乎贯穿了整个并发编程，对于后面起到铺垫作用。"
  },
  
  {
    "title": "JVM对象回收机制（下）",
    "url": "/posts/java-jvm-gc2/",
    "categories": "Java",
    "tags": "JVM",
    "date": "2019-04-16 00:00:00 +0800",
    "content": "我们知道当内存空间达到一定条件时，会自动触发。这个过程就叫作 GC，负责 GC 的组件，就叫作垃圾回收器。按照语义上面理解，垃圾回收首先需要找到的是这些垃圾，然后回收掉，但是GC过程正好相反，它是先找到活跃的对象，然后把其他不活跃的对象判定为垃圾，然后删除。所以垃圾回收只与活跃的对象有关，和堆的大小无关。  标记-清除算法  就像我们前面说的，GC过程正好相反：垃圾回收的第一步，就是找出活跃的对象，并将它们标记起来。根据GC Roots从上到下遍历所有可达对象，这个过程就叫做标记。  如上图所示，绿色代表GC Roots，蓝色代表可以被引用到的对象，灰色代表被回收的对象。但是这种方式有一个弊端就是会产生大量不连续的碎片，空间碎片太对可能会导致以后再程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次GC动作。  复制算法  将堆分为两个大小相同的空间 From 和 To， 利用 From 空间进行分配，当 From 空间满的时候，GC将其中的活动对象复制到 To 空间，之后将两个空间互换即完成GC。虽然解决了碎片问题，但是弊端也很明显，就是将内存缩小为了原来的一半，如果资源本身有限，这就是非常高的代价了。  标记-整理算法    它的主要思路就是，标记过程和标记-清除算法一样，但是到了整理阶段，它会移动所有存活的对象，且按照内存地址顺序依次排列，然后将末端内存地址以后的内存全部回收掉。这种算法虽然效率差一些，但是没有空间浪费，也没有产生碎片。  分代收集算法  综上，没有最优的算法，只有最合适的算法。分代收集没有新的思想，只是根据对象的存活周期的不同将内存划分为几块，一般把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法，在新生代中，每次垃圾收集时有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集，而老年代中因为对象存活率高，没有额外空间对他们进行分配担保，就必须使用标记-清理或者标记-整理算法进行回收。  新生代  综合上面，年轻代使用的垃圾回收算法是复制算法。因为年轻代发生 GC 后，只会有非常少的对象存活，复制这部分对象是非常高效的。我们前面也了解到复制算法会造成一定的空间浪费，所以年轻代中间也会分很多区域：一个伊甸园空间（Eden ），两个幸存者空间（Survivor ）  当新生代中的 Eden 区分配满的时候，就会触发新生代的 GC（Minor GC）。具体过程如下：     在 Eden 区执行了第一次 GC 之后，存活的对象会被移动到其中一个 Survivor 分区（以下简称from）；   Eden 区再次 GC，这时会采用复制算法，将 Eden 和 from 区一起清理。存活的对象会被复制到 to 区；接下来，只需要清空 from 区就可以了。   所以在这个过程中，总会有一个 Survivor 分区是空置的。Eden、from、to 的默认比例是 8:1:1，所以只会造成 10% 的空间浪费。  这个比例，是由参数 -XX:SurvivorRatio 进行配置的（默认为 8）。  老年代  结合上面，老年代一般使用“标记-清除”、“标记-整理”算法，因为老年代的对象存活率一般是比较高的，空间又比较大，拷贝起来并不划算，还不如采取就地收集的方式。  那么新生代对象如何进入老年代的呢？它们有这么几种：          大对象直接进入老年代      超出某个大小的对象将直接在老年代分配。这个值是通过参数 -XX:PretenureSizeThreshold 进行配置的。默认为 0，意思是全部首选 Eden 区进行分配。           长期存活的对象将进入老年代      新生代对象每当发生一次 Minor GC，存活下来的对象年龄都会加 1。直到达到一定的阈值，就会把这些“老顽固”给提升到老年代。这个阈值，可以通过参数 ‐XX:+MaxTenuringThreshold 进行配置，最大值是 15（默认）。      这些对象如果变的不可达，直到老年代发生 GC 的时候，才会被清理掉。           动态对象年龄判断      为了更好地适应不同程序的内存状况，虚拟机并不是永远的要求对象的年龄必须达到MaxTenuringThreshold才能提升到老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。           空间分配担保      上面新生代每次存活的对象，都会放入其中一个幸存区，这个区域默认的比例是 10%。但是我们无法保证每次存活的对象都小于 10%，当 Survivor 空间不够，就需要依赖其他内存（指老年代）进行分配担保。这个时候，对象也会直接在老年代上分配。"
  },
  
  {
    "title": "JVM对象回收机制（上）",
    "url": "/posts/java-jvm-gc1/",
    "categories": "Java",
    "tags": "JVM",
    "date": "2019-04-12 00:00:00 +0800",
    "content": "我们知道Java实例对象存储在堆中，等不用的时候，GC会回收它，但是GC是不受程序控制的，它会在满足条件时自动触发。那我们接下来就聊一聊这个条件。  在发生GC时，一个对象，JVM总能找到引用它的祖先，最后发现这个祖先已经被回收，那么它们就都会被清理掉，而能够躲过垃圾回收的那些祖先，我们管它叫GC Roots。  引用计数法  该方法是在对象头里面维护了一个计数器，每当该对象被引用1次，计数器+1，引用失效，则计数器-1，当计数器为0时，就会被认为无效。到那时这种方法有一个硬伤，就是针对循环引用，就处理不了了，所以现在主流的JVM都不采用这种方法了。  可达性分析法  这个算法的基本思路就是通过一系列被称为GC Roots的对象作为起始点，从这些节点开始往下搜索，搜索所走过的路径被称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连，即从GC Roots到这个对象不可达，则证明此对象是不可用的。    图中object4、object5、object6由于不能和GC Roots产生关系，所以发生GC时就会被回收。  GC Roots对象  在Java语言中，常常包含这几类对象：     虚拟机栈（栈帧中的局部变量表）中引用的对象   方法区中类静态属性引用的对象   方法区中常量引用的对象   本地方法栈中JNI (即所谓的Native方法)引用的对象   引用级别  如果说满足了上面的条件，即可以找到引用链的对象，就一定会存活吗？接下来要说的就是，其实判断对象的存活还与引用有关，Java对引用的概念进行了扩充，做了更细致的划分：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种。  强引用  强引用在我们代码中很常见，类似：String s = new String(\"s\")这类的引用都是强引用，只要引用还存在，垃圾收集器就永远不会回收被引用的对象。所以当内存不足时，JVM就会抛出OutOfMemoryError的错误。  软引用  软引用时用来描述一些还有用但是并非必需的对象，在内存足够的时候，软引用对象不会被回收，只有在内存不足的时候，系统则会回收这些引用对象，如果回收了仍然没有足够的内存，才会抛出内存溢出。  从上面可以看出，软引用非常适合做缓存技术。  软引用可以和一个引用队列(ReferenceQueue)联合使用。如果软引用所引用对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。  ReferenceQueue&lt;String&gt; referenceQueue = new ReferenceQueue&lt;&gt;(); String str = new String(\"yuxingxin\"); SoftReference&lt;String&gt; softReference = new SoftReference&lt;&gt;(str, referenceQueue);   我们有时候调用System.gc()方法只是起通知作用，JVM什么时候扫描回收对象是JVM根据自己的状态决定的，就算扫描到软引用对象也不一定回收它，只有内存不够的时候才回收。  当内存不足时，JVM首先会将软引用的对象置为null，然后通知垃圾回收机制进行回收。  也就是说，垃圾收集线程会在虚拟机抛出OutOfMemoryError之前回收软引用对象，而且虚拟机会尽可能优先回收长时间闲置不用的软引用对象。对那些刚构建的或刚使用过的“较新的”软引用对象会被虚拟机尽可能保留，这就是引入引用队列ReferenceQueue的原因。  弱引用  弱引用也是用来描述非必需对象的，但是它的强度会更弱一些，生命周期也更短。即当JVM进行垃圾回收时，无论内存是否足够，都会回收弱引用对象，它的应用场景和软引用类似，可以在一些对内存更加敏感的系统里采用，不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。  同样，弱引用可以和一个引用队列(ReferenceQueue)联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。  String str = new String(\"yuxingxin\"); WeakReference&lt;String&gt; weakReference = new WeakReference&lt;&gt;(str); // 弱引用转强引用 String strongReference = weakReference.get();   虚引用  顾名思义，形同虚设，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。它常用来跟踪对象被垃圾回收器回收的活动。  另外，它必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。  String str = new String(\"yuxingxin\"); ReferenceQueue queue = new ReferenceQueue(); // 创建虚引用，要求必须与一个引用队列关联 PhantomReference pr = new PhantomReference(str, queue);   程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要进行垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。  总结                 引用类型       被垃圾回收时间       用途场景       生命周期                       强引用       从来不会       对象的一般状态       JVM停止运行时终止                 软引用       当内存不足时       对象缓存       内存不足时终止                 弱引用       正常垃圾回收时       对象缓存       垃圾回收后终止                 虚引用       正常垃圾回收时       跟踪对象的垃圾回收       垃圾回收后终止           OOM发生区域对比：                 区域       是否线程私有       是否会发生OOM                       程序计数器       是       否                 Java虚拟机栈       是       是                 本地方法栈       是       是                 方法区       否       是                 堆       否       是                 直接内存       否       是"
  },
  
  {
    "title": "JVM类加载机制及类加载器",
    "url": "/posts/java-jvm-classloader/",
    "categories": "Java",
    "tags": "JVM",
    "date": "2019-04-08 00:00:00 +0800",
    "content": "类加载时机  我们都知道JVM通过加载.class文件，能够将其中的字节码解析成操作系统机器码。那么JVM加载时类的初始化是什么时候呢？大致有这么5种情况：     遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类没有进行过初始化，则需要先对其进行初始化。生成这四条指令的最常见的Java代码场景是：            使用new关键字实例化对象的时候；       读取或设置一个类的静态字段（被final修饰，已在编译器把结果放入常量池的静态字段除外）的时候；       调用一个类的静态方法的时候           使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。   当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。   当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。   当使用jdk1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。   对于这五种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：“有且只有”，这五种场景中的行为称为对一个类进行 主动引用。除此之外，所有引用类的方式，都不会触发初始化，称为 被动引用。  被动引用的场景举例：     通过子类引用父类的静态字段，并不会导致子类初始化，只有直接定义这个字段的类才会初始化（这里指父类）   通过数组定义来引用类，不会触发此类的初始化   常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义的常量的类的初始化。   类加载过程  JVM加载类的过程分为这么几个阶段：加载、验证、准备、解析、初始化。    加载  加载的主要作用是将外部的class文件，加载到方法区，我们可以从多个地方加载，比如Jar、War等Zip包，也可以从网络加载，或者通过动态代理技术等运行时计算生成等等  验证  这个阶段主要是为了安全验证文件是否符合JVM的规范要求，不符合规范的将抛出 java.lang.VerifyError 错误，主要包括这么几个阶段     文件格式验证   元数据验证   字节码验证   符号引用验证   准备  这一阶段主要是为类变量（static修饰的，不包括实例变量）分配内存并将其初始化为默认值。此时实例对象还没有分配内存，所以这些动作是在方法区上面进行的。而实例变量将会在对象实例化时随着对象一起分配在Java堆中。  public class TestMain {     static int x;     public static void main(String[] args) {         System.out.println(x);     } }  public class TestMain {     public static void main(String[] args) {         int x;  // 局部变量未初始化，编译报错         System.out.println(x);     } }    上面代码中，类变量有两次赋初始值的过程，一次在准备阶段，赋予初始值（也可以是指定值）；另外一次在初始化阶段，赋予程序员定义的值。所以可以编译通过。但是局部变量并没有在准备阶段给它赋初始值，所以编译不通过。  解析  该过程是将符号引用替换为直接引用的过程，符号引用是一种定义，可以是任何字面上的含义，而直接引用就是直接指向目标的指针、相对偏移量。后者的对象都存在于内存当中。大体可以分为这么几个部分：     类或者接口的解析   字段解析   类方法解析   接口方法解析   其中几个经常发生的异常，就与这个阶段有关。  java.lang.NoSuchFieldError 根据继承关系从下往上，找不到相关字段时的报错。  java.lang.IllegalAccessError 字段或者方法，访问权限不具备时的错误。  java.lang.NoSuchMethodError 找不到相关方法时的错误。  解析过程保证了相互引用的完整性，把继承与组合推进到运行时。  初始化  这是类加载过程的最后一步，主要是对成员变量进行初始化，在这一阶段，才开始执行类中定义的Java程序代码（或者叫字节码），从另一个角度来说，初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程，该方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的，编译器收集的顺序是由语句在源文件中的顺序锁决定的。静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。如下代码示例：  public class TestMain {     static int x = 0;     static {         x = 1;         y = 1;     }     static int y = 0;     public static void main(String[] args) {         System.out.println(x);   // 1         System.out.println(y);   // 0     } }   上面代码中x和y的区别就是他们相对于static静态代码块的位置。  这就引出一个规则：static 语句块，只能访问到定义在 static 语句块之前的变量。所以下面的代码是无法通过编译的。  static {     y++;  // 报错，非法向前引用 } static int y = 0;   第二个规则是：JVM 会保证在子类的初始化方法执行之前，父类的初始化方法已经执行完毕。所以第一个被执行的类初始化方法一定是java.lang.Object  上面&lt;clinit&gt;方法与类的构造函数（或者实例构造器&lt;init&gt;）不同，它不用显示调用父类构造器，虚拟机会保证在子类&lt;clinit&gt;方法执行之前，父类的&lt;clinit&gt;已经执行完毕，所以第二个规则也就可以理解了。  class TestMain {      static {         System.out.println(1);     }      TestMain() {         System.out.println(2);     }      public static class Child extends TestMain{         static {             System.out.println('x');         }         Child() {             System.out.println('y');         }     }        public static void main(String[] args) {         TestMain testMain = new Child();         TestMain testMain1 = new Child();     } }  // 上面示例输出顺序： // 1 // x // 2 // y // 2 // y   其中 static 字段和 static 代码块，是属于类的，在类的加载的初始化阶段就已经被执行。类信息会被存放在方法区，在同一个类加载器下，这些信息有一份就够了，所以上面的 static 代码块只会执行一次，它对应的是  方法。而对象初始化就不一样了。通常，我们在 new 一个新对象的时候，都会调用它的构造方法，就是 ，用来初始化对象的属性。每次新建对象的时候，都会执行。  类加载器  对于任意一个类，都需要由它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间，通俗点讲：比较两个类是否”相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那么这两个类也就不相等。          启动类加载器（Bootstrap ClassLoader）      主要用于加载/lib中的或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库。           扩展类加载器（Extension ClassLoader）      主要负责加载/lib/ext目录中的或者被java.ext.dirs系统变量所指定的路径中的所有类库。           应用程序类加载器（Application ClassLoader）      这是我们写Java类的默认加载器，一般也称作系统类加载器，它负责加载用户类路径所指定的类库，如果应用程序中没有定义过自己的类加载器，就由它加载。           自定义加载器（Custom ClassLoader）      支持一些个性化的扩展功能。      双亲委派机制  它的工作过程是：如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传递到顶层的启动类加载器中，只有当父类加载器自己无法完成这个加载请求，子加载器才会尝试自己去加载。    这一点我们可以通过JDK源代码看出  // ClassLoader.java protected Class&lt;?&gt; loadClass(String name, boolean resolve)     throws ClassNotFoundException     {         synchronized (getClassLoadingLock(name)) {             // First, check if the class has already been loaded             Class&lt;?&gt; c = findLoadedClass(name);             if (c == null) {                 long t0 = System.nanoTime();                 try {                     if (parent != null) {                         c = parent.loadClass(name, false); // 先有父类加载器加载                     } else {                         c = findBootstrapClassOrNull(name);                     }                 } catch (ClassNotFoundException e) {                     // ClassNotFoundException thrown if class not found                     // from the non-null parent class loader                 }                  if (c == null) {  // 再由子类加载器加载                     // If still not found, then invoke findClass in order                     // to find the class.                     long t1 = System.nanoTime();                     c = findClass(name);                      // this is the defining class loader; record the stats                     sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                     sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                     sun.misc.PerfCounter.getFindClasses().increment();                 }             }             if (resolve) {                 resolveClass(c);             }             return c;         }     }    上面代码中，它首先使用parent尝试进行类加载，如果失败后，才轮到自己，同时我们也发现这个方法是可以被覆盖的，也就是说双亲委派机制是可以不生效。  这个模型的好处在于 Java 类有了一种优先级的层次划分关系。比如 Object 类，这个毫无疑问应该交给最上层的加载器进行加载，即使是你覆盖了它，最终也是由系统默认的加载器进行加载的。  那试想一个问题，为什么设计成先由应用程序类加载器加载类，这样岂不是更省事？为什么不直接由启动类加载器加载，而是选择从下往上，往返两次？  在生产应用中，95%的类其实都是由应用类加载器加载的，如果类已经被加载过一次，就会被保存在应用类加载器中，下次使用可直接从应用类加载器中获取。但是如果由启动类加载器加载，大部分的类的获取都要走一个 启动类加载器 &gt; 扩展类加载器 &gt; 应用类加载器的过程，下次使用时也要走一遍上述过程，效率显然比直接从应用类加载器中获取要慢不少，所以为了后续调用节省时间，宁可第一次加载浪费点时间，也要选择应用程序类加载器。  第二个问题，如何打破双亲委派机制呢？  这就需要我们在自定义类加载器时重写ClassLoader中的loadClass方法，试看下面代码：  protected Class&lt;?&gt; loadClass(String name, boolean resolve)                 throws ClassNotFoundException         {             synchronized (getClassLoadingLock(name)) {                 // First, check if the class has already been loaded                 Class&lt;?&gt; c = findLoadedClass(name);                 if (c == null) {                     long t0 = System.nanoTime();                       if (c == null) {                         long t1 = System.nanoTime();                         //如果不是这个包下的类,比如Object，使用 自定义类加载器的父类加载器 即应用类加载器，双亲委派                         if(!name.startsWith(\"com.yuxingxin.user.entity\")){                             c = this.getParent().loadClass(name);                         }else {                             //如果是这个包下的类 ，比如User，打破双亲委派机制                             c = findClass(name);                         }                          // this is the defining class loader; record the stats                         sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                         sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                         sun.misc.PerfCounter.getFindClasses().increment();                     }                 }                 if (resolve) {                     resolveClass(c);                 }                 return c;             }         }   最后就是通过覆写findClass查找我们指定的路径：  //自定义类加载器MyClassLoade extends ClassLoader class MyClassLoader extends ClassLoader {      private String classPath;  //定义要加载的类的路径      public MyClassLoader(String classPath) {         this.classPath = classPath;     }      //把路径下的文件转化化为字节数组     private byte[] loadByte(String name) throws Exception {         name = name.replaceAll(\"\\\\.\", \"/\");         FileInputStream fis = new FileInputStream(classPath + \"/\" + name + \".class\");         int len = fis.available();         byte[] data = new byte[len];         fis.read(data);         fis.close();         return data;     } \t     @Override     protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {         try {             byte[] data = loadByte(name);             //defineClass将一个字节数组转为Class对象，这个字节数组是class文件读取后最终的字节 数组, 由native方法实现             return defineClass(name, data, 0, data.length);         } catch (Exception e) {             e.printStackTrace();             throw new ClassNotFoundException();         }     }          @Overirde     protected Class&lt;?&gt; loadClass(String name, boolean resolve)         throws ClassNotFoundException{         ...     } }"
  },
  
  {
    "title": "JVM内存区域以及内存管理",
    "url": "/posts/java-jvm-memory/",
    "categories": "Java",
    "tags": "JVM",
    "date": "2019-04-02 00:00:00 +0800",
    "content": "内存区域划分  JVM内存布局在Java8以及之后做了一些修改，方法区做了一些变化：将原来永久代（Permanent Generation）移除了，改为使用元空间（Metaspace）来代替，因此原来的两个调优参数：-XX:PermSize和-XX:MaxPermSize被弃用了，改为使用-XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 来指定元空间的大小。如下图：  Java8之前：    Java8之后：    方法区的变化总结一下就是：     移除了永久代（PermGen）, 替换为元空间（Metaspace）   永久代中的class metadata 转移到了 native memory(本地内存，而不是虚拟机)   永久代中的interned Strings（字符串常量池） 和 class static variables（类静态变量）转移到了 Java heap   上面说的调优参数做了变化   程序计数器  程序计数器是一块较小的内存单元，它可以看做当前线程所执行的字节码的行号指示器，也就是里面存的是当前线程的执行进度，由于JVM可以并发执行线程，因此会存在线程之间的切换，而这个时候就程序计数器会记录下当前程序执行到的位置，以便在其他线程执行完毕后，恢复现场继续执行。如果线程正在执行的是应该Java方法，这个计数器记录的是正在执行虚拟机字节码指令的地址。如果正在执行的是Native方法，计数器的值则为空（undefined），注意程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。除此之外，程序计数器还存储了当前正在运行的流程，包括正在执行的指令、跳转、分支、循环、异常处理等。我们可以使用javap命令输出字节码，在每个opcode的前面都有一个序号，这就可以理解为程序计数器的内容。举例如下：  public class Test {     public static void main(String[] args) {         String s = \"Hello World\";         System.out.println(s);     } }   将上面一段代码执行javac指令后生成Test.class文件，然后我们对该class文件执行javap -p -v Test.class指令后，看下输出结果：  public static void main(java.lang.String[]);     descriptor: ([Ljava/lang/String;)V     flags: (0x0009) ACC_PUBLIC, ACC_STATIC     Code:       stack=2, locals=2, args_size=1          0: ldc           #2                  // String Hello World          2: astore_1          3: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;          6: aload_1          7: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V         10: return       LineNumberTable:         line 3: 0         line 4: 3         line 5: 10   上面的0，2，3，6，7，10即为程序计数器内容。  虚拟机栈  上图我们看到虚拟机栈是基于线程的，也就是说即便上面的例子只有一个main方法，也是以线程方式运行的，在线程的生命周期中，参与计算的数据会频繁地入栈和出栈，栈的生命周期是和线程一样的。每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储以下四个信息：          局部变量表      局部变量表是存放方法参数和局部变量的区域。全局变量是放在堆的，有两次赋值的阶段，一次在类加载的准备阶段，赋予系统初始值；另外一次在类加载的初始化阶段，赋予代码定义的初始值。           操作数栈      当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作           动态链接      每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。持有这个引用是为了支持方法调用过程中的动态连接(Dynamic Linking)。           方法出口      即方法返回地址，指向特定指令内存地址的指针，返回分为 正常返回 和 异常退出。一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中会保存这个计数器值。方法退出的过程相当于弹出当前栈帧。      每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。等所有栈帧都出栈以后，线程也就结束了。  最后它的调优参数为：-Xss    本地方法栈  和Java虚拟机栈比较类似，区别是Java虚拟机栈是调用Java方法；本地方法栈是调用本地native方法。  堆  Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存，所以它也是最大的内存区域，我们常说的垃圾回收，操作的对象就是堆，所以也称为”GC堆”。  由于现在垃圾收集器都采用分代收集算法，所以又把堆分为新生代和老年代，新生代 又分为 Eden + From Survivor + To Survivor区。  我们都知道Java对象分为基本数据类型和普通对象，对于普通对象来说，JVM 会首先在堆上创建对象，然后在其他地方使用的其实是它的引用。比如，把这个引用保存在虚拟机栈的局部变量表中。而对于基本数据类型来说，当你在方法体内声明了基本数据类型的对象，它就会在栈上直接分配。其他情况，都是在堆上分配。而像 int[] 数组这样的内容，是在堆上分配的。因为数组并不是基本数据类型。上面就是JVM的基本内存分配策略。  最后它的调优参数为：-Xmx 和 -Xms。  方法区  方法区（Method Area）与 Java 堆一样，是所有线程共享的内存区域。方法区用于存储已经被虚拟机加载的类信息（即加载类时需要加载的信息，包括版本、field、方法、接口等信息）、final常量、静态变量、编译器即时编译的代码等。  方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。  Java 8 以前，类的信息都放在一个叫永久代的内存里，这个区域有大小限制，很容易造成 JVM 内存溢出，从而造成 JVM 崩溃。所以后来就被去除了。取而代之的就是开头说的元空间。需要注意的是原来的永久代是在堆上的，而现在的元空间是在非堆上的。  JVM中存在多个常量池。1、字符串常量池，已经移动到堆上（jdk8之前是perm区），也就是执行intern方法后存的地方。2、类文件常量池，constant_pool，是每个类每个接口所拥有的，第四节字节码中“#n”的那些都是。这部分数据在方法区，也就是元数据区。而运行时常量池是在类加载后的一个内存区域，它们都在元空间。  总结了下变化：     移除了永久代（PermGen）, 替换为元空间（Metaspace）   永久代中的class metadata 转移到了 native memory(本地内存/非堆)   永久代中的interned Strings（字符串常量池） 和 class static variables（类静态变量非基本类型）转移到了 Java heap   调优参数也由-XX:PermSize和-XX:MaxPermSize改为使用-XX:MetaspaceSize 和 -XX:MaxMetaspaceSize   总结  综上，JVM 的运行时区域是栈，而存储区域是堆。线程私有的区域有：程序计数器、Java虚拟机栈、本地方法栈，而线程共享的区域有方法区和Java堆，而多个线程访问，就会造成数据同步的问题。"
  },
  
  {
    "title": "Android构建流程分析",
    "url": "/posts/android-build/",
    "categories": "Android",
    "tags": "build",
    "date": "2019-03-20 00:00:00 +0800",
    "content": "APK组成  我们都知道APK其实本质是一个压缩包文件，我们可以通过手动解压或者在Android Studio中的APK分析器我们可以看到，他最终是由这几部分组成：     Dex文件：.class文件通过d8工具处理后端产物，Android虚拟机可以执行的文件   Resource文件：资源文件，主要包括layout，drawable，animator等   resources.arsc：资源索引表   Assets文件：资源文件，通过AssetManager来加载   Library：so库文件   META-INF：APK签名信息   AndroidManifest.xml：清单文件   构建流程    上面这张图是现在的官方构建流程图，但是不够详细，下面这个是早期的android构建流程图，看起来更清楚一些，图中绿色标注为其中用到的相应工具，蓝色代表的是中间生成的各类文件类型：    我们的应用程序通常由这几部分组成     源代码文件   AIDL文件   资源文件   清单文件   我们构建的过程其实就是将上面几种文件编译成APK解压缩后的文件，其大致的一个框架是：          首先aapt工具会将资源文件进行转化，生成对应资源ID的R文件和二进制资源文件。           adil工具会将其中的aidl接口转化成Java的接口           至此，Java Compiler开始进行Java文件向class文件的转化，将R文件，Java源代码，由aidl转化来的Java接口，统一转化成.class文件。           通过dx工具将class文件转化为dex文件，现在通过D8工具完成这一过程转化。           此时我们得到了经过处理后的资源文件和一个dex文件，当然，还会存在一些其它的资源文件，这个时候，就是将其打包成一个类似apk的文件。但还并不是直接可以安装在Android系统上的APK文件。           通过签名工具对其进行签名。           通过Zipalign进行优化，提升运行速度。      更细致的分析我们通过另外一张图可以了解：    接下来我们先准备上面需要构建的几类文件，然后结合这张图分析下具体流程：          通过aapt2 compile 打包资源文件，生成编译后的.flat文件（二进制文件）      这一步我们可以通过命令行执行就是：aapt2 compile -o build/res.zip --dir res           通过 aapt2 link 将 .flat 和 AndroidManifest 进行连接，转化成不包含 dex 的 apk 和 R.java      同样用命令行执行：aapt2 link build/res.zip -I $ANDROID_HOME/platforms/android-30/android.jar --java build --manifest AndroidManifest.xml -o build/app-debug.apk           通过 javac 将 Java 文件编译成 .class 文件      命令行：javac -d build -cp $ANDROID_HOME/platforms/android-30/android.jar com/**/**/**/*.java           通过 d8 将 .class 文件转化成 dex 文件      d8 --output build/ --lib $ANDROID_HOME/platforms/android-30/android.jar build/com/yuxingxin/gradle_test/androidbuild/*.class           合并 dex ⽂件和资源⽂件      zip -j build/app-debug.apk build/classes.dex           对 apk 通过 apksigner 进行签名      apksigner sign -ks ~/.android/debug.keystore build/appdebug.apk           zipalign进行优化，提升运行速度      zipalign -p -f -v 4 appdebug.apk app_debug.apk      上面过程注意dex文件，因为Android有64K限制，即当 type_ids、method_ids 或者 field_ids 超过 65536（64 * 1024）的时候，需要进行 dex 分包，为了 Dex 的数量尽可能少，我们需要尽量实现「Dex 信息有效率」的提升。"
  },
  
  {
    "title": "Android构建工具Gradle解析",
    "url": "/posts/gradle/",
    "categories": "Android",
    "tags": "build",
    "date": "2019-03-15 00:00:00 +0800",
    "content": "Gradle 是一个开源的自动化构建工具，其核心是基于 Java 实现，可以把它看成一个轻量级的 Java 应用，可以使用 Groovy 或 Kotlin 来编写脚本，简化了开发时对项目构建要做的配置，使用更加灵活和强大。  配置文件  build.gradle  该文件是项目构建文件，每个工程都有一个build.gradle文件，它在配置阶段执行，并创建相应工程的Project对象，执行的代码可以直接调用该对象提供的方法或者属性。  settings.gradle  该文件是在初始化阶段执行，创建Setting对象，在执行脚本时可调用此对象方法，它决定了哪些模块参与构建过程。  基本概念  项目：每个 build.gradle 都是一个项目对象，每一次 gradle 构建都至少包含一个项目，每个项目中都有各自的任务。  任务/task：任务定义在构建脚本中，包含一系列的动作，类似于一个方法，比如 clean 任务：  task clean(type: Delete) {     delete rootProject.buildDir }   声明周期    如上图所示，共分为三个阶段：  1. 初始化  Gradle支持单项目和多项目构建。在初始化阶段，执行settings.gradle脚本，Gradle读取include信息，并 确定哪些项目将参与构建，并为每个工程创建一个与之对应的Project 对象，最终形成一个项目层次结构。  2. 配置  配置阶段，执行每个工程的 build.gradle 文件，完成Project的配置，并且构造出Task任务依赖的一个有向无环图DAG，以供执行阶段按照依赖顺序执行，并对任务做一些初始化配置。  3. 执行  运行阶段，Gradle 根据配置阶段创建和配置的要执行的任务子集，执行任务。  Task  语法：  task &lt;任务名称&gt; {     // 代码块          doFirst {         // 执行     }          doLast {              } }   上面代码中，定义在task中的代码块只是设置了任务的配置，在配置阶段执行，那么想要在执行阶段添加动作action，就可以在doFirst和doLast方法中添加。  依赖  task A(dependsOn:[B]){ .. } 表示任务 A 依赖于任务 B，那么 B 执行在 A 之前。  task A{     println \"test A\"     doLast{         println \"test A-doLast\"     } } //这里表示任务B依赖任务A，在A执行后才会执行B task B(dependsOn:[A]){     println \"test B\"     doLast{         println \"test B-doLast\"     } }  // 执行./gradlew B &gt; Configure project :app test A test B  &gt; Task :app:A test A-doLast  &gt; Task :app:B test B-doLast   插件  自定义 Gradle 插件有三种方式：     构建脚本   可以直接在构建脚本中包含插件的源代码。这样做的好处是插件可以自动编译并包含在构建脚本的类路径中，而不需要您做任何事情。然而，插件只能在定义它的构建脚本之内可见，不能在其他脚本中复用插件。     buildSrc   可以将插件的源代码放在rootProjectDir/buildSrc/src/main/java目录（或rootProjectDir/buildSrc/src/main/groovy或rootProjectDir/buildSrc/src/main/kotlin中，具体取决于你使用的语言）。 Gradle将负责编译插件，并使其在构建脚本的类路径中可用。 该插件对整个项目里的每个构建脚本都是可见的， 但是，它在项目外部不可见，因此不能其他项目中复用该插件。     独立项目   可以为插件创建一个单独的项目，将项目打包成一个JAR包，然后可以在多个项目中复用。  实践  执行gradle init命令，按照下面步骤一步一步选择配置，最终创建完项目  Starting a Gradle Daemon (subsequent builds will be faster)  Select type of project to generate:   1: basic   2: application   3: library   4: Gradle plugin Enter selection (default: basic) [1..4] 4  Select implementation language:   1: Groovy   2: Java   3: Kotlin Enter selection (default: Java) [1..3] 1  Select build script DSL:   1: Groovy   2: Kotlin Enter selection (default: Groovy) [1..2] 1  Project name (default: gradle_plugin): com.yuxingxin.plugintest Source package (default: com.yuxingxin.plugintest):  &gt; Task :init Get more help with your project: https://docs.gradle.org/7.2/userguide/custom_plugins.html  BUILD SUCCESSFUL in 35s 2 actionable tasks: 2 executed   紧接着创建一个名为Greeting的任务，目的是向该插件的项目注册一个这样的任务，它做的事情就是在doLast时候打印一句话。  public class HelloPlugin implements Plugin&lt;Project&gt; {     public void apply(Project project) {         // Register a task         project.tasks.register(\"greeting\") {             doLast {                 println(\"Hello from plugin 'com.yuxingxin.plugintest.greeting'\")             }         }     } }   发布该插件需要借助Maven Publish Plugin插件，首先在build.gradle中应用：  plugins {     ...     id 'maven-publish' }   然后定义插件的发布信息：  publishing {     publications {         // 这里的 hello 可以任意命名         hello(MavenPublication) {             // 插件的组ID，建议设置为插件的包名             groupId = 'com.yuxingxin.plugintest'             // 插件ID             artifactId = 'greeting'             version = '1.0.0'             // 组件类型，我们的插件其实就是Java组件             from components.java         }     }     // 不指定repositories会默认发布在.m2/repository/目录下     repositories {         maven {             // 这里发布到自己项目，$rootDir 表示你项目的根目录             url = \"$rootDir/repo\"         }     } }   然后就可以接入自己的项目使用了。"
  },
  
  {
    "title": "基于Hacker News的内容热度推荐算法",
    "url": "/posts/recommendation-algorithm/",
    "categories": "Algorithm",
    "tags": "algorithm",
    "date": "2019-03-10 00:00:00 +0800",
    "content": "前言 近期公司产品需要做一个内容推荐的功能，但限于人员和能力有限，经过调研，确定了一个简单相对我们可以实现的方案。一篇文章产生，随着用户浏览、点赞、分享、收藏、评论，热度逐渐攀升，进入榜单到推荐页面，但随着时间的推移，这篇文章也不能永久的霸占榜单，让后面新产生的文章没有机会到推荐页，因此也就有了时间衰减的因素，从而可以让榜单能够动态的变化，除了上面基本的原理以外，还需要人为干预因素，通过加权或者降权的方式来影响排名。  因子     用户活跃度（以积分的形式）   浏览量   点赞数   收藏数   评论数   分享数   时间衰减   平台编辑推荐（人为因素介入干预）   基本原理    初始热度  Hinit  与最后的推荐指数呈正相关（注意不是成正比），影响其的因素有：     创作者：暂时以用户活跃度来界定   内容属性：以篇幅、类别来区分   互动热度  Hinteract  与最后的推荐指数呈正相关（注意不是成正比），用户行为数据是决定一篇文章是否热门的重要因素，通过对这些数据评级来进行调整行为分：  比如： 浏览+1分，点赞+3分，评论+8分，收藏+10分，分享+15分。  时间衰减 Htime  与最后的推荐指数呈负相关（注意不是成反比）  大部分内容属于一次性消费品，用户看过也就过了，若推荐榜单总是那么几条， 可能很快就觉得乏味 ，从而转向别的产品。所以我们自然希望内容能不断更新，而若只看初始热度+互动热度，那么后来者必定很难超越前者。  所以还必须考虑一个因素就是时间衰减，通常这个也不是线性衰减，往往是一个指数函数：即过了一定时间后，持续衰减，热度直到无限趋于0  权重 Hweight  运营或编辑人为干预来调整权重也很重要，毕竟算法是死的，人是活的，虽然大部分都遵循这样一个规律，但也不排除偶然或者极端情况，比如恶意刷榜，这时候就需要人为的干预  图形曲线：    总结公式    参数解释：  Hinit ： 初始热度值，可以以用户活跃度来衡量，比如以积分的形式，积分积累的途径有：     发文章   发笔记   发动态   提问题   回答问题   评论   系统、平台编辑推荐   在其他条件一定的情况下，初始热度越高，其最终热度也就越高  Hinteract：互动热度值，根据用户行为数据来衡量，参考点有以下几项：     浏览量   点赞量   评论量   收藏量   分享量   在其他条件一定的情况下，互动热度越高，其最终热度也就越高  Htime：时间衰减因子， 加2是为了防止最新发表的会导致分母过小 ，这个值可调，在前期平台人数较少时调整大一些，在后期人数增长起来后，可以调整的小一些，比如，因为用户对平台资源有一个消化时间。并不是一发出来就有数据的。  G：重力因子，它决定了热度随时间下降的速度，前期平台人员较少时，相对应得发的资源也会比较少，这时可以把G调小一点，减缓时间推移对热度下降的影响，后期平台人员增多时，相对应的资源也会增加，这时可以把G调大一点，加速时间推移对热度下降的影响。比如：1.2-1.8  Hweight: 加减权重，初始值可以为0，在某些偶然或者极端情况下需要人为干预的时候，可以动态调整其值，使其能够及时的控制其热度。  反作弊     可以通过权重来干预   可以制定社区规则来动态调整Hinit   参考     Hacker News 帖子热度排序算法   掘金文章内容热度排序算法"
  },
  
  {
    "title": "关于Code Review的一些思考总结",
    "url": "/posts/code-review/",
    "categories": "CodeStyle",
    "tags": "CodeReview",
    "date": "2018-06-17 00:00:00 +0800",
    "content": "Code Review     提高代码质量   提前发现bug   统一代码规范   提高团队成员代码技能   总之，前期找问题（代码规范、潜在缺陷、BUG，代码设计等等），后期演变成开发者技术交流和员工成长  如何开展     代码规范：明确Coding规则   检视清单：结合业务特点，check重点   总结优化：透明问题，持续优化   激励措施：激发主观能动性   开展方式     强制&amp;非强制   线上交流（小组review）&amp;线下会议（团队review）   小片段&amp;大模块   发布前&amp;发布后   高频率&amp;低频率   阻力因素     领导或者团队骨干不认同   为了疲于应付   以需求多，没时间做为偷懒借口   组织类型     小组内review，通常是模块负责人或者项目负责人review，频率比较高，一天至少一次   团队review，通常是整个团队review代码，团队负责人牵头，频率可以低一点，鉴于公司情况一周至少1次吧   review内容  统一团队代码风格和编程规范  静态代码检查工具     Java类：Checkstyle、FindBugs、PMD、Infer等   JavaScript类：JSLint、ESLint等   Object-C类：OCLint、Clang Static Analyzer、Infer等   C#类：StyleCode等   可以参考的一些编码规范(https://github.com/Kristories/awesome-guidelines)  发现『bad smell』的代码以及bug  相关书籍：《重构-改善既有代码的设计》《代码整洁之道》  团队成员好的经验     什么写法可能导致性能低下？   哪个接口要慎用？   哪些设计方式需要规避？   什么习惯容易引发内存泄漏？   ……   开发者由于当初时间紧迫而觉得设计不合理的功能     功能不完善   设计有欠缺   代码有更好实现方案   重视项目代码的可读性   总之，代码是否符合团队约定的代码风格规范、代码是否切合它所实现的业务、代码是否安全、代码性能、对后续开发者是否友好，即是否容易维护等  注意事项     GitLab可以设置master和develop分支保护，开发者不能向这两个分支push代码，只能通过PR/MR形式。   可以通过设置git pre-commit hook来check，从而使不符合规范的代码禁止提交仓库。   配合CI检查，作为build的第一步。   用户角色有：所有者/主程/开发者/报告者/访客，其中只有所有者和主程才有review代码和合并代码权限。   注意小组至少有两个人有权限review并合并代码，避免一个人请假或者不在，导致代码合不上去。   主程一定要注意，避免过多模块工作堆积在自己身上，一定要学会合理分配任务，因为你还需要有精力去review代码，这也是一部分额外任务。   提交的 feature 分支全部走 gitlab 的 MR ，develop分支不允许提交，只用来合并，并且只合并那些经过review过的代码，master分支不允许提交，也只用来合并，并且只合并来自develop分支的代码。   不一定职称越高，就更有可能比别人review代码，code review知识共享更受重视，通过review发现bug是有的，但不是最终目的，增进团队共识，保护团队一致性其实更重要。   尽量避免开发经验不足的开发者或者刚进公司对业务不熟悉的人员（哪怕高级工程师）review 代码。   如果可以尽可能写单元测试，不一定cover全面，如果时间紧迫可以只对关键模块做。   提交PR/MR，记得在IM上通知相关人员review，比如项目负责人或者模块负责人。   控制团队review的时间，半个小时到1个小时，最好不要超过1个小时，30-40分钟为宜，项目负责人具体把握。   根据公司情况团队review一周在至少一次比较合适。   review可能需要多次才被允许合入代码，这也就意味着，可能你的代码需要给多次修改才能改好。   避免代码堆积，造成一次review大量代码，一方面急于review，这样容易放水，同时也浪费时间，造成效果不理想。   建议由1人做好记录，把每次review的改进点以清单形式汇总列清楚发给所有参会人员。   总结  由于工期紧、需求变更快，如果不想清楚为什么要做 Code Review ，遇到障碍会非常容易妥协，慢慢 Code Review 就会走样，最终流于形式。反之，在我们遇到障碍，review 代码不顺利时就会以积极的心态来解决问题。Code Review会影响开发效率，事实上追求高质量的代码本身就降低了局部的开发效率，但是放眼长远，这样写出来的代码更加健壮，不会或很少出现“诡异”的bug，降低了后期维护的成本。  所以Code Review本身没有问题，其实是人容易出问题。"
  },
  
  {
    "title": "JavaScript基础之发布-订阅模式EventEmitter的实现",
    "url": "/posts/javascript-event-emitter/",
    "categories": "JavaScript",
    "tags": "EventEmitter",
    "date": "2018-03-26 00:00:00 +0800",
    "content": "我们知道EventEmitter是在Node.js中events模块封装的，但是在浏览器端还没有，在Vue中非父子组件通信，官方推荐过一种EventBus的解决方案，它是将EventBus作为组件传递数据的桥梁，所有组件共用的相同事件中心，可以向该中心发送事件或者接收事件，所有组件都可以收到通知，使用起来非常便利，其核心便是发布-订阅模式的实现。  接下来实现一个简易版的发布-订阅模式EventEmitter:  function EventEmitter {     this._events = {} }  // 订阅事件 EventEmitter.prototype.on = function(eventName, callback) {     const listeners = this._events[eventName] || [];     listeners.push(callback);     this._events[eventName] = listeners; }  // 触发事件 EventEmitter.prototype.emit = function(eventName, ...args) {     const listeners = this._events[eventName];     const params = [].slice.call(args);     listeners.forEach(fn =&gt; {         fn.call(params);     }); }  // 取消事件 EventEmitter.prototype.off = function(eventName, callback) { \tconst listeners = this._events[eventName];     this._events[eventName] = listeners &amp;&amp; listeners.filter(fn =&gt; fn !== callback); }  // 单次触发该事件 EventEmitter.prototype.once = function(eventName, callback) {     const wrapperFun = (...args) =&gt; {         callback.call(this, args);         this.off(eventName, wrapperFun);     }     this.on(eventName, wrapperFun); }   从上面实例也可以看出，一个基本的发布订阅模式主要有四部分组成：     提供一个事件订阅方法on，并将事件存储到this._events中，等需要出发的时候，则直接从通过获取 __events 中对应事件的 listener 回调函数，而后直接执行该回调方法就能实现想要的效果。   提供一个触发事件的方法emit，并发送对应的参数触发回调函数执行。   提供一个取消订阅事件的方法off，能够对指定事件取消订阅。   提供一个单词触发事件的方法。该事件的回调函数在执行完成后自动取消订阅。"
  },
  
  {
    "title": "JavaScript基础之异步编程演进",
    "url": "/posts/javascript-asynchronous/",
    "categories": "JavaScript",
    "tags": "Asynchronous",
    "date": "2018-03-22 00:00:00 +0800",
    "content": "在说异步之前，先介绍一下同步的概念，即在执行某段代码时，在该段代码没有返回结果之前，其他代码暂时无法执行，但是一旦拿到返回值后，就可以接着执行其他代码了，换句话说，在此段代码执行完未返回结果前，会阻塞之后的代码的执行，这样的情况就成为同步。  再回过头来说异步，就是当某一代码执行异步过程调用发出后，这段代码不会立刻得到返回结果。而是在异步调用发出之后，一般通过回调函数处理这个调用之后拿到结果。异步调用发出后，不会影响阻塞后面的代码执行，这样的情形称为异步。  我们都知道JavaScript是单线程的，如果代码都是同步执行，这样可能会造成阻塞，但如果是以异步的方式执行，程序不需要等待异步代码执行的结果，可以继续执行该异步任务之后的代码逻辑，这样不会造成阻塞。  回调函数  早年实现异步的方法就是采用回调函数的方式，比如setTimeout或者setInterval，以及一些事件回调，但是写过异步的人都知道使用回调函数最大的一个问题就是会产生回调地狱。  var readData = function(fileName, callback) {     fs.readFile(fileName, callback); } readData(\"file1\", function() {     readData(\"file2\", function(){         readData(\"file3\",function(){             console.log(\"end\")         })     }) })   从上面的代码逻辑可以看出，要实现的功能是模拟读取文件file的内容，即先读取file1的内容，再读取file2的内容，最后读取file3的内容，为了实现上面的需求，就很容易产生回调地狱。那么针对这个问题，如何解决呢？那么接下来看下Promise如何实现异步编程的。  Promise  为了更好的解决回调地狱问题，社区提出了Promise的方案。  var readData = function(fileName){     return new Promise((resolve, reject) =&gt; {         fs.readFile(fileName, (err, data) =&gt; {             if(err) reject(err);             resolve(data);         });     }); }  readData(\"file1\").then(function() {     return readData(\"file2\"); }).then(function() {     return readData(\"file3\") }).then(function() {    console.log('end'); }).catch(function(err){    console.log(err);  });    从上面的代码来看。可读性有一定的提升，优点是可以将异步的操作以同步的流程表达出来，避免了层层嵌套的回调函数。但如果说上面需求改为，同时读取3个文件，这个时候就需要用到Promise.all方法了。  Promise.all([readData(\"file1\"), readData(\"file2\"), readData(\"file3\")]).then(data =&gt; {     console.log(data); }).catch(function(err) {     console.log(err); })   其实Promise相当于是一个容器，它里面保存着未来才会结束的事件，通常是异步操作的结果，从语法上面来讲，Promise是一个对象，从 它可以获取异步操作的信息。  一般Promise在执行的 过程中，会分成以下几个状态：     待定（pending）：初始状态，既没有被完成，也没有被拒绝。   已完成（fulfilled）：操作成功完成。   已拒绝（rejected）：操作失败。   待定状态的 Promise 对象执行的话，最后要么会通过一个值完成，要么会通过一个原因被拒绝。当其中一种情况发生时，我们用 Promise 的 then 方法排列起来的相关处理程序就会被调用。因为最后 Promise.prototype.then 和 Promise.prototype.catch 方法返回的是一个 Promise， 所以它们可以继续被链式调用。  另外除了上面提到的Promise.all方法以外，还有几个方法：  Promise.allSettled 的语法及参数跟 Promise.all 类似，其参数接受一个 Promise 的数组，返回一个新的 Promise。唯一的不同在于，执行完之后不会失败，也就是说当 Promise.allSettled 全部处理完成后，我们可以拿到每个 Promise 的状态，而不管其是否处理成功。  Promise.any（iterable），参数为 iterable 可迭代的对象，例如 Array。 它返回一个 Promise，只要参数 Promise 实例有一个变成 fulfilled 状态，最后 any 返回的实例就会变成 fulfilled 状态；如果所有参数 Promise 实例都变成 rejected 状态，包装实例就会变成 rejected 状态。  Promise.race（iterable），参数为 iterable 可迭代的对象，例如 Array。 它返回一个 Promise，只要参数的 Promise 之中有一个实例率先改变状态，则 race 方法的返回状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 race 方法的回调函数。  Generator  Generator 也是一种异步编程解决方案，它最大的特点就是可以交出函数的执行权，Generator 函数可以看出是异步任务的容器，需要暂停的地方，都用 yield 语法来标注。Generator 是一个带星号的函数，一般配合 yield 使用来暂停或者执行函数，它最后返回的是迭代器。  function* makeRangeIterator(start = 0, end = Infinity, step = 1) {     for (let i = start; i &lt; end; i += step) {         yield i;     } } var a = makeRangeIterator(1,10,2) a.next() // {value: 1, done: false} a.next() // {value: 3, done: false} a.next() // {value: 5, done: false} a.next() // {value: 7, done: false} a.next() // {value: 9, done: false} a.next() // {value: undefined, done: true}   从实例可以看出，yield关键词最后返回一个迭代器对象，配合着 Generator，再同时使用 next 方法，可以主动控制 Generator 执行进度。每一次执行next函数都会返回一个对象，其存在两个属性，value和done，其中value就是我们打印出来的值，而done表示该迭代器是否执行完，  从上面这个例子，还很难和异步编程联系到一起，接下来我们先说下thunk函数  thunk函数  它的基本思想都是接收一定的参数，然后生产出定制化的函数，最后使用定制化的函数去完成想要实现的功能。  const readDataThunk = (fileName) =&gt; {     return (callback) =&gt; {         fs.readFile(fileName, callback);     } }  const gen = function* () {     const file1 = yield readDataThunk('file1');     const file2 = yield readDataThunk('file2');     const file3 = yield readDataThunk('file3'); }  let g = gen(); g.next().value((err, file1) =&gt; {     g.next(file1).value((err,file2) =&gt; {         g.next(file2).value((err, file3) =&gt; {             g.next(file3);         })     }) })  // 进一步封装，改进嵌套问题 function run(gen){     const next = (err, data) =&gt; {         let res = get.next(data);         if(res.done) return;         res.value(next);     }     next(); } run(g)   co函数库  co 函数库是著名程序员 TJ 发布的一个小工具，用于处理 Generator 函数的自动执行。核心原理其实就是上面讲的通过和 thunk 函数以及 Promise 对象进行配合，包装成一个库。它使用起来非常简单，比如还是用上面那段代码，第三段代码就可以省略了，直接引用 co 函数，包装起来就可以使用了  const co = require('co'); let g = gen(); co(g).then(res =&gt;{   console.log(res); })   这段代码比较简单，几行就完成了之前写的递归的那些操作。那么为什么 co 函数库可以自动执行 Generator 函数，它的处理原理是什么呢？  其实Generator 函数就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。     回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。   Promise 对象。将异步操作包装成 Promise 对象，用 then 方法交回执行权。   co 函数库其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个库。使用 co 的前提条件是，Generator 函数的 yield 命令后面，只能是 Thunk 函数或 Promise 对象。所以上面的例子用Promise就是：  const readData = (fileName) =&gt; {     return new Promise((resolve, reject) =&gt; {         fs.readFile(fileName, (err, data) =&gt; {             if(err) reject(err);             resolve(data);         });     }); };  const gen = function* () {     const file1 = yield readData('file1');     const file2 = yield readData('file2');     const file3 = yield readData('file3'); }  let g = gen(); g.next().value.then((err, file1) =&gt; {     g.next(file1).value.then((err,file2) =&gt; {         g.next(file2).value.then((err, file3) =&gt; {             g.next(file3);         })     }) })  // 进一步封装，改进嵌套问题 function run(gen){     const next = (err, data) =&gt; {         let res = get.next(data);         if(res.done) return;         res.value.then(next);     }     next(); } run(g)   关于更多co函数库的内部原理，可以去源码库学习，也可以参考这里  async/await  ES6 之后 ES7 中又提出了新的异步解决方案：async/await，async 是 Generator 函数的语法糖，async/await 的优点是代码清晰（不像使用 Promise 的时候需要写很多 then 的方法链），可以处理回调地狱的问题。async/await 写起来使得 JS 的异步代码看起来像同步代码，其实异步编程发展的目标就是让异步逻辑的代码看起来像同步一样容易理解。  var readData = function(fileName){     return new Promise((resolve, reject) =&gt; {         fs.readFile(fileName, (err, data) =&gt; {             if(err) reject(err);             resolve(data);         });     }); } // 这里把 Generator的 * 换成 async，把 yield 换成 await async function testReadData() {     await readData(\"file1\");     await readData(\"file2\");     await readData(\"file3\");     console.log('end'); } console.log(testReadData());  // file1  file2  file3  end   执行上面的代码，从结果中可以看出，在正常的执行顺序下，readData 这个函数由于使用的是 setTimeout 的定时器，回调会在一秒之后执行，但是由于执行到这里采用了 await 关键词，testReadData 函数在执行的过程中需要等待3个 readData 函数执行完成之后，再执行打印 end 的操作。  总结下来，async 函数对 Generator 函数的改进，主要体现在以下三点。          内置执行器：Generator 函数的执行必须靠执行器，因为不能一次性执行完成，所以之后才有了开源的 co 函数库。但是，async 函数和正常的函数一样执行，也不用 co 函数库，也不用使用 next 方法，而 async 函数自带执行器，会自动执行。           适用性更好：co 函数库有条件约束，yield 命令后面只能是 Thunk 函数或 Promise 对象，但是 async 函数的 await 关键词后面，可以不受约束。           可读性更好：async 和 await，比起使用 * 号和 yield，语义更清晰明了。      所以，async/await也是javascript异步的终极解决方案。"
  },
  
  {
    "title": "JavaScript基础之数组常用操作实现",
    "url": "/posts/javascript-array-operation/",
    "categories": "JavaScript",
    "tags": "Array",
    "date": "2018-03-19 00:00:00 +0800",
    "content": "数组的去重  给定一个数组，如果对其中的元素去重？  1. 利用Set  我们知道ES6引入了Set，它的一个特性就是不能有重复的元素存在，我们可以利用这一特性来实现。另外Set是一个可迭代的对象，我们可以利用Array.from或者展开运算符将其转换为一个新的数组  const result = Array.from(new Set(arr))  const result = [...new Set(arr)]   2. 利用indexOf、includes、filter  // indexOf const unique1 = arr =&gt; {     const result = [];     for(let i = 0; i&lt; arr.length; i++) {         if(result.indexOf(arr[i]) === -1) result.push(arr[i]);     }     return result; }  // includes const unique2 = arr =&gt; {     const result = [];     for(let i = 0; i&lt; arr.length; i++) {         if(!result.includes(arr[i])) result.push(arr[i]);     }     return result; }  // filter const unique3 = arr =&gt; {     return arr.filter((item, index) =&gt; {         return arr.indexOf(item) === index;     }); }   数组扁平化  数组扁平化就是将一个嵌套多层的数组 array（嵌套可以是任何层数）转换为只有一层的数组。  1. 使用flat()  const result = arr.flat(Infinity)   2. 使用递归  function flatten(arr) {     let result = [];     for(let i = 0;i &lt; arr.lenght; i++){         if(Array.isArray(arr[i])) {             result = result.concat(flatten(arr[i]));         }else {             result.push(arr[i]);         }     }     return result; }   3. 使用reduce函数迭代  function flatten(arr) {     return arr.reduce((prev, curr) =&gt; {         return prev.concat(Array.isArray(curr)? flatten(curr): curr);     }, []); }   4. 使用扩展运算符  function flatten(arr) {     while(arr.some(item =&gt; Array.isArray(item))) {         arr = [].concat(...arr);     }     return arr; }    5. 使用toString和split  function flatten(arr) {     return arr.toString().split(','); }   6. 使用正则和JSON  function flatten(arr) {     let str = JSON.stringfy(arr);     str = str.replace(/(\\[|\\])/g,'');     str = '[' + str + ']';     return JSON.parse(str); }   类数组转化为数组  类数组是具有length属性，但不具有数组原型上的方法。常见的类数组有arguments、DOM操作方法返回的结果。  1. Array.from  Array.from(document.querySelectorAll('div'))   2. Array.prototype.slice.call()  Array.prototype.slice.call(document.querySelectorAll('div'))  [].slice.call(document.querySelectorAll('div'))   3. 扩展运算符  [...document.querySelectorAll('div')]   4. 利用concat  Array.prototype.concat.apply([], document.querySelectorAll('div'));   常见数组原型方法实现  forEach  Array.prototype.forEach2 = function(callback, thisArg) {     if(this == null) {         throw new TypeError('this is null or not defined')     }     if(typeof callback !== 'function') {         throw new TypeError(callback+' is not a function');     }          const O = Object(this)  // this是当前数组     const len = O.length &gt;&gt;&gt; 0  // 无符号右移     let k = 0;     while(k &lt; len) {         if(k in O) {             callback.call(thisArg, O[k], k, O);         }         k++;     } }   参考forEach#polyfill  O.length »&gt; 0 是什么操作？就是无符号右移 0 位，它就是为了保证转换后的值为正整数。其实底层做了 2 层转换，第一是非 number 转成 number 类型，第二是将 number 转成 Uint32 类型。  Map  该方法创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。基于 forEach 的实现能够很容易写出 map 的实现：  Array.prototype.map2 = function(callback, thisArg) {     if(this == null) {         throw new TypeError('this is null or not defined');     }     if(typeof callback !== 'function')  {         throw new TypeError(callback + ' is not a function');     }     const O = Object(this);     const len = O.length &gt;&gt;&gt; 0;     let k = 0, res = [];     while(k &lt; len) {         if(k in O) {             res[k] = callback.call(thisArg, O[k], k, O);         }         k++;     }          return res; }   filter  该方法创建一个新数组，其包含通过所提供函数实现的测试的所有元素。同样，基于 forEach 的实现能够很容易写出 filter 的实现：  Array.prototype.filter2 = function(callback,thisArg) {     if(this == null) {         throw new TypeError('this is null or not defined');     }     if(typeof callback !== 'function')  {         throw new TypeError(callback + ' is not a function');     }     const O = Object(this);     const len = O.length &gt;&gt;&gt; 0;     let k = 0, res = [];     while(k &lt; len) {         if(k in O) {             if(callback.call(thisArg, O[k], k, O)) {                 res.push(O[k]);             }         }         k++;     }     return res; }   some  该方法测试数组中是不是至少有 1 个元素通过了被提供的函数测试。它返回的是一个 Boolean 类型的值。同样，基于 forEach 的实现能够很容易写出 some 的实现：  Array.prototype.some2 = function(callback,thisArg) {     if (this == null) {         throw new TypeError('this is null or not defined');     }     if (typeof callback !== \"function\") {         throw new TypeError(callback + ' is not a function');     }     const O = Object(this);     const len = O.length &gt;&gt;&gt; 0;     let k = 0;     while(k &lt; len) {         if(k in O) {             if(callback.call(thisArg, O[k], k, O)) {                 return true             }         }         k++;     }     return false; }   reduce  该方法对数组中的每个元素按序执行一个由您提供的 reducer 函数，每一次运行 reducer 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。  第一次执行回调函数时，不存在“上一次的计算结果”。如果需要回调函数从数组索引为 0 的元素开始执行，则需要传递初始值。否则，数组索引为 0 的元素将被作为初始值 initialValue，迭代器将从第二个元素开始执行（索引为 1 而不是 0）。  Array.prototype.reduce2 = function(callback, initialValue) {     if (this == null) {         throw new TypeError('this is null or not defined')     }     if (typeof callback !== \"function\") {         throw new TypeError(callback + ' is not a function')     } \tconst O = Object(this);     const len = O.length &gt;&gt;&gt; 0;     let k = 0, acc;     if(arguments.length &gt; 1) {         acc = initialValue;     } else {         // 没传入初始值的时候，取数组中第一个非empty的值为初始值         while( k &lt; len &amp;&amp; !(k in O)) {             k++;         }         // 如果超出数组界限还没有找到累加器的初始值，则TypeError         if(k &gt; len) {             throw new TypeError('Reduce of empty array with no initial value');         }         acc = O[k++];     }     while(k &lt; len) {         if(k in O) {             acc = callback.call(acc, O[k], k, O);         }         k++;     }     return acc; }"
  },
  
  {
    "title": "JavaScript基础之数组与类数组梳理",
    "url": "/posts/javascript-array/",
    "categories": "JavaScript",
    "tags": "Array",
    "date": "2018-03-16 00:00:00 +0800",
    "content": "JavaScript中数组的API纷繁复杂，其中还有不少坑，这里一起做个总结。  构造器  通常我们使用对象字面量的方式创建一个数组，例如var array = [];，但是，有的时候对象字面量不能满足我们要求，比如，我想给数组限制长度，用对象字面量就无法创建了，这时候只能使用构造器：     new Array(arg1,arg2,…)，参数长度为0或者长度大于等于2时，传入的参数将按照顺序依次成为数组的第0至第N项（参数长度为0时，返回空数组）   new Array(len)，当len不是数值时，返回一个只包含len元素一项的数组，当len为数值时，len最大不能超过32位无符号整型，即小于2的32次方，否则将抛出RangeError.   ES6 以后，新增了几个方法：  Array.of  Array.of 用于将参数依次转化为数组中的一项，然后返回这个新数组，而不管这个参数是数字还是其他，它基本上与 Array 构造器功能一致，唯一的区别就在单个数字参数的处理上。  Array.of(8);  // [8] new Array(8)    // [empty X 8]  Array.of(3,5)  // [3,5] new Array(3,5)    // [3,5] Array.of('3')  // ['3'] new Array('3')   // ['3']   Array.from  Array.from 的设计初衷是快速便捷地基于其他对象创建新数组，准确来说就是从一个类似数组的可迭代对象中创建一个新的数组实例。其实就是，只要一个对象有迭代器，Array.from 就能把它变成一个数组（注意：是返回新的数组，不改变原对象）。  从语法上看，它有3个参数：     类似数组的对象。   加工函数，新生成的数组会经过该函数的加工后返回。   this作用域，表示加工函数执行的this的值。   这三个参数中，第一个参数是必选的，后面两个参数是可选的。  Array.from([1, 2, 3], x =&gt; x + x);  // [2, 4, 6]  Array.from(new Set(['foo', 'bar', 'baz', 'foo'])) // [ \"foo\", \"bar\", \"baz\" ]  const map = new Map([[1, 2], [2, 4], [4, 8]]); Array.from(map); // [[1, 2], [2, 4], [4, 8]]  const mapper = new Map([['1', 'a'], ['2', 'b']]); Array.from(mapper.values()); // ['a', 'b'];  Array.from(mapper.keys()); // ['1', '2'];   Array的判断  这里总结至少6种判断数组的方法：     基于instanceof   基于constructor   基于Object.prototype.isPrototypeOf   基于getPrototypeOf   基于Object.prototype.toString   基于ES6 新增的Array.isArray方法   var a = []; a instanceof Array  a.constructor === Array  Array.prototype.isPrototypeOf(a);  Object.getPrototypeOf(a) === Array.prototype  Object.prototype.toString.apply(a) === '[object Array]'   改变自身的方法  基于 ES6，会改变自身值的方法一共有 9 个，分别为 pop、push、reverse、shift、sort、splice、unshift，以及两个 ES6 新增的方法 copyWithin 和 fill。  pop  pop() 方法从数组中删除最后一个元素，并返回该元素的值。此方法会更改数组的长度。  push  push() 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。  reverse  reverse() 方法将数组中元素的位置颠倒，并返回该数组。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。该方法会改变原数组。  shift  shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。  unshift  unshift() 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度（该方法修改原有数组）。  sort  sort() 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的 UTF-16 代码单元值序列时构建的  如果指明了 compareFunction ，那么数组会按照调用该函数的返回值排序。即 a 和 b 是两个将要被比较的元素：     如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；   如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）；   如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。   compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。   splice  splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。此方法会改变原数组。  参数：start指定修改的开始位置，deleteCount表示要移除的数组元素的个数，item1,item2……要添加进数组的元素。  copyWithin  copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回该数组，不会改变原数组的长度。  参数target为基底的索引，复制序列到该位置，start为索引，开始复制元素的起始位置，end为索引，开始复制元素的结束位置。  fill  fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素，并返回修改后的数组，不包括终止索引。  参数value用来填充数组元素的值，start（可选）起始索引，默认为0，end（可选）终止索引，默认为this.length  不改变自身的方法  基于 ES7，不会改变自身的方法也有 9 个，分别为 concat、join、slice、toString、toLocaleString、indexOf、lastIndexOf、未形成标准的 toSource，以及 ES7 新增的方法 includes。  另外这里面需要注意的就是，slice不改变自身，而splice改变自身，其中，slice 的语法是：arr.slice([start[, end]])，而 splice 的语法是：arr.splice(start,deleteCount[, item1[, item2[, …]]])。我们可以看到从第二个参数开始，二者就已经有区别了，splice 第二个参数是删除的个数，而 slice 的第二个参数是 end 的坐标（可选）。  concat  concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。  join  join() 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。  slice  slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。  indexOf  indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。  lastIndexOf  lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。  includes  includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false。  数组遍历的方法  基于 ES6，不会改变自身的遍历方法一共有 14 个，分别为 forEach、every、some、filter、map、reduce、reduceRight，以及 ES6 新增的方法 entries、find、findLast、findIndex、findLastIndex、keys、values。  forEach  forEach() 方法对数组的每个元素执行一次给定的函数，注意不返回值  arr.forEach(callback(currentValue [, index [, array]])[, thisArg])   every  every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。  arr.every(callback(element[, index[, array]])[, thisArg])   some  some() 方法测试数组中是不是至少有 1 个元素通过了被提供的函数测试。它返回的是一个 Boolean 类型的值。  arr.some(callback(element[, index[, array]])[, thisArg])   filter  filter() 方法创建一个新数组，其包含通过所提供函数实现的测试的所有元素。注意它返回一个新数组  var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])   map  map() 方法创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。注意它返回一个新数组。  var new_array = arr.map(function callback(currentValue[, index[, array]]) {  // Return element for new_array }[, thisArg])    reduce  reduce() 方法对数组中的每个元素按序执行一个由您提供的 reducer 函数，每一次运行 reducer 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。  第一次执行回调函数时，不存在“上一次的计算结果”。如果需要回调函数从数组索引为 0 的元素开始执行，则需要传递初始值。否则，数组索引为 0 的元素将被作为初始值 initialValue，迭代器将从第二个元素开始执行（索引为 1 而不是 0）。  // Arrow function reduce((previousValue, currentValue) =&gt; { /* ... */ } ) reduce((previousValue, currentValue, currentIndex) =&gt; { /* ... */ } ) reduce((previousValue, currentValue, currentIndex, array) =&gt; { /* ... */ } ) reduce((previousValue, currentValue, currentIndex, array) =&gt; { /* ... */ }, initialValue)  // Callback function reduce(callbackFn) reduce(callbackFn, initialValue)  // Inline callback function reduce(function(previousValue, currentValue) { /* ... */ }) reduce(function(previousValue, currentValue, currentIndex) { /* ... */ }) reduce(function(previousValue, currentValue, currentIndex, array) { /* ... */ }) reduce(function(previousValue, currentValue, currentIndex, array) { /* ... */ }, initialValue)    keys  keys() 方法返回一个包含数组中每个索引键的Array Iterator对象。  values  values() 方法返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值。  entries  entries() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。  var arr = [\"a\", \"b\", \"c\"]; var iterator = arr.entries(); console.log(iterator.next());  /*{value: Array(2), done: false}           done:false           value:(2) [0, \"a\"]            __proto__: Object */ // iterator.next() 返回一个对象，对于有元素的数组， // 是 next{ value: Array(2), done: false }； // next.done 用于指示迭代器是否完成：在每次迭代时进行更新而且都是 false， // 直到迭代器结束 done 才是 true。 // next.value 是一个 [\"key\",\"value\"] 的数组，是返回的迭代器中的元素值。     find/findLast  find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。  findLast() 方法返回数组中满足提供的测试函数条件的最后一个元素的值。如果没有找到对应元素，则返回 undefined。  arr.find(callback[, thisArg])  // Arrow function findLast((element) =&gt; { /* ... */ } ) findLast((element, index) =&gt; { /* ... */ } ) findLast((element, index, array) =&gt; { /* ... */ } )  // Callback function findLast(callbackFn) findLast(callbackFn, thisArg)  // Inline callback function findLast(function(element) { /* ... */ }) findLast(function(element, index) { /* ... */ }) findLast(function(element, index, array){ /* ... */ }) findLast(function(element, index, array) { /* ... */ }, thisArg)   findIndex/findLastIndex  findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。  findLastIndex() 方法返回数组中满足提供的测试函数条件的最后一个元素的索引。若没有找到对应元素，则返回 -1。  arr.findIndex(callback[, thisArg])  // Arrow function findLastIndex((element) =&gt; { /* ... */ } ) findLastIndex((element, index) =&gt; { /* ... */ } ) findLastIndex((element, index, array) =&gt; { /* ... */ } )  // Callback function findLastIndex(callbackFn) findLastIndex(callbackFn, thisArg)  // Inline callback function findLastIndex(function(element) { /* ... */ }) findLastIndex(function(element, index) { /* ... */ }) findLastIndex(function(element, index, array){ /* ... */ }) findLastIndex(function(element, index, array) { /* ... */ }, thisArg)   数组总结  这里面需要注意一些返回数组的方法，比如：reverse、sort、copyWithin、fill、concat、slice、filter、map，同时也注意前面四个返回原数组，即改变自身，后面四个返回新数组，即不改变自身。                 数组\\分类       改变自身的方法       不改变自身的方法       遍历方法（不改变自身）                       ES5及以前       pop、push、reverse、shift、sort、splice、unshift       concat、join、slice、toString、toLocateString、indexOf、lastIndexOf       forEach、every、some、filter、map、reduce、reduceRight                 ES6/7/8       copyWithin、fill       includes、toSource       entries、find、findLast、findIndex、findLastIndex、keys、values           同时以上这些方法之间还存在很多共性，如下：          所有插入元素的方法，比如 push、unshift 一律返回数组新的长度；           所有删除元素的方法，比如 pop、shift、splice 一律返回删除的元素，或者返回删除的多个元素组成的数组；           部分遍历方法，比如 forEach、every、some、filter、map、find、findIndex，它们都包含 function(value,index,array){} 和 thisArg 这样两个形参。      类数组  我们日常开发者中经常会遇到类数组对象，最常见的便是在函数中使用的arguments，它的对象只定义在函数体中，包括了函数的参数和其他属性。  如下代码实例：  function foo(name, age, sex) {     console.log(arguments);     console.log(typeof arguments);  // 'object'     console.log(Object.prototype.toString.call(arguments));  // [object Arguments] } foo('yuxingxin', '28', 'male');   从结果中可以看到，typeof 这个 arguments 返回的是 object，通过 Object.prototype.toString.call 返回的结果是 ‘[object arguments]’，可以看出来返回的不是 ‘[object array]’，说明 arguments 和数组还是有区别的。  另外length属性表示函数参数的长度，callee属性代表函数自身，如果在函数内部直接执行调用 callee 的话，那它就会不停地执行当前函数，直到执行到内存溢出。  除此之外，还有其他类数组，比如下面的HTMLCollection和NodeList  HTMLCollection  HTMLCollection 简单来说是 HTML DOM 对象的一个接口，这个接口包含了获取到的 DOM 元素集合，返回的类型是类数组对象，如果用 typeof 来判断的话，它返回的是 ‘object’。它是及时更新的，当文档中的 DOM 变化时，它也会随之变化。  NodeList  NodeList 对象是节点的集合，通常是由 querySlector 返回的。NodeList 不是一个数组，也是一种类数组。虽然 NodeList 不是一个数组，但是可以使用 for…of 来迭代。在一些情况下，NodeList 是一个实时集合，也就是说，如果文档中的节点树发生变化，NodeList 也会随之变化。  应用场景  遍历参数  我们在函数内部可以直接获取 arguments 这个类数组的值，那么也可以对于参数进行一些操作  定义链接字符串函数  我们可以通过 arguments 这个例子定义一个函数来连接字符串。这个函数唯一正式声明了的参数是一个字符串，该参数指定一个字符作为衔接点来连接字符串。该函数定义如下：  function myConcat(separa) {   var args = Array.prototype.slice.call(arguments, 1);   return args.join(separa); } myConcat(\", \", \"red\", \"orange\", \"blue\"); // \"red, orange, blue\" myConcat(\"; \", \"elephant\", \"lion\", \"snake\"); // \"elephant; lion; snake\" myConcat(\". \", \"one\", \"two\", \"three\", \"four\", \"five\"); // \"one. two. three. four. five\"   传递参数  // 使用 apply 将 foo 的参数传递给 bar function foo() {     bar.apply(this, arguments); } function bar(a, b, c) {    console.log(a, b, c); } foo(1, 2, 3)   //1 2 3   上述代码中，通过在 foo 函数内部调用 apply 方法，用 foo 函数的参数传递给 bar 函数，这样就实现了借用参数的妙用。  类数组借用数组方法转换为数组  function sum(a, b) {   let args = Array.prototype.slice.call(arguments);  // let args = [].slice.call(arguments); // 这样写也是一样效果   console.log(args.reduce((sum, cur) =&gt; sum + cur)); } sum(1, 2);  // 3  function sum(a, b) {   let args = Array.prototype.concat.apply([], arguments);   console.log(args.reduce((sum, cur) =&gt; sum + cur)); } sum(1, 2);  // 3  // 借助ES6新增的Array.from和展开运算符 function sum(a, b) {   let args = Array.from(arguments);   console.log(args.reduce((sum, cur) =&gt; sum + cur)); } sum(1, 2);    // 3  function sum(a, b) {   let args = [...arguments];   console.log(args.reduce((sum, cur) =&gt; sum + cur)); } sum(1, 2);    // 3  function sum(...args) {   console.log(args.reduce((sum, cur) =&gt; sum + cur)); } sum(1, 2);    // 3   总结  数组和类数组还是有一些区别的，这里可以通过一个表格来重新梳理一下两者的异同点                 方法\\特点       数组       类数组                       自带方法       多个方法       无                 length属性       有       有                 callee属性       无       有"
  },
  
  {
    "title": "JavaScript基础之闭包原理",
    "url": "/posts/javascript-closure/",
    "categories": "JavaScript",
    "tags": "closure",
    "date": "2018-03-13 00:00:00 +0800",
    "content": "闭包是JavaScript中重要的概念，并且与作用域紧密相关，这里做个总结。在闭包之前，我们先对作用域做下基本介绍。  作用域  JavaScript 的作用域通俗来讲，就是指变量能够被访问到的范围，在 JavaScript 中作用域也分为好几种，ES5 之前只有全局作用域和函数作用域两种。ES6 出现之后，又新增了块级作用域。接下来我们一一介绍。  全局作用域  在编程语言中，变量通常被分为全局变量和局部变量两种，那么变量定义在最外部，代码前面的一般情况下都是全局变量，在JavaScript中，全局变量是挂在window对象下面，所以在网页中的任何位置都可以使用并且访问它。  var globalVar = 'global var'; function getGlobalVar() {     console.log(globalVar);  // global var     var localVar = 'local var';      console.log(localVar)   // local var }  getGlobalVar()  console.log(localVar)  // 报错 console.log(globalVar)  // global var console.log(window.globalVar)  // global var   从上面实例中可以看出，globalVar在什么地方都可以访问的到，所以它就是全局变量。而变量localVar就不具备这样的能力。另外全局变量也有全局的作用域，在控制台可以通过window对象访问它。  当然全局作用域有相应的缺点，我们定义很多全局变量的时候，会容易引起变量命名的冲突，所以在定义变量的时候应该注意作用域的问题。  函数作用域  在 JavaScript 中，函数中定义的变量叫作函数变量，这个时候只能在函数内部才能访问到它，所以它的作用域也就是函数的内部，称为函数作用域。  function getLocalVar() {     var localVar = 'local var';      console.log(localVar)   // local var } getLocalVar() console.log(localVar)  // 报错   上面实例中，localVar变量是在函数内部中定义的，所以它是一个局部变量，它的作用域就是函数内部，也称函数作用域。除了函数内部以外，其他地方是无法访问到它的，同时，当这个函数被执行完之后，这个局部变量也相应会被销毁。所以你会看到在 getLocalVar 函数外面的 localVar 是访问不到的。  块级作用域  ES6 中新增了块级作用域，最直接的表现就是新增的 let 关键词，使用 let 关键词定义的变量只能在块级作用域中被访问，有“暂时性死区”的特点，也就是说这个变量在定义之前是不能被使用的。 所谓的块其实就是在 JS 编码过程中 if 语句及 for 语句后面 {…} 这里面所包括的，就是块级作用域。  console.log(a)  //报错 if(true){     let a = 1;     console.log(1)  // 1 }  console.log(a)  // 报错   从这段代码可以看出，变量 a 是在 if 语句{…} 中由 let 关键词进行定义的变量，所以它的作用域是 if 语句括号中的那部分，而在外面进行访问 a 变量是会报错的，因为这里不是它的作用域。所以在 if 代码块的前后输出 a 这个变量的结果，控制台会报错显示 a 并没有被定义。  闭包  摘录一段红宝书和MDN中的定义：     红宝书：闭包是指有权访问另外一个函数作用域中的变量的函数。 MDN：一个函数和对其周围状态的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。   概念  通俗的讲，闭包其实就是一个可以访问其他函数内部变量的函数。即一个定义在函数内部的函数，或者直接说闭包是个内嵌函数也可以。  因为通常情况下，函数内部变量是无法在外部访问的（即全局变量和局部变量的区别），因此使用闭包的作用，就具备实现了能在外部访问某个函数内部变量的功能，让这些内部变量的值始终可以保存在内存中。  function fun() {     var a = 1;     return function() {         console.log(a);     }; }  fun(); var result = fun(); result();  // 1   结合闭包的概念，以及前面对作用域的铺垫，那么可以很清楚地发现，a 变量作为一个 fun 函数的内部变量，正常情况下作为函数内的局部变量，是无法被外部访问到的。但是通过闭包，我们最后还是可以拿到 a 变量的值。  闭包产生的原因-作用域链  我们在前面介绍了作用域的概念，那么你还需要明白作用域链的基本概念。其实很简单，当访问一个变量时，代码解释器会首先在当前的作用域查找，如果没找到，就去父级作用域去查找，直到找到该变量或者不存在父级作用域中，这样的链路就是作用域链。 需要注意的是，每一个子函数都会拷贝上级的作用域，形成一个作用域的链条。  var a = 1; function fun1() {     var a = 2;     function fun2() {         var a = 3;         console.log(a);     } }   从中可以看出，fun1 函数的作用域指向全局作用域（window）和它自己本身；fun2 函数的作用域指向全局作用域 （window）、fun1 和它本身；而作用域是从最底层向上找，直到找到全局作用域 window 为止，如果全局还没有的话就会报错。这样一来，当前函数一般都会存在上层函数的作用域的引用，那么他们就形成了一条作用域链。  由此可见，闭包产生的本质就是：当前环境中存在指向父级作用域的引用。  function fun1() {     var a = 2;     function fun2() {         console.log(a);     }     return fun2; }  var result = fun1(); result()   // 2   从上面实例可以看出，这里 result 会拿到父级作用域中的变量，输出 2。因为在当前环境中，含有对 fun2 函数的引用，fun2 函数恰恰引用了 window、fun1 和 fun2 的作用域。因此 fun2 函数是可以访问到 fun1 函数的作用域的变量。  其实上面这里不返回函数也可以产生闭包，我们只需要让父作用域的引用存在即可。  var fun3; function fun1() {     var a = 2;     fun3 = function() {         console.log(a);     } } fun1();  fun3();   可以看出，其中实现的结果和前一段代码的效果其实是一样的，就是在给 fun3 函数赋值后，fun3 函数就拥有了 window、fun1 和 fun3 本身这几个作用域的访问权限；然后还是从下往上查找，直到找到 fun1 的作用域中存在 a 这个变量；因此输出的结果还是 2，最后产生了闭包，形式变了，本质没有改变。 因此最后返回的不管是不是函数，也都不能说明没有产生闭包。  闭包的表现形式          返回一个函数，上面讲原因的时候已经说过，这里就不赘述了。           在定时器、事件监听、Ajax 请求、Web Workers 或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。      // 定时器 setTimeout(function handler(){   console.log('1'); }，1000); // 事件监听 $('#app').click(function(){   console.log('Event Listener'); });                作为函数参数传递的形式      var a = 1; function foo(){   var a = 2;   function baz(){     console.log(a);   }   bar(baz); } function bar(fn){   // 这就是闭包   fn(); } foo();  // 输出2，而不是1                IIFE（立即执行函数），创建了闭包，保存了全局作用域（window）和当前函数的作用域，因此可以输出全局的变量         var a = 2;    (function IIFE(){      console.log(a);  // 输出2    })();   IIFE 这个函数会稍微有些特殊，算是一种自执行匿名函数，这个匿名函数拥有独立的作用域。这不仅可以避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域，我们经常能在高级的 JavaScript 编程中看见此类函数。  闭包产生的问题  一个常见的问题就是循环输出问题，代码如下：  for(var i = 1; i &lt;= 5; i ++){   setTimeout(function() {     console.log(i)   }, 0) }   上面执行结果是5个6，先来看下输出5个6的原因是什么？     setTimeout 为宏任务，由于 JS 中单线程 eventLoop 机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后 setTimeout 中的回调才依次执行。   因为 setTimeout 函数也是一种闭包，往上找它的父级作用域链就是 window，变量 i 为 window 上的全局变量，开始执行 setTimeout 之前变量 i 已经就是 6 了，因此最后输出的连续就都是 6。   但是如果想让输出1,2,3,4,5的话，如何修改呢 ？  利用IIFE  可以利用 IIFE（立即执行函数），当每次 for 循环时，把此时的变量 i 传递到定时器中，然后执行，改造之后的代码如下。  for(var i = 1;i &lt;= 5;i++){   (function(j){     setTimeout(function timer(){       console.log(j)     }, 0)   })(i) }   使用ES6中的let  ES6 中新增的 let 定义变量的方式，使得 ES6 之后 JS 发生革命性的变化，让 JS 有了块级作用域，代码的作用域以块级为单位进行执行。通过改造后的代码，可以实现上面想要的结果。  for(let i = 1; i &lt;= 5; i++){   setTimeout(function() {     console.log(i);   },0) }   从上面的代码可以看出，通过 let 定义变量的方式，重新定义 i 变量，则可以用最少的改动成本，解决该问题。  定时器传入第三个参数  setTimeout 作为经常使用的定时器，它是存在第三个参数的，日常工作中我们经常使用的一般是前两个，一个是回调函数，另外一个是时间，而第三个参数用得比较少。那么结合第三个参数，调整完之后的代码如下。  for(var i=1;i&lt;=5;i++){   setTimeout(function(j) {     console.log(j)   }, 0, i) }   从中可以看到，第三个参数的传递，可以改变 setTimeout 的执行逻辑，从而实现我们想要的结果，这也是一种解决循环输出问题的途径。"
  },
  
  {
    "title": "JavaScript基础之new、apply、call、bind实现原理",
    "url": "/posts/javascript-keywords/",
    "categories": "JavaScript",
    "tags": "关键字",
    "date": "2018-03-09 00:00:00 +0800",
    "content": "在 javascript 中，new通常被用来创建一个对象，call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。而bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。  new关键词原理  new 关键词的主要作用就是执行一个构造函数、返回一个实例对象，在 new 的过程中，根据构造函数的情况，来确定是否可以接受参数的传递，我们先看一段代码：  function Person() {     this.name = 'yuxingxin'; } let p = new Person(); console.log(p.name);   // yuxingxin   这段代码从结果可以看出p是通过一个构造函数生成的实例对象，那么new这个关键词在这个过程中都发生了什么呢 ？我们用伪代码来模拟一下过程：  new Person() = {     var p = {};     p.__proro__ = Person.prototype;     var res = Person.call(this);     return typeof res === 'object'? res : p }   总结下来大致分为这么几步：     创建一个新的空对象{}   设置这个对象原型指向构造函数，即this指向新对象   执行构造函数，为这个新对象添加属性   返回新创建的对象   当上面构造函数中存在return语句时，结果就又不一样了。  function Person() {     this.name = 'yuxingxin';     return {age: 28}; }  var p = new Person(); console.log(p)  // {age: 28} console.log(p.name) // undefined console.log(p.age)  // 28   通过这段代码又可以看出，当构造函数最后 return 出来的是一个和 this 无关的对象时，new 命令会直接返回这个新对象，而不是通过 new 执行步骤生成的 this 对象。  但是这里要求构造函数必须是返回一个对象，如果返回的不是对象，那么还是会按照 new 的实现步骤，返回新生成的对象。如下实例：  function Person() {     this.name = 'yuxingxin';     return \"宇行信\"; }  var p = new Person(); console.log(p)  // {name: 'yuxingxin'} console.log(p.name) // yuxingxin   可以看出，当构造函数中 return 的不是一个对象时，那么它还是会根据 new 关键词的执行逻辑，生成一个新的对象（绑定了最新 this），最后返回出来。 因此我们总结一下：new 关键词执行之后总是会返回一个对象，要么是实例对象，要么是 return 语句指定的对象。  apply、call、bind原理  我们先来看下这三个函数的基本语法：     func.call(thisArg, param1, param2, …) func.apply(thisArg, [param1,param2,…]) func.bind(thisArg, param1, param2, …)   其中 func 是要调用的函数，thisArg 一般为 this 所指向的对象，后面的 param1、2 为函数 func 的多个参数，如果 func 不需要参数，则后面的 param1、2 可以不写。 这三个方法共有的、比较明显的作用就是，都可以改变函数 func 的 this 指向。call 和 apply 的区别在于，传参的写法不同：apply 的第 2 个参数为数组； call 则是从第 2 个至第 N 个都是给 func 的传参；而 bind 和这两个（call、apply）又不同，bind 虽然改变了 func 的 this 指向，但不是马上执行，而这两个（call、apply）是在改变了函数的 this 指向之后立马执行。  let yuxingxin = {     name: 'yuxingxin',     getName: function(msg){         return msg+this.name;     } }  let zhangsan = {     name: 'zhangsan' }  console.log(yuxingxin.getName('I am '))   // I am yuxingxin console.log(yuxingxin.getName.call(zhangsan, 'I am '))  // I am zhangsan console.log(yuxingxin.getName.apply(zhangsan, ['I am ']))  // I am zhangsan   let name = yuxingxin.getName.bind(zhangsan, 'I am '); console.log(name())  // I am zhangsan   从上面的代码执行的结果中可以发现，使用这三种方式都可以达成我们想要的目标，即通过改变 this 的指向，让 一个对象可以直接使用 另一个对象中的 getName 方法。从结果中可以看到，最后三个方法输出的都是预期的结果。  方法的应用场景  判断数据类型  用Object.prototype.toString来判断类型是最合适的，借用它我们可以几乎判断所有的类型。  function getType(obj) {     let type = typeof obj     if(type !== 'object'){         return type     }     return Object.prototype.toString.call(obj).replace(/^\\[object (\\S+)\\]$/,'$1') }   结合上面这段代码，以及在前面讲的 call 的方法的 “借用” 思路，那么判断数据类型就是借用了 Object 的原型链上的 toString 方法，最后返回用来判断传入的 obj 的字符串，来确定最后的数据类型，这里就不再多做讲解了。  类数组借用方法  var programs = {     0: 'java',     1: 'javascript',     length: 2 } Array.prototype.push.call(programs, 'C++', 'C#'); console.log(typeof programs)   // 'object console.log(programs)  // {0: 'java', 1: 'javascript', 2: 'C++', 3: 'C#', lenght: 4}   从上面的代码可以看出，programs是一个对象，模拟数组的一个类数组。从数据类型上看，它是一个对象。用 typeof 来判断输出的是 ‘object’，它自身是不会有数组的 push 方法的，这里我们就用 call 的方法来借用 Array 原型链上的 push 方法，可以实现一个类数组的 push 方法，给 programs 添加新的元素。  获取数组最大/最小值  let array = [12,6,9,3]; const max = Math.max.apply(Math, array); const min = Math.min.apply(Math, array);  console.log(max)  // 12 console.log(min)  // 3   继承  在继承实现方式中，有一种组合继承，代码如下：  function Parent(name) {     this.name = name;     this.content = [1,2,3];          this.getContent1 = function() {         return this.content     } }  Parent.prototype.getContent = function() {     console.log(this.content); }  function Child(name) {     Parent.call(this, name)  // 创建子类实例时执行一次 }  Child.prototype = new Parent();  // 指定子类原型会执行一次 Child.prototype.constructor = Child; // 校正构造函数  var child1 = new Child(\"这是子类1\"); child1.content.push(4); console.log(child1.getContent())  // Array [1,2,3,4] console.log(child1.getContent1())  // Array [1,2,3,4]  var child2 = new Child(\"这是子类2\"); child2.content.push(5);   console.log(child2.getContent1())  // Array [1,2,3,5]    手写实现方法  new手写实现  回顾一下上面new的执行过程，大致做了这几件事情：          让实例可以访问到私有属性；           让实例可以访问构造函数原型（constructor.prototype）所在原型链上的属性；           构造函数返回的最后结果是引用数据类型。      代码实现如下：  function _new() {     var obj = new Object();     var constructor = [].shift.call(arguments); // 拿到arguments中的第一个参数，即构造函数constructor;     if(constructor.prototype !== null) {         obj.__proto__ = constructor.prototype;     }     var ret = constructor.apply(obj, arguments);     let isObject = typeof res === 'object' &amp;&amp; res !== null;          let isFunction = typeof res === 'function';     // 如果传入的构造函数已经指定返回的对象，那么就返回该对象，否则返回内部构造的obj。     return isObject || isFunction? res: obj; }  /**  1.new关键字会首先创建一个空对象 2.将这个空对象的原型对象指向构造函数的原型属性，从而继承原型上的方法 3.将this指向这个空对象，执行构造函数中的代码，以获取私有属性 4.如果构造函数返回了一个对象res，就将该返回值res返回，如果返回值不是对象，就将创建的对象返回 */ function _new(ctor, ...args) {     if(typeof ctor !== 'function') {         throw 'ctor must be a function';     }      let obj = new Object();     obj.__proto__ = Object.create(ctor.prototype);     let res = ctor.apply(obj, [...args]);     let isObject = typeof res === 'object' &amp;&amp; res !== null;          let isFunction = typeof res === 'function';     // 如果传入的构造函数已经指定返回的对象，那么就返回该对象，否则返回内部构造的obj。     return isObject || isFunction? res: obj; }   总结下：          new产生一个新对象;           拿到传入的参数中的第一个参数，即构造函数constructor;           执行构造函数，并将this指向创建的空对象obj;           将传入构造函数的参数，在obj上下文中执行一遍;           如果构造函数返回一个对象，则直接返回这个对象；      apply和call方法手写实现  由于apply和call方法实现的基本原理差不多，都是借助eval来实现，只是参数不同，这里放一起来看。  Function.prototype.apply = function(context, ...args) {     var context = context || window;     context.fn = this;     var result = eval('context.fn(...agrs)');     delete context.fn;     return result; } Function.prototype.call = function(context, ...args) {     var context = context || window;     context.fn = this;     var result = eval('context.fn(...agrs)');     delete context.fn;     return result; }   从上面的代码可以看出，实现 call 和 apply 的关键就在 eval 这行代码。其中显示了用 context 这个临时变量来指定上下文，然后还是通过执行 eval 来执行 context.fn 这个函数，最后返回 result。 要注意这两个方法和 bind 的区别就在于，这两个方法是直接返回执行结果，而 bind 方法是返回一个函数，因此这里直接用 eval 执行得到结果。  bind手写实现  bind实现和上面最大的变化就是返回结果这里不同，他不需要执行，而是通过返回一个函数的方式将结果返回，之后再执行这个结果，得到想要的效果。  Function.prototype.bind = function(context, ...args) {     if(typeof this !== 'function') {         throw new Error('this must be a function')     }     var self = this;          var fbound = function() { //绑定函数被当做普通函数调用（context）或者被当做构造函数使用（this）         self.apply(this instanceof self ? this: context, args.concat(Array.prototype.slice.call(arguments));     }     // 修正new调用带来的this指向绑定问题     if(this.prototype) {         fbound.prototype = Object.create(this.prototype)     }     return fbound; }   从上面的代码中可以看到，实现 bind 的核心在于返回的时候需要返回一个函数，故这里的 fbound 需要返回，但是在返回的过程中原型链对象上的属性不能丢失。因此这里需要用Object.create 方法，将 this.prototype 上面的属性挂到 fbound 的原型上面，最后再返回 fbound。这样调用 bind 方法接收到函数的对象，再通过执行接收的函数，即可得到想要的结果。  总结  最后我们一起梳理一下这些方法的异同点，表格如下：                 方法/特点       call       apply       bind                       方法参数       多个       单个数组       多个                 方法功能       函数调用改变this       函数调用改变this       函数调用改变this                 返回结果       直接执行       直接执行       返回待执行函数                 底层实现       通过eval       通过eval       间接调用apply"
  },
  
  {
    "title": "JavaScript基础之继承实现",
    "url": "/posts/javascript-inherit/",
    "categories": "JavaScript",
    "tags": "继承",
    "date": "2018-03-06 00:00:00 +0800",
    "content": "继承可以使得子类具有父类的方法和属性，同时也可以重新定义父类的某些属性，并重写或者覆盖某些属性和方法。使得子类具有与父类不同的属性和方法。  接下来我们就来一起看看实现继承的几种方式  1. 原型链继承  原型链继承是比较常见的继承方式之一，其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。其中涉及的构造函数、原型和实例，三者之间存在着一定的关系，即每一个构造函数都有一个原型对象（构造函数的prototype属性），原型对象又包含一个指向构造函数的指针（原型对象的constructor属性），而实例则包含一个原型对象的指针（实例对象的__proto__属性）。  function Parent() {     this.name = \"这是父类\";     this.content = [1,2,3]; }  Parent.prototype.getContent = function() {     console.log(this.content); }  function Child() {      }  Child.prototype = new Parent();  var child1 = new Child(); child1.content.push(4); console.log(child1.getContent())  // Array [1,2,3,4]  var child2 = new Child(); child2.content.push(5);   console.log(child2.getContent())  // Array [1,2,3,4,5]   虽然上面子类可以复用父类的属性和方法，但是这里面存在着一个问题：两个实例共用一个原型对象，它们的内存空间是共享的，当一个发生变化的时候，另外一个也随之进行了变化。下面我们看看其他继承方式如何解决这个问题  2. 构造函数继承  function Parent(name) {     this.name = name;     this.content = [1,2,3];          this.getContent1 = function() {         return this.content     } }  Parent.prototype.getContent = function() {     console.log(this.content); }  function Child(name) {     Parent.call(this, name) }  var child1 = new Child(\"这是子类1\"); child1.content.push(4); console.log(child1.getContent())  // 报错 console.log(child1.getContent1())  // Array [1,2,3,4]  var child2 = new Child(\"这是子类2\"); child2.content.push(5);   console.log(child2.getContent1())  // Array [1,2,3,5]    从上面实例我们也可以总结该方法的优缺点：  优点：     解决了第一种继承方式的缺点，即避免了引用类型属性被所有实例共享   可以直接在Child中向Parent传参   缺点：     只能继承父类的实例属性和方法，不能继承其原型属性或者方法。   那么上面两者都有不足的地方， 我们可以组合上面两种实现方式  3. 组合继承  function Parent(name) {     this.name = name;     this.content = [1,2,3];          this.getContent1 = function() {         return this.content     } }  Parent.prototype.getContent = function() {     console.log(this.content); }  function Child(name) {     Parent.call(this, name)  // 创建子类实例时执行一次 }  Child.prototype = new Parent();  // 指定子类原型会执行一次 Child.prototype.constructor = Child; // 校正构造函数  var child1 = new Child(\"这是子类1\"); child1.content.push(4); console.log(child1.getContent())  // Array [1,2,3,4] console.log(child1.getContent1())  // Array [1,2,3,4]  var child2 = new Child(\"这是子类2\"); child2.content.push(5);   console.log(child2.getContent1())  // Array [1,2,3,5]   从上面实例可以看出，组合继承解决了前面提到的两个问题，既具有原型链继承能够复用函数的特性，又有借用构造函数方式能够保证每个子类实例能够拥有自己的属性以及向父类传参的特性，但组合继承也并不是完美实现继承的方式，因为这种方式在创建子类时会调用两次父类的构造函数，这是我们不愿意看到的，因为每一次的调用都会是一次性能开销，接着看我们如何解决这个问题。  4. 原型式继承  ECMAScript5通过新增Object.create()方法规范化了原型式继承，这个方法接收两个参数：一个用作新对象原型的对象和为新对象定义属性的对象（可选参数）。  let parent = {     name: '这是父类',     content: [1,2,3],          getContent: function() {         return this.content;     },     getName: function(){         return this.name;     } }  let child1 = Object.create(parent); child1.name = \"这是子类child1\" child1.content.push(4); console.log(child1.name);  // 这是子类child1 console.log(child1.name === child1.getName()) // true console.log(child1.getContent())  // Array [1,2,3,4]  let child2 = Object.create(parent); child2.content.push(5)  console.log(child2.getContent())  // Array [1,2,3,4,5]    通过以上代码也可以知道，这种继承方式缺点也很明显，多个实例引用类型属性指向相同的内存，接下来看如何优化它。  5. 寄生式继承  寄生式继承和上面的原型式继承密切相关，即创建一个仅用于封装继承函数过程的函数，在该函数内部以某种方式来增强对象，最后返回该对象。  let parent = {     name: '这是父类',     content: [1,2,3],          getContent: function() {         return this.content;     } }  function createChild(){     let child = Object.create(parent);     child.getName = function() {         return this.name;     }     return child; }  let child = createChild(); console.log(child.getName());    console.log(child.getContent());   该方式通过createChild函数在继承过程中又增加了一个getName方法，这样的继承方式就是寄生式继承。而上面第三点提到的性能开销问题，可以通过下面方式来解决:寄生式+组合继承  6. 寄生组合式继承  所谓寄生组合式继承，即通过构造函数来继承属性，通过原型链继承方法，背后的基本思路是：不必为了指定子类的原型而调用父类的构造函数，我们所需要的无非就是父类原型的一个副本而已。  function Parent() {     this.name = '这是父类';     this.content = [1,2,3]; }  Parent.prototype.getName = function() {     return this.name; }  function Child() {     Parent.call(this);     this.age = 18; }  function create(parent,child) {      //改变子类的原型，同时纠正构造函数     child.prototype = Object.create(parent.prototype);     child.prototype.constructor = child; }  create(Parent, Child); Child.prototype.getContent = function() {     return this.content; } var child1 = new Child();   console.log(child1.getName()) console.log(child1.getContent());   通过以上代码可以看出寄生组合继承的高效率在于它只调用了一次父类构造函数，同时还能够保持原型链不变，能够正常使用 instanceof 和 isPrototypeOf() ，寄生组合继承被普遍认为是引用类型最理想的继承方式。  ES6 关键字extends  最后我们一起来看下ES6的语法糖，深入底层逻辑研究extends是如何实现的，这里借助babel转换，代码如下：  class Parent {   constructor(name) {     this.name = name   }   // 原型方法   // 即 Person.prototype.getName = function() { }   // 下面可以简写为 getName() {...}   getName = function () {     console.log('Parent:', this.name)   } } class Child extends Person {   constructor(name, age) {     // 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。     super(name)     this.age = age   } } const child = new Child('yuxingxin', 32) child.getName() // 成功访问到父类的方法   我们借助Babel转译成ES5，来看下代码是如何实现的？  \"use strict\";  function _typeof(obj) {   \"@babel/helpers - typeof\";   return (     (_typeof =       \"function\" == typeof Symbol &amp;&amp; \"symbol\" == typeof Symbol.iterator         ? function (obj) {             return typeof obj;           }         : function (obj) {             return obj &amp;&amp;               \"function\" == typeof Symbol &amp;&amp;               obj.constructor === Symbol &amp;&amp;               obj !== Symbol.prototype               ? \"symbol\"               : typeof obj;           }),     _typeof(obj)   ); }  function _inherits(subClass, superClass) {   if (typeof superClass !== \"function\" &amp;&amp; superClass !== null) {     throw new TypeError(\"Super expression must either be null or a function\");   }   // 注意看这里   subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, {     constructor: { value: subClass, writable: true, configurable: true }   });   Object.defineProperty(subClass, \"prototype\", { writable: false });   if (superClass) _setPrototypeOf(subClass, superClass); }  function _setPrototypeOf(o, p) {   _setPrototypeOf = Object.setPrototypeOf     ? Object.setPrototypeOf.bind()     : function _setPrototypeOf(o, p) {         o.__proto__ = p;         return o;       };   return _setPrototypeOf(o, p); }  function _createSuper(Derived) {   var hasNativeReflectConstruct = _isNativeReflectConstruct();   return function _createSuperInternal() {     var Super = _getPrototypeOf(Derived),       result;     if (hasNativeReflectConstruct) {       var NewTarget = _getPrototypeOf(this).constructor;       result = Reflect.construct(Super, arguments, NewTarget);     } else {       result = Super.apply(this, arguments);     }     return _possibleConstructorReturn(this, result);   }; }  function _possibleConstructorReturn(self, call) {   if (call &amp;&amp; (_typeof(call) === \"object\" || typeof call === \"function\")) {     return call;   } else if (call !== void 0) {     throw new TypeError(       \"Derived constructors may only return object or undefined\"     );   }   return _assertThisInitialized(self); }  function _assertThisInitialized(self) {   if (self === void 0) {     throw new ReferenceError(       \"this hasn't been initialised - super() hasn't been called\"     );   }   return self; }  function _isNativeReflectConstruct() {   if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;   if (Reflect.construct.sham) return false;   if (typeof Proxy === \"function\") return true;   try {     Boolean.prototype.valueOf.call(       Reflect.construct(Boolean, [], function () {})     );     return true;   } catch (e) {     return false;   } }  function _getPrototypeOf(o) {   _getPrototypeOf = Object.setPrototypeOf     ? Object.getPrototypeOf.bind()     : function _getPrototypeOf(o) {         return o.__proto__ || Object.getPrototypeOf(o);       };   return _getPrototypeOf(o); }  function _defineProperties(target, props) {   for (var i = 0; i &lt; props.length; i++) {     var descriptor = props[i];     descriptor.enumerable = descriptor.enumerable || false;     descriptor.configurable = true;     if (\"value\" in descriptor) descriptor.writable = true;     Object.defineProperty(target, descriptor.key, descriptor);   } }  function _createClass(Constructor, protoProps, staticProps) {   if (protoProps) _defineProperties(Constructor.prototype, protoProps);   if (staticProps) _defineProperties(Constructor, staticProps);   Object.defineProperty(Constructor, \"prototype\", { writable: false });   return Constructor; }  function _classCallCheck(instance, Constructor) {   if (!(instance instanceof Constructor)) {     throw new TypeError(\"Cannot call a class as a function\");   } }  function _defineProperty(obj, key, value) {   if (key in obj) {     Object.defineProperty(obj, key, {       value: value,       enumerable: true,       configurable: true,       writable: true     });   } else {     obj[key] = value;   }   return obj; }  var Parent = /*#__PURE__*/ _createClass(   function Parent(name) {     _classCallCheck(this, Parent);      _defineProperty(this, \"getName\", function () {       console.log(\"Parent:\", this.name);     });      this.name = name;   } // 原型方法   // 即 Person.prototype.getName = function() { }   // 下面可以简写为 getName() {...} );  var Child = /*#__PURE__*/ (function (_Person) {   _inherits(Child, _Person);    var _super = _createSuper(Child);    function Child(name, age) {     var _this;      _classCallCheck(this, Child);      // 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。     _this = _super.call(this, name);     _this.age = age;     return _this;   }    return _createClass(Child); })(Person);  var child = new Child(\"yuxingxin\", 20); child.getName(); // 成功访问到父类的方法   从上面编译完的源代码也可以看出，它采用的也是寄生组合式继承的方式。  总结  通过 Object.create 来划分不同的继承方式，最后的寄生式组合继承方式是通过组合继承改造之后的最优继承方式，而 extends 的语法糖和寄生组合继承的方式基本类似。"
  },
  
  {
    "title": "JavaScript基础之原型与原型链的理解",
    "url": "/posts/javascript-prototype/",
    "categories": "JavaScript",
    "tags": "prototype",
    "date": "2018-03-02 00:00:00 +0800",
    "content": "理解原型与原型链对于我们实现继承、new关键字原理、甚至代码优化等非常重要，接下来我们对这块做一个总结。  概念  我们都知道，访问一个对象实例上的属性和方法时，首先在实例本身查找。 如果没有找到，会到实例对象的隐式属性__proto__上查找，就是该实例的构造函数的原型对象。如果还没有，会继续访问原型对象的原型,直到Object.prototype.__proto__(null)为止。这也是所有对象都有toString 方法的原因，因为toString方法是Object.prototype上面的方法。所有对象沿着原型链最终都会到Object.prototype.  这其中沿着__proto__查找属性的这一链条，就是我们说的原型链。     js分为函数对象和普通对象，每个对象都有__proto__属性，但是只有函数对象才有prototype属性，并指向函数的原型对象。Object、Function都是js内置的函数对象，类似的还有Array、RegExp、Date、Boolean、Number、String   属性__proto__是一个对象，来描述对象的原型，它有两个属性，分别是constructor和__proto__   原型对象prototype有一个默认的constructor属性，用于记录实例是由哪个构造函数创建的。   举例代码如下：    function Person() {     this.name = 'yuxingxin';     this.age = 28; }  let person = new Person()；   这里注意原型以及原型链的时候的两条准则：     准则1： 原型对象（即Person.prototype）的constructor指向构造函数本身    Person.prototype.constructor == Person    准则2：实例（即person）的__proto__和原型对象指向同一个地方，所有函数的原型对象的__proto__会指向Object.prototype    person.__proto__ == Person.prototype     我们来分析一下上面这张图：  Function是最顶层的构造器，Object是最顶层的对象；从原型链讲Function继承了Object，从构造器讲Function构造了Object  // 从上方function Foo()开始分析 function Foo() {}  let f1 = new Foo(); let f2 = new Foo();  f1.__proto__ = Foo.prototype;  // 准则2 f2.__proto__ = Foo.prototype;  // 准则2 Foo.prototype.__proto__ = Object.prototype; // 准则2  (Foo.prototype本质也是普通对象) Object.prototype.__proto__ = null; // 原型链到此停止  Foo.prototype.constructor = Foo;  // 准则1 Foo.__proto__ = Function.prototype;  // 准则2 Function.prototype.__proto__ = Object.prototype // 准则2 (Function.prototype本质也是普通对象) Object.prototype.__proto__ = null; // 原型链到此停止   // 从中间function Object()开始分析 function Object() {}  let o1 = new Object(); let o2 = new Object();  o1.__proto__ = Object.prototype;  //准则2 o2.__proto__ = Object.prototype;  //准则2 Object.prototype.__proto__ = null;  // 原型链到此停止 Object.prototype.constructor = Object;   // 准则1 Object.__proto__ = Function.prototype;  // 准则2 (Object本质也是函数)  Function.prototype.__proto__ = Object.prototype; // 准则2 (Function.prototype本质也是普通对象) Object.prototype.__proto__ = null;  // 原型链到此为止   // 从下方function Function()开始分析 function Function() {} Function.__proto__ = Function.prototype // 准则2 Function.prototype.constructor = Function  // 准则1   由此可以得出结论： 除了Object的原型对象（Object.prototype）的__proto__指向null，其他内置函数对象的原型对象（例如：Array.prototype）和自定义构造函数的 __proto__都指向Object.prototype, 因为原型对象本身是普通对象。  Object.prototype.__proto__ = null; Array.prototype.__proto__ = Object.prototype; Foo.prototype.__proto__  = Object.prototype;   普通函数可以通过new Function()创建，所以普通函数的__proto__指向Function.prototype。那么内置的这些函数同样属于函数，也是通过new Function()创建出来的函数对象，同理，他们的__proto__也指向Function.prototype  console.log(Object.__proto__ === Function.prototype)  // true console.log(Array.__proto__ === Function.prototype)   // true console.log(Number.__proto__ === Function.prototype)  // true console.log(String.__proto__ === Function.prototype)  // true console.log(Boolean.__proto__ === Function.prototype)  // true console.log(Date.__proto__ === Function.prototype)  // true   原型对象的作用，是用来存放实例中共有的那部份属性、方法，可以大大减少内存消耗。实例对象重写原型上继承的属相、方法，相当于“属性覆盖、属性屏蔽”，这一操作不会改变原型上的属性、方法，自然也不会改变由统一构造函数创建的其他实例，只有修改原型对象上的属性、方法，才能改变其他实例通过原型链获得的属性、方法。"
  },
  
  {
    "title": "JavaScript基础之对象深浅拷贝原理以及实现",
    "url": "/posts/javascript-deep-clone/",
    "categories": "JavaScript",
    "tags": "数据类型",
    "date": "2018-02-26 00:00:00 +0800",
    "content": "我们知道JavaScript数据类型分为基本数据类型和引用数据类型，对于基本数据类型，变量存储的是基本类型的值，而对于引用数据类型， 变量存储的是其在内存中的地址，而通常拷贝一个对象，又分为浅拷贝和深拷贝两种，下面我们分别来讨论这种拷贝的区别。  浅拷贝  复制一个对象，如果对象属性是基本数据类型，复制的就是基本类型的值给新对象，但如果是引用数据类型，复制的就是内存中的地址，如果其中一个对象改变了内存中的地址，肯定会影响到另一个对象。  接下来整理一些浅拷贝的方法，结合着我们上面的定义来理解：  1. Object.assign  这个方法是ES6中提供的方法，它常用于对象的合并，它的第一个参数为拷贝的目标对象，后面的参数是拷贝的源对象，当然也可以是多个源对象。     Object.assign(target, …sources)   举例：  let target = {} let source = {a: {b: 1}}; Object.assign(target, source);  source.a.b = 2  console.log(target)  // {a: {b: 2}} console.log(source)  // {a: {b: 2}}   但是该方法有几点需要注意：     它不会拷贝对象的继承属性   它不会拷贝对象的不可枚举属性   他可以拷贝Symbol类型的属性   来重新看下面这段代码：  let target = {} let source = {a: {b: 1}, sym: Symbol(1)}; Object.defineProperty('source','innumerable', {     value: \"这是一个不可枚举属性\",     enumerable: false }) Object.assign(target, source);  source.a.b = 2  console.log(target)  // {a: {b: 2}, sym: Symbol(1)} console.log(source)  // {a: {b: 2}, sym: Symbol(1), innumerable: \"这是一个不可枚举属性\"}   2. 扩展运算符  这个也是ES6新增的语法     let target = {…source}   举例如下：  let source = {a: 1, b: {c: 2}} let target = {...source}  source.a = 2 console.log(source)   // {a: 2, b:{c:2}} console.log(target)  //  {a: 1, b:{c:2}}  source.b.c = 3 console.log(source)  // {a: 2, b:{c:3}} console.log(target)  // {a: 1, b:{c:3}}  // 数组拷贝 let array = [1,2,3] let newArray = [...array] //跟array.slice()方法效果一样   通过上面例子可以看出扩展运算符同样具备浅拷贝的特性，如果是基本类型，使用它会更加方便  3. concat拷贝数组  该方法局限性在于只能浅拷贝数组，使用场景比较有限，需要值得注意的是它会修改原数组中农的元素属性，因此它会影响拷贝后连接的数组  let array = [1,2,3] let newArray = array.concat(); newArray[1] = 5 console.log(array) console.log(newArray)   4. slice拷贝数组  slice方法同上也只能应用于数组的浅拷贝，不过它返回一个新的数组对象，这一对象由该方法前两个参数决定原数组的开始和结束位置，是不会影响和改变原数组的  let array = [1,2,3,4,5,{val: 6}] let newArray = array.slice(2) newArray[3].val = 7 console.log(array)  // [1,2,3,4,5,{val:7}] console.log(newArray)  // [3,4,5,{val:7}]   从上面的例子可以看出，浅拷贝只能拷贝一层对象，如果存在对象的嵌套，那么浅拷贝就无能为力，因此如果想要拷贝多层对象，就需要用到深拷贝  所以大致实现一个浅拷贝的思路：     对于基础类型做一个基本的拷贝   对于引用类型，开辟一个新的内存空间，拷贝一层对象属性   跟着这个思路，我们实现一个自己的浅拷贝：  /** 基本类型拷贝其值 引用类型拷贝内存地址 不可枚举属性不拷贝 继承属性不拷贝 Symbol也可以拷贝 */ function shallowClone(source){     if(typeof source === 'object' &amp;&amp; source !== null) {         const target = Array.isArray(source)? []:{};         for(let prop in source){             if(source.hasOwnProperty(prop)) {                 target[prop] = source[prop]             }         }         return target     }else {         return source     } }   深拷贝  深拷贝对于复杂引用数据类型，在内存中完全开辟了一个新的内存地址，并将原来的对象完整复制过来，拷贝后的对象和原来的对象相互独立，互不影响，彻底实现了内存的分离，总结如下：     将一个对象从内存中完整地拷贝出来一份给目标对象，并从堆内存中开辟一个全新的空间存放新对象，且新对象的修改并不会改变原对象，二者实现真正的分离。   接下来整理一些深拷贝的方法，结合着我们上面的定义来理解：  1. JSON.stringfy  它借助JSON对象的方法把一个对象序列化成为JSON字符串，并将对象里面的内容转换成字符串，最后再用JSON.parse()方法将JSON字符串生成一个新的对象。  let source = {a: 1, b: [1,2,3]} let str = JSON.stringfy(source) let target = JSON.parse(str) console.log(target)  // {a:1, b: [1,2,3]} source.a = 2 source.b.push(4) console.log(source)  // {a:2, b: [1,2,3,4]} console.log(target)  // {a:1, b: [1,2,3]}   通过以上实例可以看出深拷贝的对象不受原来对象的影响，但是该方法也有需要注意的地方：     拷贝的对象的值中如果有函数、undefined、symbol 这几种类型，经过 JSON.stringify 序列化之后的字符串中这个键值对会消失；   拷贝 Date 引用类型会变成字符串；   无法拷贝不可枚举的属性；   无法拷贝对象的原型链；   拷贝 RegExp 引用类型会变成空对象；   对象中含有 NaN、Infinity 以及 -Infinity，JSON 序列化的结果会变成 null；   无法拷贝对象的循环应用，即对象成环 (obj[key] = obj)。   2. 简易版深拷贝实现  function deepClone(source){     let target = {};     for(let key in source){         if(typeof source[key] === 'object'){             target[key] = deepClone(source[key]);         }else{             target[key] = source[key];         }     }     return target; }   虽然上面实现一个深拷贝，但是还有一些问题没有解决：          这个深拷贝函数并不能复制不可枚举的属性以及 Symbol 类型；           这种方法只是针对普通的引用类型的值做递归复制，而对于 Array、Date、RegExp、Error、Function 这样的引用类型并不能正确地拷贝；           对象的属性里面成环，即循环引用没有解决。      针对上面这些问题，我们对此进行改进  3. 改进版深拷贝  针对上面提出的几个问题，我们先通过以下几个方法来分别解决          针对能够遍历对象的不可枚举属性以及 Symbol 类型，我们可以使用 Reflect.ownKeys 方法；           当参数为 Date、RegExp 类型，则直接生成一个新的实例返回；           利用 Object 的 getOwnPropertyDescriptors 方法可以获得对象的所有属性，以及对应的特性，顺便结合 Object 的 create 方法创建一个新对象，并继承传入原对象的原型链；           利用 WeakMap 类型作为 Hash 表，因为 WeakMap 是弱引用类型，可以有效防止内存泄漏（你可以关注一下 Map 和 weakMap 的关键区别，这里要用 weakMap），作为检测循环引用很有帮助，如果存在循环，则引用直接返回 WeakMap 存储的值。      function deepClone(src, hash=new WeakMap()) {     const isComplexType = (typeof src === 'object' || src === 'function') &amp;&amp; src !== null;      if(src.constructor === Date) {         return new Date(src)     }     if(src.constructor === RegExp) {         return new RegExp(src)     }     // 如果是循环引用，通过WeakMap来解决     if(hash.has(src)) return hash.get(src)     // 获取对象所有自有属性描述符     const allDesc = Object.getOwnPropertyDescriptors(src)     // 继承原型链     let cloneObj = Object.create(Object.getPrototypeOf(src), allDesc);     hash.set(src, cloneObj)     for(let key in Reflect.ownKeys(src)){         cloneObj[key] = (isComplexType(src[key]) &amp;&amp; typeof src[key] !== 'function' )? deepclone(src[key], hash): src[key]     }     return cloneObj; }   当然一个完整的深拷贝还远远不止于此，需要各种边界条件的判断，以及不同数据类型等，而实现完整的前提是需要我们对基础知识有足够的掌握，但上面已经可以满足我们日常的需求，感兴趣的也可以继续完善它。"
  },
  
  {
    "title": "JavaScript基础之数据类型及检测和转换",
    "url": "/posts/javascript-data-type/",
    "categories": "JavaScript",
    "tags": "数据类型",
    "date": "2018-02-15 00:00:00 +0800",
    "content": "数据类型  JavaScript数据类型一共分为8种：     Number（数值，包含NaN）   String（字符串）   Boolean（布尔值）   Undefined（未定义/未初始化）   Null（空对象）   Symbol（独一无二的值，ES6 新增）   BigInt （大整数，能够表示超过 Number 类型大小限制的整数，ES 2020新增）   Object（对象。Array/数组 和 function/函数 也属于对象的一种）   其中前7种为基本数据类型（原始值），最后一种为复杂数据类型(引用类型)，其中基础类型的值存储在栈内存，是不可变的，你无法修改值本身，只能代表它的变量对其重新赋值，而复杂数据类型存储在堆内存，是可变的，它们的值可以被修改。  而引用数据类型又分为几种常见的类型：     Array  数组类型   RegExp 正则对象   Date  日期对象   Math  数学函数   Function 函数对象   数据类型检测  数据类型检测也是平常写代码过程中经常会遇到的，这里总结了四种常见的数据类型检测方法：  1. typeof  这是一种比较常见的数据类型检测方法：  console.log(typeof 10)     // number console.log(typeof '10')   // string console.log(typeof undefined)  // undefined console.log(typeof true)       // boolean console.log(typeof Symbol())   // symbol console.log(typeof null)       // object console.log(typeof [])         // object console.log(typeof {})         // object console.log(typeof console)    // object console.log(typeof console.log)   //function   由上面的结果可知typeof只可以测试出number、string、boolean、symbol、undefined及function，而对于null及数组、对象，typeof均检测出为object，不能进一步判断它们的类型。  2. instanceof  通过instanceof对象我们可以判断出这个对象是否是之前那个构造函数生成的对象，其底层的一个的大致实现：  function isInstanceOf(left, right){     // 基本类型     if(typeof left != 'object' || left === 'null') return false;     var proto = Object.getPrototypeOf(left)     while(true){  // 循环往下找，直到找到相同的原型对象         if(proto === null) return false;         if(proto === right.prototype) return true;         proto = Object.getPrototypeOf(proto);     } }   举例如下：  let Parent = function() {} let parent1 = new Parent() parent1 instanceof Parent  // true  'Child' instanceof String // false   虽然instanceof可以检测出复杂的引用数据类型，但是对于基本数据类型却不能判断，所以不管是typeof还是instanceof都不能满足所有场景的需求，而只能结合两者才能实现判断  3. constructor  当一个函数 Fun被定义时，JS引擎会为Fun添加 prototype 原型，然后再在 prototype上添加一个 constructor 属性，并让其指向 Fun 的引用。  function Fun() {} var f = new Fun() f.constructor === Fun   // true  Fun.prototype = {} var f1 = new Fun() f1.constructor === Fun   // false   可以看出，Fun 利用原型对象上的 constructor 引用了自身，当 Fun 作为构造函数来创建对象时，原型上的 constructor 就被遗传到了新创建的对象上， 从原型链角度讲，构造函数 Fun 就是新对象的类型。这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。  但是这里面也有一些问题：     null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。   函数的 constructor 是不稳定的，不安全的，因为contructor的指向是可以改变的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object   4. Object.prototype.toString  toString() 是 Object 的原型方法，调用该方法，可以统一返回格式为 “[object Xxx]” 的字符串，其中 Xxx 就是对象的类型。对于 Object 对象，直接调用 toString() 就能返回 [object Object]；而对于其他对象，则需要通过 call 来调用，才能返回正确的类型信息。我们来看一下代码。  console.log(Object.prototype.toString.call(true));//[object Boolean] console.log(Object.prototype.toString.call(1));//[object Number] console.log(Object.prototype.toString.call('str'));//[object String] console.log(Object.prototype.toString.call(undefined));//[object Undefined] console.log(Object.prototype.toString.call(null));//[object Null] console.log(Object.prototype.toString.call([]));//[object Array] console.log(Object.prototype.toString.call({}));//[object Object] console.log(Object.prototype.toString.call(function(){});//[object Function] console.log(Object.prototype.toString.call(/456/g);//[object RegExp] console.log(Object.prototype.toString.call(new Date());//[object Date] console.log(Object.prototype.toString.call(document);//[object HTMLDocument] console.log(Object.prototype.toString.call(window);//[object Window]   从上面实例可以看出使用这个方法可以返回统一的字符串格式”[Object Xxx]” ，其中首字母大写，和typeof刚好相反  到目前为止我们可以实现一个全局通用的数据类型判断方法，代码如下：  function getType(obj) {     let type = typeof obj     if(type !== 'object'){  // 先对基础数据类型进行判断         return type     }     // return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();     return Object.prototype.toString.call(obj).replace(/^\\[object (\\S+)\\]$/,'$1') }   数据类型转换  数据类型转换主要分显式类型转换和隐式类型转换  显式类型转换  其中显式类型转换的常见方法有：     Number()   parseInt()   parseFloat()   toString()   String()   Boolean()   这里参考了 ECMA-262 的官方文档来总结一下这几种常见类型转换                 原始值       ToNumber                       Undefined       NaN                 Null       0                 true       1                 false       0                 String       根据语法和转换规则来转换                 Symbol       Throw a TypeError exception                 Object       先调用toPrimitive, 再调用toNumber           String 转换为 Number 类型的规则：     如果字符串中只包含数字，那么就转换为对应的数字。   如果字符串中只包含十六进制格式，那么就转换为对应的十进制数字。   如果字符串为空，那么转换为0。   如果字符串包含上述之外的字符，那么转换为 NaN。                  原始值       ToBoolean                       Undefined       false                 Boolean       true / false                 Number       0和NaN转换为false，其他转换为true                 Symbol       true                 Object       true                          原始值       ToString                       Undefined       ‘Undefined’                 Boolean       ‘true’ / ‘false’                 Number       对应的字符串类型                 String       String                 Symbol       Throw a TypeError exception                 Object       先调用ToPrimitive，再调用toNumber           隐式类型转换  凡是通过逻辑运算符 (&amp;&amp;、||、 !)、运算符 (+、-、*、/)、关系操作符 (&gt;;、 &lt;;、 &gt;= 、&lt;=)、相等运算符 (==) 或者 if/while 条件的操作，如果遇到两个数据类型不一样的情况，都会出现隐式类型转换。这里你需要重点关注一下，因为比较隐蔽，特别容易让人忽视。  其中我们举例==运算符和+ 号运算符：  == 运算符     如果其中一个操作值是 null 或者 undefined，那么另一个操作符必须为 null 或者 undefined，才会返回 true，否则都返回 false；   如果其中一个是 Symbol 类型，那么返回 false；   两个操作值如果为 string 和 number 类型，那么就会将字符串转换为 number；   如果一个操作值是 boolean，那么转换成 number；   如果一个操作值为 object 且另一方为 string、number 或者 symbol，就会把 object 转为原始类型再进行判断（调用 object 的 valueOf/toString 方法进行转换）。   所以在JavaScript语言中，我们不使用双等号运算符==进行等式判断，而是采用三等号运算符===进行等式判断。  + 运算符     ’+’ 号操作符，不仅可以用作数字相加，还可以用作字符串拼接。仅当 ‘+’ 号两边都是数字时，进行的是加法运算；如果两边都是字符串，则直接拼接，无须进行隐式类型转换。   如果其中有一个是字符串，另外一个是 undefined、null 或布尔型，则调用 toString() 方法进行字符串拼接；如果是纯对象、数组、正则等，则默认调用对象的转换方法会存在优先级，然后再进行拼接。   如果其中有一个是数字，另外一个是 undefined、null、布尔型或数字，则会将其转换成数字进行加法运算，对象的情况还是参考上一条规则。   如果其中一个是字符串、一个是数字，则按照字符串规则进行拼接。   Object的转换规则  对象转换的规则，会先调用内置的 [ToPrimitive] 函数，其规则逻辑如下：     如果部署了 Symbol.toPrimitive 方法，优先调用再返回；   调用 valueOf()，如果转换为基础类型，则返回；   调用 toString()，如果转换为基础类型，则返回；   如果都没有返回基础类型，会报错。"
  },
  
  {
    "title": "关于fastlane已存在的证书复用问题",
    "url": "/posts/fastlane-reuse-certs/",
    "categories": "iOS",
    "tags": "fastlane",
    "date": "2018-01-10 00:00:00 +0800",
    "content": "前言 iOS开发在团队项目协作中，面临着许许多的挑战，除了被大家诟病的nib文件和故事板以外，还有就是今天要说的证书管理问题，相信做过iOS开发的用户对fastlane已经不陌生了，它提供了很多有用的功能来帮助开发者从繁琐的重复性劳动中解脱出来，这里列举出一些：     deliver: 上传截图, 元数据, app应用程序到App Store   supply: 上传Android app应用程序和元数据到Google Play   snapshot: 自动捕获iOS app应用程序本地截图   screengrab: 自动捕获Android app应用程序本地截图   frameit: 快速截屏并将截屏放入设备中   pem: 自动生成和更新推送通知配置文件   sigh: 开发证书和描述文件下载   produce: 使用命令行在iTunes Connect上创建新的app和开发入口   cert: 自动创建和配置iOS代码签名证书   spaceship: Ruby 库访问 Apple开发者中心和 iTunes Connect   pilot: 最好的方式管理你的TestFlight 测试人员和从终端构建   boarding: 最简单的方式邀请你的TestFlight beta测试人员   gym: iOS app打包签名自动化工具   match: 使用Git同步你的团队证书和配置文件   scan: 最简单方式测试你的 iOS 和 Mac apps   今天说的其实是match，我们知道，苹果公司在个人开发者账号上面对于证书的生成是有严格的数量限制的，development 和 distribution证书类型只能生成2个，所以如果按照fastlane每次build不同的target或者不同的Bundle ID的话，它都会重新去生成一个新的证书并以此生成对应的描述文件，这样以来，我们也只能最多同时用该开发者账号签名两个App安装在真机上，想用第三个就必须revoke掉以前生成的证书，当然了，一旦把证书revoke掉了，这也就意味着我们用该证书签名的App也不能在真机上面使用了。所以就得考虑一下，该如果复用现有证书。 1. 拿到你想要复用证书的ID 关于这个证书ID，从钥匙串和openssl工具库中没有找到方法来取到，但是可以通过spaceship这个库来实现，下面是相关脚本： require 'spaceship' Spaceship.login('your@apple.id') Spaceship.select_team Spaceship.certificate.all.each do |cert|    cert_type = Spaceship::Portal::Certificate::CERTIFICATE_TYPE_IDS[cert.type_display_id].to_s.split(\"::\")[-1]   puts \"Cert id: #{cert.id}, name: #{cert.name}, expires: #{cert.expires.strftime(\"%Y-%m-%d\")}, type: #{cert_type}\" end  执行上面代码，会输出所有证书的相应信息，你可以从中找到你想复用的那个证书的ID。 2. 创建远程仓库来保存证书。 建立一个远程仓库，并在该目录下创建certs/distribution和 certs/development目录，分别存放生产和开发环境下的相关证书文件。 3. 通过钥匙串导出你想要复用的那个证书 导出对应的cer文件和p12文件。 4. 执行下面命令，导出私钥文件 openssl pkcs12 -nocerts -nodes -out key.pem -in certificate.p12  5. 生成最后需要的证书 openssl aes-256-cbc -k &lt;your_password&gt; -in key.pem -out &lt;cert_id&gt;.p12 -a openssl aes-256-cbc -k &lt;your_password&gt; -in certificate.cer -out &lt;cert_id&gt;.cer -a  这里的cert_id是上面我们保存的证书id，其中执行完上述步骤后，就生成了fastlane match想要的证书，当执行fastlane match development/adhoc/appstore命令后，match就不会在Apple Development Center重新生成证书了，而是用现有的。 将证书分别放到对应的git仓库目录中，提交并推送到远程仓库。 6. 在开发者网站上面生成App ID fastlane produce -u &lt;your@apple.id&gt; -a &lt;your_app_bundle_id&gt; --skip_itc  如果你的App需要在ITC（iTunes Connect）中创建，则移除--skip_itc选项。 7. 生成证书对应的描述文件 fastlane match &lt;type&gt;   其中type有四种：development/adhoc/distribution/appstore 如果执行过程中，出现输入Git Repo密码后，密码错误导致的不能解密repo，可以尝试着用fastlane match change_password来重置密码。如果修改密码后，发现还是不行的话，可以在与distribution同级目录下创建一个txt文件：”match_version.txt”，内容为fastlane版本号即可，再重新执行。     Passphrase for Git Repo: ** Type passphrase again: ** [22:57:34]: 🔒 Successfully encrypted certificates repo [22:57:34]: Cloning remote git repo… [22:57:39]: Couldn’t decrypt the repo, please make sure you enter the right password! version: 256 class: “inet” ：：：： ：：：：   关于注册新设备  在这之前我们都是通过开发者中心来添加和管理更新设备以及描述文件，有了fastlane提供的match命令则可以帮助我们做这些事情。 注册新设备 我们可以通过添加action的方式更新Fastfile文件：  直接添加设备 register_devices(   devices: {     \"Luka iPhone 6\" =&gt; \"1234567890123456789012345678901234567890\",     \"Felix iPad Air 2\" =&gt; \"abcdefghijklmnopqrstvuwxyzabcdefghijklmn\"   } ) # Simply provide a list of devices as a Hash   通过文件添加设备 register_devices(   devices_file: \"./devices.txt\" ) # Alternatively provide a standard UDID export .txt file, see the Apple Sample (http://devimages.apple.com/downloads/devices/Multiple-Upload-Samples.zip)   文件格式参考demo：http://devimages.apple.com/downloads/devices/Multiple-Upload-Samples.zip  你也可以添加参数： register_devices(   devices_file: \"./devices.txt\", # You must pass in either `devices_file` or `devices`.   team_id: \"XXXXXXXXXX\",         # Optional, if you\"re a member of multiple teams, then you need to pass the team ID here.   username: \"luka@goonbee.com\"   # Optional, lets you override the Apple Member Center username. )  更新描述文件 match(type: \"adhoc\", force_for_new_devices: true)  注意这里的type，对应我们前面提到的几种类型，除此之外，我们也可以通过命令行的方式来更新描述文件： fastlane match adhoc --force_for_new_devices  这样以来，fastlane会重新更新描述文件并提交到我们的证书仓库。 后面我们需要做的就是，只需重新打包，然后将包通过Airport安装到新的设备上就可以了，经测试以前用该描述文件打的包也可以安装到新设备上面去。  关于Apple ID开启双重验证  如果开启双重验证，默认苹果会在新设备登录时，需要手动输入验证码，这时候如果是在CI上面构建，就会带来问题，此时我们可以通过以下方式解决：    访问Apple ID网站,找到 安全 - App 专用密码，生成一个专用密码   然后在构建服务器上面配置环境变量: vim ~/.bash_profile     export FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD=&lt;YOUR_PASSWORD&gt;           执行 fastlane spaceauth -u  按提示获取session信息   复制session信息（很长一大段） 配置环境变量: vim ~/.bash_profile     export FASTLANE_SESSION=‘YOUR SESSION’           参考    Simplify your life with fastlane match   register_devices - fastlane docs   match - fastlane docs"
  },
  
  {
    "title": "Git使用过程中的一些常见场景问题总结",
    "url": "/posts/git-scenes/",
    "categories": "Tools",
    "tags": "Git",
    "date": "2017-12-11 00:00:00 +0800",
    "content": "之前在公司内部推Git，写了一份git使用教程，后来又在团队内部做了一次分享，内容是关于Git使用过程中经常会遇到的一些场景，并有了这份总结。  git基础  基于feature的工作流     添加忽略文件   .gitignore (http://gitignore.io/)   基于develop分支开发：feature分支   bugfix分支   版本节点tag   问题排查: diff 、log  、reflog、blame   撤销操作: checkout  、reset、revert、commit –amend   删除操作: rm  clean   储藏操作: stash   分支操作：创建、删除（注意远程分支的删除）、切换、合并（–no-ff 、rebase）   标签操作   更多详细查看上面教程链接  场景  1. 本地已经存在的项目/分支与如何远程仓库关联 git remote add origin &lt;your-repo-git-url&gt;  2. 刚刚提交了的commit log发现错了，想修改 git commit --amend -m \"your new log\"  3. 查看某次提交的日志和ID git reflog  4. 查看某次提交的内容 git show &lt;commit_id&gt;  5. 只是修改了工作区的文件，想恢复到原来修改前的样子 git reset --hard HEAD git checkout -- &lt;file_name&gt;  6. 被修改的文件已经添加到了暂存区，想撤销添加 git reset --mixed HEAD  7. 被修改的文件已经commit提交，想撤销提交 git reset --soft HEAD^  8. 已经提交到远程主机的文件，想撤销 git revert &lt;commit_id&gt; git revert HEAD  9. 已经开发一半的功能，但是没有开发完，这时候有个bug要紧急处理，需要放下手头的功能，赶去修改BUG // 保存现场 git stash   // 恢复现场 git stash pop  10. 加入过历史版本的文件，因某些原因被删除了想恢复 git checkout &lt;commit_id&gt; -- &lt;file_name&gt;  另外你也可以用reset命令来完成  11. 需要单独把多次提交中的某一次提交从你的分支迁移到另外一个分支上，即跨分支应用commit git cherry-pick &lt;commit_id&gt;  比如：我想把以下分支 A-B  master    \\     C-D-E-F-G develop  中的D，F 两次提交移动到master分支，而保持其他commit不变，结果就像这样 A-B-D-F  master        \\         C-E-G develop  那么，思路是将D，F 用cherry-pick应用到master分支上，然后将develop分支对master分支变基。 $ git checkout master   $ git cherry-pick D   $ git cherry-pick F   $ git checkout develop   $ git rebase master  注意有些情况下使用cherry-pick会存在冲突，解决方法和我们平时合并分支遇到冲突一样。  12. 遇到文件冲突，可以手动解决，或者用你配置的工具解决，记得把文件标位resolved：add/rm 如：常见的拉取同事的代码合并引起冲突 1. 手动处理冲突 2. 文件标志位置为resolved：git add &lt;file_name&gt; 3. 继续合并  git merge --continue 当然也可以选择放弃合并：git merge --abort   13. 让自己本地分支上面的每一次提交日志变得更有意义，有时候需要我们选择有意义的提交日志信息合并上去  比如我们在bugfix分支上面由于修改bug提交了很多次，修复好了之后，我们想把这些提交合并入我们的master分支 git checkout master git merge --squash bugfix git commit -m \"bug fixed\"   上面操作会将bugfix分支上的所有commit都合并为一个commit，并把它并入我们的master分支上去。这里还有一点需要注意的是：–squash含义代表的是本地内容与不使用该选项的合并结果相同，但是不提交，不移动HEAD指针，所以我们要另外多一条语句来移动我们的HEAD指针，即最后的commit。  14. 有时候需要整理我们本地的commits，可以使用Squash  git rebase -i &lt;commit&gt;   举例：  git rebase -i HEAD~5  执行完后，Git会把所有commit列出来，让你进行一些修改，修改完成之后会根据你的修改来rebase。HEAD-5的意思是只修改最近的5个commit。  pick 033beb4 b1 pick b426a8a b2 pick c216era b3 pick d627c9a b4 pick e416c8b b5  # Rebase 033beb4..e416c8b onto 033beb4 # # Commands: #  p, pick = use commit #  r, reword = use commit, but edit the commit message #  e, edit = use commit, but stop for amending #  s, squash = use commit, but meld into previous commit #  f, fixup = like \"squash\", but discard this commit's log message #  x, exec = run command (the rest of the line) using shell # # If you remove a line here THAT COMMIT WILL BE LOST. # However, if you remove everything, the rebase will be aborted. #   上面pick是要执行的commit指令，另外还有reword、edit、squash、fixup、exec这5个，具体的含义可以看上面的注释解释，比较简单，这里就不说了。 我们要合并就需要修改前面的pick指令：  pick 033beb4 b1 squash b426a8a b2 squash c216era b3 squash d627c9a b4 squash e416c8b b5   也就是下面这4个提交合并到最前面的那个提交里面，按esc，打上:wq提交保存离开。 接着是输入新的commit message  b # This is a combination of 2 commits. # The first commit's message is: # b1 # # This is the 2nd commit message: # # b2 # # This is the 3rd commit message: # # b3 # # This is the 4th commit message: # # b4 # # This is the 5th commit message: # # b5 # # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # Not currently on any branch. # Changes to be committed: # (use \"git reset HEAD &lt;file&gt;...\" to unstage) # # modified:   a.txt #   其中第一行的b就是需要我们输入的新信息，同样编辑完保存，出现类似下面的信息：  Successfully rebased and updated refs/heads/develop.   最后可以用git log指令来验证commits是不是我们要变成的样子。  15. 多人协作开发项目，想知道某个文件的当前改动情况 通常查问题时想知道某个文件的某部分代码是谁改动的，那么git blame 就派上用场了。 git blame &lt;file_name&gt;  你也可以具体指定到某一行或者某几行代码 git blame -L &lt;start_line&gt;,&lt;end_line&gt; &lt;file_name&gt;   16. 执行push命令向多个仓库同时提交代码 有时候会做代码备份，将代码保存在几个不同的Git代码管理平台，这时候就需要用到了  修改本地仓库目录下.git/config文件  [core] \trepositoryformatversion = 0 \tfilemode = true \tbare = false \tlogallrefupdates = true \tignorecase = true \tprecomposeunicode = true [remote \"origin\"] \turl = git@github.com:yuxingxin/blog.git     url = ……     url = …… \tfetch = +refs/heads/*:refs/remotes/origin/*   如上 在remote处可以添加多个远程地址。  17. 从多次提交中快速定位某一次提交的bug  # 开始 bisect $ git bisect start  # 录入正确的 commit $ git bisect good xxxxxx  # 录入出错的 commit $ git bisect bad xxxxxx  # 然后 git 开始在出错的 commit 与正确的 commit 之间开始二分查找，这个过程中你需要不断的验证你的应用是否正常 $ git bisect bad $ git bisect good $ git bisect good ...  # 直到定位到出错的 commit，退出 bisect $ git bisect reset   总结  当然了，git的一些常见场景，还远不止这些，限于本人能力有限，如果你在平时的工作中遇到一些很实用的命令，也欢迎反馈给我，我好一并学习。更多的详细可以参考之前总结的一系列文档: https://devops.yuxingxin.com。 学习git命令是一件很有意思的事情，我想它能帮助使用git命令的人更好的理解这一代码管理工具，从而不至于犯一些低级错误，MobDevGroup网站上面也分享过几个学习命令的网站，可以供参考：https://mobdevgroup.com/tools/assistant"
  },
  
  {
    "title": "Android Studio 和Gradle Plugin 3.0 迁移不完全指南",
    "url": "/posts/migrate-android-studio-3-guide/",
    "categories": "Android",
    "tags": "Android, Studio",
    "date": "2017-11-03 00:00:00 +0800",
    "content": "Android Studio 3.0 默认Gradle版本为4.1，如果你需要手动升级版本的话，记得修改gradle/wrapper/gradle-wrapper.properties文件的URL地址：  distributionUrl=https\\://services.gradle.org/distributions/gradle-4.1-all.zip   对应的Gradle插件版本为3.0.0，手动修改的话，需要修改项目级的build.gradle文件：  buildscript {     repositories {         ...         // You need to add the following repository to download the         // new plugin.         google()     }      dependencies {         classpath 'com.android.tools.build:gradle:3.0.0'     } }   注意上面记得添加google这个repository，某些官方依赖需要下载  对应我们的构建工具buildToolsVersion版本为26.0.2，对应Module级项目build.gradle文件：  android {     compileSdkVersion 26     ...     defaultConfig {       ...     } }   使用变体感知（variant-aware）依赖管理机制  Android 3.0的插件使用一种新的依赖机制，这种机制能自动的匹配我们项目中依赖库的变体，即app变体debug会自动消费它所依赖的library的debug变体。当然了，我们在给产品定制不同的风味时，它依然能够适用。所以呢为了保证能够准确的匹配这些变体，我们需要为所有的产品风味声明风味维度（flavor dimensions），以及不可能直接匹配的需要我们提供matching fallbacks（PS：不知道怎么翻译了…）  好了，上面说了那么多”废话”，其实只是想说明一点，如果你项目中用了build type 或者product flavor一种或一种以上， 那么你就需要注意了，这里可能需要做相应的适配：  添加风味维度的声明  当我们在配置文件中配置产品风味的时候，现在需要声明风味维度，然后在每个产品风味中指定你前面所声明的某一个风味维度，如下：  //定义两个风味维度 flavorDimensions \"api\", \"mode\"  productFlavors {     demo {         //指定风味维度         dimension \"mode\"         ...     }      full {         dimension \"mode\"         ...     }      minApi24 {         dimension \"api\"         minSDKVersion '24'         versionNameSuffix \"-minApi24\"     }      minApi23 {         dimension \"api\"         minSDKVersion '23'         versionNameSuffix \"-minApi23\"     }      minApi21 {         dimension \"api\"         minSDKVersion '21'         versionNameSuffix \"-minApi21\"     } }   如上，配置完后，Gradle创建的构建变体数量等于每个风味维度中的风味数量与你配置的构建类型数量的乘积，在 Gradle 为每个构建变体或对应 APK 命名时，属于较高优先级风味维度的产品风味首先显示，之后是较低优先级维度的产品风味，再之后是构建类型。以上面的构建配置为例，Gradle 可以使用以下命名方案创建总共 12 个构建变体： 构建变体：[minApi24, minApi23, minApi21][Demo, Full][Debug, Release] 对应 APK：app-[minApi24, minApi23, minApi21]-[demo, full]-[debug, release].apk 例如构建变体：minApi24DemoDebug，对应 APK：app-minApi24-demo-debug.apk 当然如果有些特定的变体不是你需要的，你也可以过滤：  android{     variantFilter { variant -&gt;         def names = variant.flavors*.name         // To check for a certain build type, use variant.buildType.name == \"&lt;buildType&gt;\"         if (names.contains(\"minApi21\") &amp;&amp; names.contains(\"demo\")) {         // Gradle ignores any variants that satisfy the conditions above.         setIgnore(true)         }     } }   如果组合多个产品风味，产品风味之间的优先级将由它们所属的风味维度决定。上面所列示的第一个风味维度中的产品风味比第二个维度中的产品风味拥有更高的优先级，以此类推。此外，与属于各个产品风味的源集相比，你为产品风味组合创建的源集拥有更高的优先级。  如果不同源集包含同一文件的不同版本，Gradle 将按以下优先顺序决定使用哪一个文件（左侧源集替换右侧源集的文件和设置）：  构建变体 &gt; 构建类型 &gt; 产品风味 &gt; 主源集 &gt; 库依赖项  如以下优先级顺序：     src/demoDebug/（构建变体源集）   src/debug/（构建类型源集）   src/demo/（产品风味源集）   src/main/（主源集）   这里说下源集的概念，Android Studio 按逻辑关系将每个模块的源代码和资源分组称为源集，默认情况下，Android Studio 会创建 main/源集和目录，用于存储要在所有构建变体之间共享的一切资源。然而，我们也可以创建新的源集来控制 Gradle 要为特定的构建类型、产品风味（以及使用风味维度时的产品风味组合）和构建变体编译和打包的确切文件。例如，可以在 main/ 源集中定义基本的功能，使用产品风味源集针对不同的客户更改应用的品牌，或者仅针对使用调试构建类型的构建变体包含特殊的权限和日志记录功能等。     src/main/：此源集包括所有构建变体共用的代码和资源。   src/&lt;buildType&gt;/：创建此源集可加入特定构建类型专用的代码和资源。   src/&lt;productFlavor&gt;/：创建此源集可加入特定产品风味专用的代码和资源。   src/&lt;productFlavorBuildType&gt;/：创建此源集可加入特定构建变体专用的代码和资源。   配置完后我们可以通过Android Studio窗口右侧Gradle，导航至YourApplication&gt;Tasks&gt;android下双击sourceSets，在Android Studio底部右下角 Gradle Console处查看项目是如何组织源集的  关于构建类型的配置  假设App中配置了一个叫做”jniDebug”的构建类型，但是该App所依赖的库中没有配置，这时候当我们构建”jniDebug”的时候，插件就不知道库该使用什么构建类型，这时候就会给报出下面的错误：  Error:Failed to resolve: Could not resolve project :mylibrary. Required by:project :app   这类问题就是由于上面的依赖管理机制变化导致的，我们可以下面的几种情况来分别解决：  你的 Module App 包含了它所依赖的库没有的构建类型  例如，我们的App包含了一个jniDebug的构建类型，但是它所依赖的库中没有这个，而是有debug和release这两个构建类型，这时候我们就可以在Module App的build.gradle文件中使用matchingFallbacks 来指定可以替换的匹配项，如下：  android {     buildTypes {         debug {}         release {}         jniDebug {             // Specifies a sorted list of fallback build types that the             // plugin should try to use when a dependency does not include a             // \"jniDebug\" build type. You may specify as many fallbacks as you             // like, and the plugin selects the first build type that's             // available in the dependency.             matchingFallbacks = ['debug', 'release']         }     } }   值得一提的是插件会选择matchingFallbacks列表中第一个可用的构建类型来替换匹配项。     注意当依赖的库中包含了Module App没有的构建类型，则不会出现上述问题。   对于一个给定的存在于App和它所依赖的库中的风味维度，我们的主Module App包含了库中没有的风味  例如，主Module App和库中都包含了一个mode的风味维度，我们的App中指定mode维度的是free和paid风味，而库中指定mode维度的是demo和paid风味，这时候我们就可以用`matchingFallbacks 来为App中的free指定可以替换的匹配项。如下：  android {     defaultConfig{     // Do not configure matchingFallbacks in the defaultConfig block.     // Instead, you must specify fallbacks for a given product flavor in the     // productFlavors block, as shown below.     }     flavorDimensions 'mode'     productFlavors {         paid {             dimension 'mode'             // Because the dependency already includes a \"paid\" flavor in its             // \"mode\" dimension, you don't need to provide a list of fallbacks             // for the \"paid\" flavor.         }         free {             dimension 'mode'             // Specifies a sorted list of fallback flavors that the plugin             // should try to use when a dependency's matching dimension does             // not include a \"free\" flavor. You may specify as many             // fallbacks as you like, and the plugin selects the first flavor             // that's available in the dependency's \"mode\" dimension.             matchingFallbacks = ['demo', 'trial']         }     } }   值得注意的是，上述情况中，如果说库中包含了一个主Module App没有的产品风味，则不会出现上述问题。  库中包含了一个主Module App没有的风味维度  例如，库中声明了一个minApi的风味维度，但是你的App中只有mode维度，因此当你要构建freeDebug这个变种版本的App时，插件就不知道你是想用minApi23Debug还是用minApi25Debug变种版本的库，这时候我们可以在主Module App中的defaultConfig代码块通过配置missingDimensionStrategy来让插件从丢失的维度中指定默认的风味，当然你也可以在productFlavors代码块中覆盖先前的选择，因此每一个风味都可以为丢失的维度指定一个不同的匹配策略。  android {     defaultConfig{         // Specifies a sorted list of flavors that the plugin should try to use from         // a given dimension. The following tells the plugin that, when encountering         // a dependency that includes a \"minApi\" dimension, it should select the         // \"minApi23\" flavor. You can include additional flavor names to provide a         // sorted list of fallbacks for the dimension.         missingDimensionStrategy 'minApi', 'minApi23', 'minApi25'         // You should specify a missingDimensionStrategy property for each         // dimension that exists in a local dependency but not in your app.         missingDimensionStrategy 'abi', 'x86', 'arm64'     }     flavorDimensions 'mode'     productFlavors {         free {             dimension 'mode'             // You can override the default selection at the product flavor             // level by configuring another missingDimensionStrategy property             // for the \"minApi\" dimension.             missingDimensionStrategy 'minApi', 'minApi25', 'minApi23'         }         paid {}     } }      值得注意的是，当你的主Module App中包含了一个库中依赖项没有的风味维度时，则不会出现上述问题。例如，当库中依赖项不包含abi这个维度时，freeX86Debug版本将会使用freeDebug版本的依赖。   使用新的依赖配置  先来看下以前的配置：  android {...} ... dependencies {     // The 'compile' configuration tells Gradle to add the dependency to the     // compilation classpath and include it in the final package.      // Dependency on the \"mylibrary\" module from this project     compile project(\":mylibrary\")      // Remote binary dependency     compile 'com.android.support:appcompat-v7:26.1.0'      // Local binary dependency     compile fileTree(dir: 'libs', include: ['*.jar']) }   上面也是我们常见的三种依赖项声明：     模块依赖项 compile project(‘:mylibrary’) 行声明了一个名为“mylibrary”的本地 Android 库模块作为依赖项，并要求构建系统在构建应用时编译并包含该本地模块。   远程二进制依赖项 compile ‘com.android.support:appcompat-v7:26.1.0’ 行会通过指定其 JCenter 坐标，针对 Android 支持库的 26.1.0 版本声明一个依赖项。   本地二进制依赖项 compile fileTree(dir: ‘libs’, include: [‘*.jar’]) 行告诉构建系统在编译类路径和最终的应用软件包中包含 app/libs/ 目录内的任何 JAR 文件。   先来看下以前配置的关键字：          compile 指定编译时依赖项。Gradle 将此配置的依赖项添加到类路径和应用的 APK。这是默认配置。           apk 指定 Gradle 需要将其与应用的 APK 一起打包的仅运行时依赖项。我们可以将此配置与 JAR 二进制依赖项一起使用，而不能与其他库模块依赖项或 AAR 二进制依赖项一起使用。           provided 指定 Gradle 不与应用的 APK 一起打包的编译时依赖项。如果运行时无需此依赖项，这将有助于缩减 APK 的大小。我们可以将此配置与 JAR 二进制依赖项一起使用，而不能与其他库模块依赖项或 AAR 二进制依赖项一起使用。           使用构建变体或者测试源集的名称配置关键字 这种方式可以为特定的构建变体或者测试源集配置依赖项，如：      dependencies {     ...     // Adds specific library module dependencies as compile time dependencies     // to the fullRelease and fullDebug build variants.     fullReleaseCompile project(path: ':library', configuration: 'release')     fullDebugCompile project(path: ':library', configuration: 'debug')      // Adds a compile time dependency for local tests.     testCompile 'junit:junit:4.12'      // Adds a compile time dependency for the test APK.     androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2.2' }   我们再来看下新的配置项：          implementation      原有compile已经废弃掉，新增了implementation，用它来配置模块时，它是用来告诉Gradle该Module不会在编译时暴露其依赖给其他Module，而仅仅是在运行时才会暴露出来，即对其他Module可用。因此它也常常用在该模块不需要有别的模块依赖时声明使用，例如我们的App Module或者test Module。这样做的好处是减少了我们构建的时间。           api      同原有compile，它和上面的区别就是它在编译器和运行期都会暴露它所配置的模块，因此也常常用在\t\t\t\t\t\t\t\tlibrary module中。这是因为一旦我们api配置的这个Module有变化，Gradle会在编译期重新编译那个依赖项的所有依赖。所以，如果我们项目中有大量的api配置项依赖，那么无形中就增加了构建的时间，除非你想暴露这个模块的API给其他Module使用，否则，我们应尽可能使用implementation来代替。           compileOnly      同上面的provided，只在编译时用，不会打包到我们的APK中           runtimeOnly      同上面的apk      一些API的变化  尤其注意的是我们重命名打包的APK文件，以及输出路径。 变化前：  applicationVariants.all { variant -&gt;     variant.outputs.each { output -&gt;         def outputFile = output.outputFile         if (outputFile != null &amp;&amp; outputFile.name.endsWith('.apk')) {             if (variant.buildType.name == 'lotteryTest') {                 def fileName = \"myApp_v${defaultConfig.versionName}_${releaseTime()}.apk\"                 output.outputFile = new File(outputFile.parent, fileName)             }         }     } }   变化后：  applicationVariants.all { variant -&gt;     variant.outputs.all { output -&gt;         def outputFile = output.outputFile         if (outputFile != null &amp;&amp; outputFile.name.endsWith('.apk')) {             if (variant.buildType.name == 'lotteryTest') {                 def fileName = \"myApp_v${defaultConfig.versionName}_${releaseTime()}.apk\"                 outputFileName = new File(fileName)             }         }     } }   即我们需要修改each() 和 outputFile() 方法为 all() 和 outputFileName  默认启用AAPT2 在迁移的过程中，如果发现由于aapt2导致的异常，可以在gradle.properties中加入：    android.enableAapt2=false   支持Java8新特性  Gradle带来全新的Java8支持方案desugar  该方案启用十分简单，只需要配置下面代码：  compileOptions {     sourceCompatibility JavaVersion.VERSION_1_8     targetCompatibility JavaVersion.VERSION_1_8 }   如果你不想使用，也可以禁用，可以在gradle.properties中加入：  android.enableDesugar=false   记得删除上面的兼容Java8代码。  移除Jack工具链，不再支持  android { ... defaultConfig {     ...     // Remove this block.     jackOptions {         enabled true         ...     } } // Keep the following configuration in order to target Java 8. compileOptions {     sourceCompatibility JavaVersion.VERSION_1_8     targetCompatibility JavaVersion.VERSION_1_8 } }   移除Retrolambda插件  项目级build.gradle 文件：  buildscript { ... dependencies {     // Remove the following dependency.     classpath 'me.tatarka:gradle-retrolambda:&lt;version_number&gt;' } }   Module级build.gradle文件：  // Remove the following plugin. apply plugin: 'me.tatarka.retrolambda' ... // Remove this block after migrating useful configurations. retrolambda { ... // If you have arguments for the Java VM you want to keep, // move them to your project's gradle.properties file. jvmArgs '-Xmx2048m' }   目前兼容支持的功能特性有：     Lambda expressions   Method References   Type Annotations   Default and static interface methods   Repeating annotations   参考     https://developer.android.com/studio/write/java8-support.html#migrate   https://android-developers.googleblog.com/2017/10/android-studio-30.html   https://developer.android.com/studio/build/gradle-plugin-3-0-0.html#known_issues   https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration.html"
  },
  
  {
    "title": "依赖注入库Dagger2",
    "url": "/posts/dagger2/",
    "categories": "Android",
    "tags": "Dagger2",
    "date": "2017-06-26 00:00:00 +0800",
    "content": "依赖注入Dagger2  之前在项目中要用到这个库，后来就给团队内部分享完Dagger2后做的一个提纲总结。  解决的痛点  依赖管理问题  角色     依赖实例   注入对象   注入方式   提供依赖的方式          @Inject           @Module  优先级更高      @provide      注入在哪里  @Inject  注入方式：连接的桥梁  @Component  注入方法：void inject();  提供中间桥梁：Application  getApplication();  依赖的实体：modules  依赖的传递：dependencies  本质是将依赖的Component的引用传递给了被依赖的Component  @SubComponent：Component的拓展  公用依赖实例  区别  Component Dependencies： 单纯依赖     你想保留独立的单个组件   要明确的显示该组件所使用的其他依赖   Subcomponent：有点类似继承     两个组件之间的关系紧密   你只关心Component，而Subcomponent只是作为Component的拓展   限定符  @Qualifier  自定义注解  区分多个依赖对象，单独为其打上标记  作用域  @Scope  自定义注解  管理依赖的生命周期  默认实现：@Singleton   局部单例     Module中provide方法使用了@scope, 对应的Component中也必须加上@scope,  注解名字也是一样的，这时候 provide提供的方法就会在Component中保持『局部单例』，如果只是在Component中标注@scope,Module中的provide方法没有标注，这时候scope就不会起作用，仅仅是为了编译通过   实现单例：     依赖在Component中是单例的（供该依赖的provide方法和对应的Component类使用同一个Scope注解。）   对应的Component在App中只初始化一次，每次注入依赖都使用这个Component对象。（在Application中创建该Component）   自定义其他scope：@ActivityScope  @FragmentScope等等  延迟注入Lazy  初始化的时候不注入，等到调用get方法的时候才去初始化依赖实例注入依赖  多实例注入Provider  有时候不仅仅是注入单个实例，我们需要多个实例，每次调用它的 get() 方法都会调用到 @Inject 构造函数创建新实例或者 Module 的 provide 方法返回新实例"
  },
  
  {
    "title": "终端下Python镜像源管理工具pprm",
    "url": "/posts/pprm/",
    "categories": "Tools",
    "tags": "registry",
    "date": "2017-03-01 00:00:00 +0800",
    "content": "我们在使用Python做开发的时候，常常会用到第三方库，.虽然用easy_install和pip来安装第三方库很方便，但默认的第三方库是从Python的官方源下载的，因为某些原因，官方的网站访问时快时慢，很不稳定，有时候也直接打不开了，网上可以找一些国内的镜像源可以做为替换，通过修改配置文件(~/.pip/pip.conf)pip.conf即可，其实这个小工具的作用就是帮我们做这个事情，另外也提供了增删查等其他相关命令。  安装 $  npm install -g pprm   使用  列出所有的镜像源地址：  $ prm ls    pypi --- https://pypi.python.org/simple/ * douban - https://pypi.doubanio.com/simple/   ali ---- http://mirrors.aliyun.com/pypi/simple/   tsinghua  https://pypi.tuna.tsinghua.edu.cn/simple/   ustc --- https://mirrors.ustc.edu.cn/pypi/web/simple/  切换镜像源：  $ prm use ali  Registry has been set to: http://mirrors.aliyun.com/pypi/simple/  查看当前镜像源：  $ prm current  douban  添加镜像源：  $ prm add 'registry_name' 'registry_url' 'registry_home_url' # 参数依次是镜像源的名称、地址、项目首页  删除指定的镜像源：  $ del 'registry_name'  用浏览器打开主页：  prm home 'registry_name'  测试镜像源地址的响应速度：  prm test 'registry_name'  帮助中心  prm help     版本  prm version   项目地址：    GitHub_pprm   npm_pprm"
  },
  
  {
    "title": "西安GDG上《以开发者的角度再聊Material Design》的总结",
    "url": "/posts/material-design/",
    "categories": "Android",
    "tags": "MaterialDesign",
    "date": "2016-07-17 00:00:00 +0800",
    "content": "概述 谷歌在2014年I/O大会上推出了Material Design,旨在为手机、平板电脑、台式机和“其他平台”提供更一致、更广泛的“外观和感觉”。在国内有好几种版本的翻译：材料设计/材质设计/质感设计（官方文档）/原质设计（国内设计师更倾向于这个）。  三大设计原则  隐喻  通过纸墨做比，光影打造空间层次和符合客观规律的特效来隐喻表面质感、光效以及运动感。  鲜明、形象、深思熟虑  借鉴了传统的印刷设计，从排版、网格、空间、比例、配色、图像使用上做了精心处理，尤其对色彩、图像、字体、留白明确了规范，力求构建鲜明的用户界面。  有意义的动画效果  通过符合客观运动规律的特效效果，让物体的变化以更连续、更平滑的方式呈现给用户，从而吸引用户的注意。比如转场、触摸反馈、循环揭示等  关于界面的层次：   从下往上依次可以分为：     界面的内容   顶部导航条 App Bar   浮动按钮  FAB   状态栏&amp;底部虚拟导航键   抽屉菜单   通知栏等系统信息   六大部分 官方文档分别从动画、样式、布局、组件、模式、可用性六个方面对Material Design的设计规范进行了详细阐释。  这里主要列一些5.0以后引入的新特性：  1.触控涟漪    首先在视图 XML 中应用此功能     ?android:attr/selectableItemBackground 指定有界的波纹。   ?android:attr/selectableItemBackgroundBorderless 指定越过视图边界的波纹。 它将由一个非空背景的视图的最近父项所绘制和设定边界。注意这个是API21引入的新特性   如果要改变默认触摸反馈颜色，可以在我们自定义的主题下面主题的添加 android:colorControlHighlight 属性。  相关类是RippleDrawable。  在drawable-v21中：  &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;ripple xmlns:android=\"http://schemas.android.com/apk/res/android\"     android:color=\"@android:color/darker_gray\"&gt;     &lt;item&gt;         &lt;shape android:shape=\"rectangle\"&gt;             &lt;solid android:color=\"@color/colorAccent\" /&gt;         &lt;/shape&gt;     &lt;/item&gt; &lt;/ripple&gt;   如果要兼容5.0以下版本，我们可以使用第三方开源库RippleEffect  否则可以在drawable中定义selector指定不同的状态即可  2. View状态改变动画  StateListAnimator定义当视图的状态改变的时候运行动画，如下代码：  &lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;   &lt;item android:state_pressed=\"true\"&gt;     &lt;set&gt;       &lt;objectAnimator android:propertyName=\"translationZ\"         android:duration=\"@android:integer/config_shortAnimTim\"         android:valueTo=\"2dp\"         android:valueType=\"floatType\"/&gt;     &lt;/set&gt;   &lt;/item&gt;   &lt;item android:state_enabled=\"true\"     android:state_pressed=\"false\"     android:state_focused=\"true\"&gt;     &lt;set&gt;       &lt;objectAnimator android:propertyName=\"translationZ\"         android:duration=\"100\"         android:valueTo=\"0\"         android:valueType=\"floatType\"/&gt;     &lt;/set&gt;   &lt;/item&gt; &lt;/selector&gt;   给视图分配动画使用android:stateListAnimator属性,代码实现可以借助AnimationInflater.loadStateListAnimator()和View.setStateListAnimator()方法。     注意当你的主题是继承的Material主题，按钮默认有一个Z轴动画。如果需要避免这个动画，设置android:stateListAnimator属性为@null即可。   与此相似的是animated-selector：android5.0的一些系统组件默认使用这些动画。  &lt;animated-selector     xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;      &lt;!-- provide a different drawable for each state--&gt;     &lt;item android:id=\"@+id/pressed\" android:drawable=\"@drawable/drawable_pressed\"         android:state_pressed=\"true\"/&gt;     &lt;item android:id=\"@+id/focused\" android:drawable=\"@drawable/drawable_focused\"         android:state_focused=\"true\"/&gt;     &lt;item android:id=\"@id/default\"         android:drawable=\"@drawable/drawable_default\"/&gt;      &lt;!-- specify a transition --&gt;     &lt;transition android:fromId=\"@+id/default\" android:toId=\"@+id/pressed\"&gt;         &lt;animation-list&gt;             &lt;item android:duration=\"15\" android:drawable=\"@drawable/drawable1\"/&gt;             &lt;item android:duration=\"15\" android:drawable=\"@drawable/drawable2\"/&gt;             ...         &lt;/animation-list&gt;     &lt;/transition&gt;     ... &lt;/animated-selector&gt;   3.循环揭示 它提供视觉上的持续性挡显示或者隐藏一组界面元素。通过ViewAnimationUtils.createCircularReveal()方法可以使用动画效果来揭示或者隐藏一个视图。    关键代码 揭示一个先前隐藏的视图  Animator anim =     ViewAnimationUtils.createCircularReveal(myView, cx, cy, 0, finalRadius); myView.setVisibility(View.VISIBLE); anim.start();   隐藏一个先前显示的视图  Animator anim =     ViewAnimationUtils.createCircularReveal(myView, cx, cy, initialRadius, 0);  anim.addListener(new AnimatorListenerAdapter() {     @Override     public void onAnimationEnd(Animator animation) {         super.onAnimationEnd(animation);         myView.setVisibility(View.INVISIBLE);     } });  anim.start();   针对5.0以下如果实现，可以借用第三方库：CircularReveal  共享元素转场  android 5.0(api 21)提供以下进入和退出效果：    explode(分解)   slide(滑动)   fade(淡入淡出)   接下来猪脚登场,共享元素过渡效果：     changeBounds - 改变目标视图的布局边界   changeClipBounds - 裁剪目标视图边界   changeTransform - 改变目标视图的缩放比例和旋转角度   changeImageTransform - 改变目标图片的大小和缩放比例     首先在我们继承的主题上，使用android:windowContentTransitions属性开启窗口内内容过渡效果     以共享元素启动一个操作行为   ActivityOptionsCompat options = ActivityOptionsCompat.     makeSceneTransitionAnimation(this, (View)ivAvatar, \"avatar\"); startActivity(intent, options.toBundle());      以多个共享元素启动一个操作行为   Pair&lt;View, String&gt; p1 = Pair.create((View)ivProfile, \"profile\"); Pair&lt;View, String&gt; p2 = Pair.create(vPalette, \"palette\"); Pair&lt;View, String&gt; p3 = Pair.create((View)tvName, \"text\"); ActivityOptionsCompat options = ActivityOptionsCompat.     makeSceneTransitionAnimation(this, p1, p2, p3); startActivity(intent, options.toBundle());   Scrolling Animations  放到后面  高度和阴影    Z = elevation + translationZ  主要借助elevation属性  着色  利用 Android 5.0（API 级别 21）及更高版本,可为位图以及定义为 Alpha 蒙版的点九图着色，主要借助android:tint 以及 android:tintMode 属性设置您的布局中的着色颜色和模式。  裁剪视图       扩展 ViewOutlineProvider 类别。   重写 getOutline() 方法。   利用 View.setOutlineProvider() 方法设置轮廓。   矢量图片添加动画  先是xml文件，对应类是VectorDrawable &lt;vector xmlns:android=\"http://schemas.android.com/apk/res/android\"      android:height=\"64dp\"      android:width=\"64dp\"      android:viewportHeight=\"600\"      android:viewportWidth=\"600\" &gt;      &lt;group          android:name=\"rotationGroup\"          android:pivotX=\"300.0\"          android:pivotY=\"300.0\"          android:rotation=\"45.0\" &gt;          &lt;path              android:name=\"v\"              android:fillColor=\"#000000\"              android:pathData=\"M300,70 l 0,-70 70,70 0,0 -70,70z\" /&gt;      &lt;/group&gt;  &lt;/vector&gt;   设置drawable，对应类是AnimatedVectorDrawable &lt;animated-vector xmlns:android=\"http://schemas.android.com/apk/res/android\"    android:drawable=\"@drawable/vectordrawable\" &gt;      &lt;target          android:name=\"rotationGroup\"          android:animation=\"@anim/rotation\" /&gt;      &lt;target          android:name=\"v\"          android:animation=\"@anim/path_morph\" /&gt;  &lt;/animated-vector&gt;   上面是使用了两个属性动画，对应类是ObjectAnimator  其中旋转动画和变形动画： &lt;objectAnimator       xmlns:android=\"http://schemas.android.com/apk/res/android\"     android:duration=\"6000\"       android:propertyName=\"rotation\"       android:valueFrom=\"0\"       android:valueTo=\"360\"/&gt;  &lt;objectAnimator       xmlns:android=\"http://schemas.android.com/apk/res/android\"     android:duration=\"3000\"       android:propertyName=\"pathData\"       android:valueFrom=\"M300,70 l 0,-70 70,70 0,0   -70,70z\"       android:valueTo=\"M300,70 l 0,-70 70,0  0,140 -70,0 z\"       android:valueType=\"pathType\"/&gt;      从图像萃取颜色  如果要萃取这些颜色，可以通过如下函数：    Palette.from(bitmap).generate() Palette.generateAsync(bitmap,paletteAsyncListener)   然后可以通过 Palette.getVibrantColor方法获取色值  样式  颜色  颜色不宜过多。选取一种主色、一种辅助色（非必需），在此基础上进行明度、饱和度变化，构成配色方案。(https://www.materialpalette.com)  图标  建议模仿现实中的折纸效果，通过扁平色彩表现空间和光影。这里也推荐下这个插件：https://github.com/konifar/android-material-design-icon-generator-plugin  图片  优先使用图像。然后可以考虑使用插画。  文字  英文官方建议Roboto字体，中文推荐Noto(思源黑体)，另外官方也开源了字体库,需翻墙  布局  这里列出部分尺寸：     所有可操作元素最小点击区域尺寸：48dp X 48dp。   栅格系统的最小单位是8dp，一切距离、尺寸都应该是8dp的整数倍。以下是一些常见的尺寸与距离：（推荐网格校正工具：keyline pushing）   顶部状态栏高度：24dp   Appbar最小高度：56dp   底部导航栏高度：48dp   悬浮按钮尺寸：56x56dp/40x40dp   用户头像尺寸：64x64dp/40x40dp   小图标点击区域：48x48dp   侧边抽屉到屏幕右边的距离：56dp   卡片间距：8dp   分隔线上下留白：8dp   大多元素的留白距离：16dp   推荐国外开发者贡献的一个开源库：https://github.com/DmitryMalkovich/material-design-dimens  里面总结了一些Material Design的设计规范，另外也推荐一款网格校正工具：keyline pushing  组件  这里列出来一些官方组件，可供我们开发Material Design时使用     RecyclerView   CardView   DrawerLayout   NavigationView   Toolbar   FloatingActionButton   Snackbar   TextInputLayout   TextInputEditText   CoordinatorLayout   TabLayout   AppBarLayout   SwipeRefreshLayout   CollapsingToolbarLayout   BottomSheetBehavior   PercentRelativeLayout   Palette   PagerTabStrip   PagerTitleStrip   SlidingPanelLayout   RecyclerView  关于RecyclerView的几点总结：     RecyclerView.LayoutManager\t:负责Item视图的布局的显示管理   RecyclerView.ItemDecoration\t:给每一项Item视图添加子View,如加分割线等   RecyclerView.ItemAnimator:负责处理数据添加或者删除时候的动画效果   RecyclerView.Adapter:为每一项Item创建视图   RecyclerView.ViewHolder:承载Item视图的子布局   与ListView的对比：     RecyclerView需借助ViewHolder模式来实现Adapter   RecyclerView可以自定义Item布局：listview只能以垂直线性排列的方式来布局Item,而RecyclerView借助RecyclerView.LayoutManager可以实现多种布局，如网格、瀑布流等   Item 动画：借助RecyclerView.ItemAnimator很容易实现item动画   数据源：listview针对不同的数据源可以有不同的适配器，而RecyclerView需要借助RecyclerView.Adapter自定义实现适配器来提供数据。   Item Decoration：listview可以通过android:divider很容易实现分割线等，而RecycerView则需要借助RecyclerView.ItemDecoration   Item Click : listview可以通过AdapterView.OnItemClickListener来实现，而RecyclerView则只提供了RecyclerView.OnItemTouchListener   CardView    两个属性：  app:cardCornerRadius app:cardBackgroundColor   Toolbar  用来替代ActionBar，可以当做一个普通的ViewGroup来使用，所以来说比前者更灵活  AppBarLayout  常作为Toolbar和其他View的父View配合CoordinatorLayout使用来实现Scrolling Animation  FloatingActionButton  浮动Button,也可以加入二级菜单  Snackbar  带有动作的Toast TabLayout  常和ViewPager搭配使用，比较方便  CoordinatorLayout.Behavior  CoordinatorLayout是一个比较重要的类，大致主要分这几点：     一个抽象内部类   利用泛型是指定我们应用这个Behavior的view的类型   自定义Behavior：某个View监听另一个view的状态变化，例如大小、位置、显示状态等：layoutDependendsOn和onDependentViewChanged方法；   某个view监听CoordinatorLayout里的滑动状态：onStartNestedScroll和onNestedPreScroll方法。   CoordinatorLayout 所做的事情就是当成一个通信的 桥梁 ，连接不同的view。使用 Behavior 对象进行通信。   两个常见用例：     CoordinatorLayout与悬浮操作按钮           CoordinatorLayout是用来协调其子view们之间动作的一个父view，而Behavior就是用来给CoordinatorLayout的子view们实现交互的。           FloatingActionButton作为一个子View添加进CoordinatorLayout并且将CoordinatorLayout传递给 Snackbar.make()         CoordinatorLayout与app bar           使用AppBarLayout可以让你的Toolbar与其他view（比如TabLayout的选项卡）能响应被标记了ScrollingViewBehavior的View的滚动事件           这里使用了CollapsingToolbarLayout的app:layout_collapseMode=”pin”来确保Toolbar在view折叠的时候仍然被固定在屏幕的顶部。借助app:layout_collapseMode=”parallax”（以及使用app:layout_collapseParallaxMultiplier=”0.7”来设置视差因子）来实现视差滚动效果（比如CollapsingToolbarLayout里面的一个ImageView），这种情况和CollapsingToolbarLayout的app:contentScrim=”?attr/colorPrimary”属性一起配合更完美。      总结：     CoordinatorLayout必须作为整个布局的父布局容器。                                   给需要滑动的组件设置 app:layout_scrollFlags=”scroll           enterAlways” 属性。                           给你的可滑动的组件，也就是RecyclerView 或者 NestedScrollView 设置如下属性:app:layout_behavior = @string/appbar_scrolling_view_behavior   给需要有折叠效果的组件设置 layout_collapseMode属性。   Chris Banes  android.support:design库作者  github: https://github.com/chrisbanes google+: https://plus.google.com/+ChrisBanes twitter: https://twitter.com/chrisbanes blog: http://chris.banes.me/  总结          阴影：android:elevation 和 android:translationZ           调色：通过android:colorPrimary 和 android:colorAccent、Palette萃取等           图标：使用遵循material design spec的icon           尺寸：注意8dp的整数倍           动效：波纹动画、循环揭示、共享元素转场、滑动、SVG动画等           组件：FAB、Appbar、Tabs、Cards、Lists等      兼容  样式与布局兼容     可以写对应的样式文件和布局文件        res/values/styles.xml.     res/values-v21/styles.xml.     res/layout/my_activity.xml     res/layout-v21/my_activity.xml      使用支持库提供的组件  使用兼容的主题：Theme.AppCompat     以下组件可以借助兼容主题来实现已有样式        EditText     Spinner     CheckBox     RadioButton     SwitchCompat     CheckedTextView      调色板    &lt;resources&gt;  &lt;style name=\"AppTheme\" parent=\"android:Theme.Material\"&gt;    &lt;item name=\"android:colorPrimary\"&gt;@color/primary&lt;/item&gt;    &lt;item name=\"android:colorPrimaryDark\"&gt;@color/primary_dark&lt;/item&gt;    &lt;item name=\"android:colorAccent\"&gt;@color/accent&lt;/item&gt;   &lt;/style&gt; &lt;/resources&gt;    使用第三方组件库  自己造轮子  先熟悉API，再查看官方设计指南，利用现有API进行封装  Best-In-Class Android Design  Material Design团队整理的Google Play上比较好的MD风格的App    https://play.google.com/store/apps/collection/promotion_3001769_io_awards  附录  这次的PPT下载地址"
  },
  
  {
    "title": "Java多线程之并发工具类",
    "url": "/posts/java-thread-tools/",
    "categories": "Java",
    "tags": "多线程",
    "date": "2016-03-05 00:00:00 +0800",
    "content": "CountDownLatch  CountDownLatch 允许一个或多个线程等待其他线程完成操作。假如有一个需求是我们需要下载多组数据，此时可以考虑多线程，每个线程下载一组，直到所有数据现在完，这里如果要实现主线程等待所有线程完成下载工作，最简单就会用到join方法。：  public static class MultiThreadDownload {     public static void main(String[] args) throws InterruptedException {         Thread task1 = new Thread(new Runnable() {             @Override             public void run() {                 System.out.println(\"下载数据1\");             }         });         Thread task2 = new Thread(new Runnable() {             @Override             public void run() {                 System.out.println(\"下载数据2\");             }         });         task1.start();         task2.start();         task1.join();         task2.join();         System.out.println(\"所有数据下载完成\");     } }   其中上面代码中join方法用于让当前执行线程等待join线程执行结束。其实现原理是不停检查join线程是否存活， 如果 join 线程存活则让当前线程永远等待。  而JDK1.5提供了CountDownLatch同于可以实现上面join的功能，并且比join功能还要多。  public static class MultiThreadDownload {     static CountDownLatch c = new CountDownLatch(2);      public static void main(String[] args) throws InterruptedException {         Thread task1 = new Thread(new Runnable() {             @Override             public void run() {                 System.out.println(\"下载数据1\");                 c.countDown();             }         });         Thread task2 = new Thread(new Runnable() {             @Override             public void run() {                 System.out.println(\"下载数据2\");                 c.countDown();             }         });         task1.start();         task2.start();         c.await();         System.out.println(\"所有数据下载完成\");     } }    CountDownLatch 的构造函数接收一个int 类型的参数作为计数器，如果你想等待N个点完成，这里就传入N。  当我们调用 CountDownLatch 的 countDown 方法时，N 就会 -1，CountDownLatch 的 await 方法会阻塞当前线程，直到 N 变成零。由于 countDown 方法可以用在任何地方，所以这里说的 N 个点，可以是 N个线程，也可以是 1个线程里的N个执行步骤。用在多个线程时，只需要把这个 CountDownLatch 的引用传递到线程里即可。  同步屏障CyclicBarrier  CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。 它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。  CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示 屏障拦截的线程数量，每个线程调用 await 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。  public class Main {    \tprivate static CyclicBarrier c = new CyclicBarrier(2); \tpublic static void main(String[] args) {         new Thread(new Thread() {             @Override             public void run() {                 try {                     c.await();                 }catch(Exception e) {                     e.printStackTrace();                 }             }         }).start()                       try {              c.await();          }catch(Exception e) {               e.printStackTrace();          }     } }    由于主线程和子线程都由CPU决定，两个线程都有可能先执行，所以执行的顺序不确定。  CyclicBarrier 还提供一个更高级的构造函数CyclicBarrier(int parties，Runnable barrierAction)，用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景。  public static class Main {     static CyclicBarrier c = new CyclicBarrier(2, new BarrierAction());      public static void main(String[] args) {         new Thread(new Runnable() {             @Override             public void run() {                 try {                     c.await();                 } catch (Exception e) {                     e.printStackTrace();                 }             }         }).start();         try {             c.await();         } catch (Exception e) {             e.printStackTrace();         }     }      static class BarrierAction implements Runnable {         @Override         public void run() {             System.out.println(\"执行后续工作\");         }     } }   CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。 所以CyclicBarrier能处理更为复杂的业务场景。 例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。  信号量Semaphore  Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。  最简单的理解信号量就是，一个计数器、一个等待队列、两个方法（在Java实现的Semaphore中就是acquire和release）。 调用一次acquire方法，计数器就减1，如果此时计数器小于0，则阻塞当前线程，否则当前线程可继续执行。 调用一次release方法，计数器就加1，如果此时计数器小于等于0，则唤醒一个等待队列中的线程，并将其中等待队列中移除。  Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。如果需要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。  public class Main {      private static final int THREAD_COUNT = 30;      private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);      private static Semaphore s = new Semaphore(10);      public static void main(String[] args) {         for (int i = 0; i &lt; THREAD_COUNT; i++) {              threadPool.execute(new Runnable() {                 @Override                 public void run() {                     try {                         s.acquire();                         System.out.println(\"save data\");                         s.release();                     } catch (InterruptedException e) {                         e.printStackTrace();                     }                 }             });         }         threadPool.shutdown();     } }   代码中，虽然有 30 个线程执行，但只允许 10 个线程并发执行。Semaphore 的构造方法 Semaphore(int permits) 接受一个整型的数字，表示可用的许可证数量。Semaphore 的用法也很简单，首先线程使用 Semaphore 的 acquire() 方法获取一个许可证，使用完之后调用 release() 方法归还即可，还可以使用 tryAcquire() 方法尝试获取许可证  实现互斥锁  public class SemaphoreMutex {      private static final Semaphore SEMAPHORE = new Semaphore(1);      public static void main(String[] args) {         SemaphoreMutex semaphoreMutex = new SemaphoreMutex();         for (int i = 0; i &lt; 10; i++) {             new Thread(semaphoreMutex::method).start();         }     }      @SneakyThrows     public void method() {         // 同时只会有一个线程执行此方法！         SEMAPHORE.acquire();         try {             System.out.println(Thread.currentThread().getName() + \"线程正在执行！\");             Thread.sleep(1000);         } finally {             SEMAPHORE.release();             System.out.println(Thread.currentThread().getName() + \"线程执行结束！\");         }     } }    从代码看上面每次都是一个线程执行结束后，才会有另一个开始执行，实现了互斥锁的功能。  线程间交换数据的Exchanger  Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据， 如果第一个线程先执行exchange方法，它会一直等待第二个线程也执行exchange，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。  假设现在有一个需求：我们需要将纸质银行流水通过人工的方式录入电子银行流水，为了避免错误，采用 AB 岗两人进行录入，录入完成后，系统需加载这两人录入的数据进行比较，看看是否录入一致  public class Main {      private static final Exchanger&lt;String&gt; exchanger = new Exchanger&lt;&gt;();      private static ExecutorService threadPool = Executors.newFixedThreadPool(2);      public static void main(String[] args) {          threadPool.execute(new Runnable() {              @Override             public void run() {                 try {                     // A录入银行流水数据                     String A = \"银行流水A\";                     exchanger.exchange(A);                 } catch (InterruptedException e) {                     e.printStackTrace();                 }             }         });          threadPool.execute(new Runnable() {              @Override             public void run() {                 try {                     // B录入银行流水数据                     String B = \"银行流水B\";                     String A = exchanger.exchange(B);                     System.out.println(\"A 和 B 数据是否一致：\" + A.equals(B) + \", A 录入的是：\" + A                         + \", B 录入的是：\" + B);                 } catch (InterruptedException e) {                     e.printStackTrace();                 }             }         });          threadPool.shutdown();     } }     如果两个线程一个没有执行exchange方法，则会一直等待，如果担心有特殊情况发送，避免一直等待，可以使用exchange(V x, longtimeout, TimeUnit unit）设置最大等待时长。"
  },
  
  {
    "title": "Java多线程之线程通信",
    "url": "/posts/java-thread-communication/",
    "categories": "Java",
    "tags": "多线程",
    "date": "2016-02-27 00:00:00 +0800",
    "content": "等待/通知机制  在不使用等待/通知机制的程序，如果实现两个线程间通信，往往使用的就是while语句轮询来检测某一个条件，这样会浪费CPU资源。  在前面的介绍中，synchronized解决了多线程竞争的问题。但是synchronized并没有解决多线程协调的问题。多个线程之间也可以实现通信，原因就是多个线程共同访问同一个变量。但是这种通信机制不是 “等待/通知” ，两个线程完全是主动地读取一个共享变量。简单的说，等待/通知机制就是一个【线程A】等待，一个【线程B】通知（线程A可以不用再等待了）。  在Java语言中，实现等待通知机制主要是用：wait()/notify()方法实现  在wait()方法 ：wait()方法是使当前执行代码的线程进行等待，wait()方法是Object类的方法，该方法用来将当前线程置入“欲执行队列”中，并且在wait()所在的代码处停止执行，直到接到通知或被中断为止。在调用wait()方法之前，线程必须获得该对象的对象级别锁，即只能在同步方法或者同步块中调用wait()方法。在执行wait()方法后，当前线程释放锁。 notify()方法：方法notify()也要在同步方法或同步块中调用，即在调用前，线程也必须获得该对象的对象级别锁。 这两个方法都需要同synchronized关键字联用。  public class Main {     \tpublic static void main(String[] args) {         String username = new String(\"yuxingxin\");         try {             username.wait();         } catch (InterruptedException e) {             e.printStackTrace();         }     } }   运行抛出如下异常：java.lang.IllegalMonitorStateException，具体的原因是：没有“对象监视器”，也就是没有同步加锁。修改如下：  public class Main {        private Object object = new Object();  \tpublic static void main(String[] args) {         synchronized(object) {             try {                 object.wait();             } catch (InterruptedException e) {                 e.printStackTrace();             }         }     } }   此示例运行成功，但是会运行到object.wait()时卡住，因为没有notify()唤醒它。  这里有几点需要注意：     执行完上面同步代码块，就会释放对象的锁。   执行同步代码块的过程中，如果遇到了异常，比如调用interrupt方法，而导致线程终止，锁也会被释放   在执行同步代码块的过程中，执行了锁所属对象的wait方法，这个线程会释放对象锁，而此线程对象也会进入线程等待池中，等待被唤醒。   notify()方法一次只随机通知一个线程进行唤醒，唤醒所有线程可以使用notifyAll()方法。  生产/消费模型  等待/通知最典型的案例就是生产者/消费者模型  其中等待方遵循如下原子：     获取对象的锁。   如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。   条件满足则执行对应的逻辑。   // 伪代码 synchronized(object) {     while(条件不满足) {     \tobject.wait();     }     // 对应的处理逻辑 }   通知方遵循如下原则:     获得对象的锁。   改变条件。   通知所有等待在对象上的线程。   // 伪代码 synchronized(object) {     // 改变条件     // 执行通知     object.notifyAll(); }    ThreadLocal  变量值的共享可以使用public static变量的形式，所有线程都是用同一个变量，如果想实现每一个线程都有自己的共享变量，那么ThreadLocal就派上用场了。  类ThreadLocal主要解决的就是每个线程绑定自己的值，可以将ThreadLocal类比喻成全局存放数据的盒子，盒子中可以存储每个线程的私有数据。  创建和使用  支持泛型  ThreadLocal&lt;String&gt; stringThreadLocal = new ThreadLocal&lt;&gt;(); stringThreadLet.set(\"yuxingxin\"); stringThreadLocal.get();  // 设置初始值 ThreadLocal&lt;String&gt; mThreadLocal = new ThreadLocal&lt;String&gt;() {     @Override     protected String initialValue() {       return Thread.currentThread().getName();     } };   在Android中，Looper类就是利用了ThreadLocal的特性，保证每个线程只存在一个Looper对象。  static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); private static void prepare(boolean quitAllowed) {     if (sThreadLocal.get() != null) {         throw new RuntimeException(\"Only one Looper may be created per thread\");     }     sThreadLocal.set(new Looper(quitAllowed));t }"
  },
  
  {
    "title": "Java多线程之线程同步锁机制",
    "url": "/posts/java-thread-lock/",
    "categories": "Java",
    "tags": "多线程",
    "date": "2016-02-20 00:00:00 +0800",
    "content": "Lock接口  锁是用来控制多个线程访问共享资源的方式，在Java SE 5之前，Java程序主要靠synchronized关键字来实现锁功能，Java SE 5之后并发包中新增了Lock接口以及相关实现类用来实现锁功能。它提供了与synchronized关键字类似的同步功能，只是在使用时需要显示的获取和释放锁，虽然它缺少了隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。  例如：针对一个场景，手把手进行锁获取和释放，先获得锁A，然后再获取锁B，当锁B获得后，释放锁A同时获取锁C，当锁C获得后，再释放B同时获取锁D，以此类推。这种情况下，synchronized关键字就不那么容易实现了，而使用Lock就容易的多。  Lock lock = new ReentrantLock(); lock.lock(); try{     // …… }finally {     lock.unlock(); }   在finally块中释放锁，目的是保证在获取到锁之后，最终能够释放锁。注意不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故被释放。  它的API：     void lock()：获取锁，调用该方法当前线程会获取锁，当获得锁后，从方法返回   void lockInterruptibly() throws InterruptedException：可中断地获取锁，和lock()方法的不同之处在于该方法会响应中断，即在锁的获取中可以中断当前线程。   boolean tryLock()：尝试非阻塞的获取锁，调用该方法后立即返回，如果能够获取则返回true，否则返回false   boolean tryLock(long time , TimeUnit unit) throws InterruptedException：超时获取锁，当前线程在以下3种情况会返回：            当前线程在超时时间内获得了锁       当前线程在超时时间内被中断       超时时间结束，返回false           void unlock()：释放锁   Condition new Condition()：获取等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的wait方法，而调用后，当前线程将释放锁。   队列同步器AQS（AbstractQueuedSynchronizer）是用来构建锁或者其他同步组件的基础框架，它使用一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。有关同步器的更多原理可以自行学习。  重入锁  重入锁ReentrantLock，顾名思义，就是支持重新进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁还支持获取锁时的公平和非公平性选择。  如果在绝对时间上，先对锁进行获取的请求一定先被满足，那么这个锁就是公平的，反之，是不公平的，公平的获取锁，也就是等待时间最长的线程最优先获取锁，也可以说锁获取是顺序的。ReentrantLock提供一个构造函数，能够满足锁是否是公平的。  而像Mutex类的锁通过lock方法获取锁之后，如果再次调用lock方法，该线程将会被自己阻塞，所以这类锁就不是一个重入锁，而前面提到的synchronized关键字隐式的支持重进入，比如一个synchronized修饰的递归方法，在方法执行时，执行线程在获取了锁之后，仍能够连续多次的获得该锁。  前面的例子中，synchronized关键字用于加锁，这种锁很重，获取时一直等待，没有额外的尝试机制，而我们用ReentrantLock再看下：  // 使用synchronized public class Main {     private int count;      public void add(int n) {         synchronized(this) {             count += n;         }     } }  // 使用ReentrantLock public class Main {     private final Lock lock = new ReentrantLock();     private int count;      public void add(int n) {         lock.lock();         try {             count += n;         } finally {             lock.unlock();         }     } }    因为synchronized是Java语言层面提供的语法，所以我们不需要考虑异常，而ReentrantLock是Java代码实现的锁，我们就必须先获取锁，然后在finally中正确释放锁。  顾名思义，ReentrantLock是可重入锁，它和synchronized一样，一个线程可以多次获取同一个锁。  和synchronized不同的是，ReentrantLock可以尝试获取锁：  if (lock.tryLock(1, TimeUnit.SECONDS)) {     try {         // ...     } finally {         lock.unlock();     } }   上述代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，tryLock()返回false，程序就可以做一些额外处理，而不是无限等待下去。所以，使用ReentrantLock比直接使用synchronized更安全，线程在tryLock()失败的时候不会导致死锁。  读写锁  之前提到的锁（Mutex类和ReentrantLock）基本都是排他锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大的提升。  在没有读写锁支持的时候，如果需要完成上述工作就要使用Java的等待通知机制，就是当写操作开始时，所有晚于写操作的读操作均会进入等待状态， 只有写操作完成并进行通知之后，所有等待的读操作才能继续执行（写操作之间依靠synchronized关键字同步），这样做的目的是使读操作能读取到正确的数据，不会出现脏数据。改用读写锁实现上述功能，只需要在读操作时获取读锁，写操作时获取写锁，当写锁被获取到后，后续（非当前的写操作线程）的读写操作都会被阻塞，写锁释放之后，所有操作继续执行，编程方式相对于使用等待通知机制的实现方式而言，变得简单明了。  public class Main {   private int x = 0;   ReentrantReadWriteLock lock = new ReentrantReadWriteLock();   Lock readLock = lock.readLock();   Lock writeLock = lock.writeLock();    private void count() {     writeLock.lock();     try {       x++;     } finally {       writeLock.unlock();     }   }    private void print(int time) {     readLock.lock();     try {       System.out.print(x + \" \");     } finally {       readLock.unlock();     }   } }   把读写操作分别用读锁和写锁来加锁，在读取时，多个线程可以同时获得读锁，这样就大大提高了并发读的执行效率。  如果我们深入分析ReentrantReadWriteLock，会发现它有个潜在的问题：如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种悲观的读锁。要进一步提升并发执行效率，Java 8引入了新的读写锁：StampedLock。  StampedLock和ReentrantReadWriteLock相比，改进之处在于：读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁。乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。  public class Main {   private int x = 0;   private final StampedLock stampedLock = new StampedLock();   Lock readLock = lock.readLock();   Lock writeLock = lock.writeLock();    private void count() {     long stamp = stampedLock.writeLock(); // 获取写锁     try {       x++;     } finally {       stampedLock.unlockWrite(stamp); // 释放写锁     }   }    private void print(int time) {     long stamp = stampedLock.tryOptimisticRead(); // 获得一个乐观读锁     double currentX = x;     if (!stampedLock.validate(stamp)) { // 检查乐观读锁后是否有其他写锁发生         stamp = stampedLock.readLock(); // 获取一个悲观读锁         try {           currentX = x;         } finally {           stampedLock.unlockRead(stamp); // 释放悲观读锁         }     }     System.out.print(currentX + \" \");   } }   和ReentrantReadWriteLock相比，写入的加锁是完全一样的，不同的是读取。注意到首先我们通过tryOptimisticRead()获取一个乐观读锁，并返回版本号。接着进行读取，读取完成后，我们通过validate()去验证版本号，如果在读取过程中没有写入，版本号不变，验证成功，我们就可以放心地继续后续操作。如果在读取过程中有写入，版本号会发生变化，验证将失败。在失败的时候，我们再通过获取悲观读锁再次读取。由于写入的概率不高，程序在绝大部分情况下可以通过乐观读锁获取数据，极少数情况下使用悲观读锁获取数据。  可见，StampedLock把读锁细分为乐观读和悲观读，能进一步提升并发效率。但这也是有代价的：一是代码更加复杂，二是StampedLock是不可重入锁，不能在一个线程中反复获取同一个锁。  StampedLock还提供了更复杂的将悲观读锁升级为写锁的功能，它主要使用在if-then-update的场景：即先读，如果读的数据满足条件，就返回，如果读的数据不满足条件，再尝试写。  Condition接口  前面我们提到，在没有读写锁支持的时候，如果需要完成读写锁的需求就要使用Java的等待通知机制（wait/notify），synchronized可以配合wait和notify实现线程在条件不满足时等待，条件满足时唤醒，用ReentrantLock我们怎么编写wait和notify的功能呢？答案是使用Condition对象来实现wait和notify的功能。  // 使用ReentrantLock public class Main {     private final Lock lock = new ReentrantLock();     private final Condition condition = lock.newCondition();      public viud conditionalWait() throws InterruptedException {         lock.lock();         try{             condition.await();         } finally {             lock.unlock();         }     }          public void conditionSignal() throws InterruptedException {         lock.lock();         try{             condition.signal();         }finally {             lock.unlock();         }     } }   可见，使用Condition时，引用的Condition对象必须从Lock实例的newCondition()返回，这样才能获得一个绑定了Lock实例的Condition实例。  Condition提供的await()、signal()、signalAll()原理和synchronized锁对象的wait()、notify()、notifyAll()是一致的，并且其行为也是一样的：     await()会释放当前锁，进入等待状态；   signal()会唤醒某个等待线程；   signalAll()会唤醒所有等待线程；   唤醒线程从await()返回后需要重新获得锁。   此外，和tryLock()类似，await()可以在等待指定时间后，如果还没有被其他线程通过signal()或signalAll()唤醒，可以自己醒来：  if (condition.await(1, TimeUnit.SECOND)) {     // 被其他线程唤醒 } else {     // 指定时间内没有被其他线程唤醒 }   可见，使用Condition配合Lock，我们可以实现更灵活的线程同步。  并发容器  我们知道多线程环境中，集合类都不是线程安全的类，而Java提供了一套标准的线程安全集合，如List类，Map类，Set类，Queue类，Deque类等                 接口       非线程安全       线程安全                       List       ArrayList       CopyOnWriteArrayList                 Map       HashMap       ConcurrentHashMap                 Set       HashSet / TreeSet       CopyOnWriteArraySet                 Queue       ArrayDeque / LinkedList       ArrayBlockingQueue / LinkedBlockingQueue / ConcurrentLinkedQueue等                 Deque       ArrayDeque / LinkedList       LinkedBlockingDeque           使用这些并发集合与使用非线程安全的集合类完全相同。"
  },
  
  {
    "title": "Java多线程之线程同步",
    "url": "/posts/java-thread_synchronized/",
    "categories": "Java",
    "tags": "多线程",
    "date": "2016-02-07 00:00:00 +0800",
    "content": "synchronized  非线程安全其实是会在多个线程对同一个对象中的实例进行访问时发生，产生的后果就是”脏读”，也就是说取到的数据是被修改过的，即多个线程同时读写共享变量，而”线程安全”就是以获得的实例变量的值经过同步处理的，不会出现脏读的现象，  提起线程同步，我们首先想到的方法就是synchronized关键字。     修饰实例方法，作用于当前实例加锁，进入同步代码钱要获得当前实例的锁   修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁   修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁   接下来我们看下实例：  public class Main implements Runnable{     //共享资源(临界资源)     static int i=0;      public void increase(){         i++;     }     @Override     public void run() {         for(int j=0;j&lt;10000;j++){             increase();         }     }     public static void main(String[] args) throws InterruptedException {         Main instance=new Main();         Thread t1=new Thread(instance);         Thread t2=new Thread(instance);         t1.start();         t2.start();         t1.join();         t2.join();         System.out.println(i);     }     /**      * 输出结果:      * 2000000      */ }    从上面实例可以看出，两个线程同时对一个int变量进行操作，每个都分别加10000次，最后结果应该是20000，但是，每次运行，结果实际上都是不一样的。  这是因为变量的读取和写入需要是原子操作，而上面的很明显不是，针对上面代码修改：  /**   * synchronized 修饰实例方法 */ public synchronized void increase(){     i++; }   上面synchronized修饰的是类方法，锁的是实例，当多个线程操作不同实例时，会使用不同实例的锁，就无法保证static变量的有序性了。如下：  public class Main implements Runnable{     static int i=0;     public synchronized void increase(){         i++;     }     @Override     public void run() {         for(int j=0;j&lt;10000;j++){             increase();         }     }     public static void main(String[] args) throws InterruptedException {         //new新实例         Thread t1=new Thread(new Main());         //new新实例         Thread t2=new Thread(new Main());         t1.start();         t2.start();                  t1.join();         t2.join();         System.out.println(i);     } }   所以当sychronized修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁。而作用于静态方法时，锁就是当前类到class对象锁。由于静态成员变量不专属于任何一个实例对象，是类成员，因此通过class对象锁可以控制静态成员的并发操作。  public class Main implements Runnable {     static int i=0;     public synchronized static void increase() {         // ……     } }   // 相当于 public class Main implements Runnable {     static int i=0;     public static void increase() {         synchronized(Main.class){             // ……         }      } }    修饰代码块时，指定加锁对象，对给定加锁对象，进入同步代码块前要获得给定对象的锁。  public class Main implements Runnable{     static Object instance=new Object();     static int i=0;     @Override     public void run() {         //省略其他耗时操作....         //使用同步代码块对变量i进行同步操作,锁对象为instance         synchronized(instance){             for(int j=0;j&lt;10000;j++){                     i++;               }         }     }     public static void main(String[] args) throws InterruptedException {         Thread t1=new Thread(instance);         Thread t2=new Thread(instance);         t1.start();         t2.start();         t1.join();         t2.join();         System.out.println(i);     } }   上述代码，将synchronized作用于一个给定的实例对象instance, 即当前实例对象就是锁对象，每次当线程进入synchronized包裹到代码块时，就会要求当前线程持有instance实例对象锁，如果当前有其他线程正持有该对象锁，那么新到到线程就必须等待，这样也就保证了每次只有一个线程执行i++操作。当然， 还可以使用this或者class  //this,当前实例对象锁 synchronized(this){     for(int j=0;j&lt;10000;j++){         i++;     } }  //class对象锁 synchronized(Main.class){     for(int j=0;j&lt;10000;j++){         i++;     } }   多线程死锁  Java线程锁为可重入的锁，所谓可重入锁是JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做可重入锁。  public class Counter {     private int count = 0;      public synchronized void add(int n) {         if (n &lt; 0) {             dec(-n);         } else {             count += n;         }     }      public synchronized void dec(int n) {         count += n;     } }   观察synchronized修饰的add()方法，一旦线程执行到add()方法内部，说明它已经获取了当前实例的this锁。如果传入的n &lt; 0，将在add()方法内部调用dec()方法。可以看到dec()方法也需要获取this锁，由于Java的线程锁是可重入锁，所以，获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。每获取一次锁，记录+1，每退出synchronized块，记录-1，减到0的时候，才会真正释放锁。  在获取多个锁的时候，不同线程获取多个不同对象的锁可能导致死锁。改造下上面代码：  public class Counter {     private int count = 0;     private Object monitor1 = new Object();     private Object monitor2 = new Object();      public void add() {         synchronized(monitor1){             this.count++;             synchronized(monitor2){                 this.count++;             }         }     }      public void dec() {         synchronized(monitor2){             this.count--;             synchronized(monitor1){                 this.count--;             }         }     } }   如上，如果线程1和线程2分别执行add和dec方法：     线程1：进入add()，获得monitor1；   线程2：进入dec()，获得monitor2。   随后：     线程1：准备获得monitor2，失败，等待中；   线程2：准备获得monitor1，失败，等待中。   此时，两个线程各自持有不同的锁，然后各自试图获取对方手里的锁，造成了双方无限等待下去，这就是死锁。  死锁发生后，没有任何机制能解除死锁，只能强制结束JVM进程。  volatile  volatile的主要作用是使变量在多个线程间可见。举例如下：  public class Main {   private boolean isRunning = true;    private void setRunning(boolean isRunning) {     this.isRunning = isRunning;   }       public void print() {     new Thread() {       @Override       public void run() {         while (isRunning) {             System.out.println(\"print running log\")         }       }     }.start();          try {       Thread.sleep(1000);     } catch (InterruptedException e) {       e.printStackTrace();     }            // 执行停止     setRunning(false);   } }    上面代码程序运行后，根本停不下来，处于死循环中。解决的办法就是给变量加上volatile关键字，使强制从公共堆栈中读取变量的值，而不是从线程私有数据栈中读取变量的值。而setRunning方法更新的是公共堆栈中的isRunning为false，但是线程私有堆栈中取得的isRunning一直为true，所以就一直为死循环状态。  这个问题其实就是线程私有堆栈当中的值和公关堆栈中的值不同步造成的，解决这样的问题就是使用volatile关键字了，它主要作用就是当线程方位isRunning这个变量时，强制从公告堆栈中进行取值。  public class Main {   private volatile boolean isRunning = true;    private void setRunning(boolean isRunning) {     this.isRunning = isRunning;   }       public void print() {     new Thread() {       @Override       public void run() {         while (isRunning) {             System.out.println(\"print running log\")         }       }     }.start();          try {       Thread.sleep(1000);     } catch (InterruptedException e) {       e.printStackTrace();     }            // 执行停止     setRunning(false);   } }    由此可见，使用volatile增加了实例变量在多个线程之间的可见性。但是它不能保证原子性，而sychronized可以保证原子性。  public class Main implements Runnable{     volatile static int i=0;     public static void increase(){         i++;     }     @Override     public void run() {         for(int j=0;j&lt;10000;j++){             increase();         }     }     public static void main(String[] args) throws InterruptedException {         Main instance=new Main();         Thread t1=new Thread(instance);         Thread t2=new Thread(instance);         t1.start();         t2.start();                  t1.join();         t2.join();         System.out.println(i);     } }   上面这个例子，最后的记过却不对，不是20000，原因也就是因为i++本身不是原子操作，它的步骤分为：     从内存中取出i的值   计算i的值   将i的值写到内存中   上面示例中加上synchronized关键字就可以了，关键字volatile使用的场合是在多个线程中可以感知实例变量被更改了， 并且可以获得最新的值使用，也就是多线程读取共享变量时可以获得最新的值使用。  当然上面这个问题我们也可以使用原子类来解决。  原子类  原子操作是不可分割的整体，没有其他线程能够中断或者检查正在原子操作中的变量，一个原子（atomic）类型就是一个原子操作可用的类型，他可以在没有锁的情况下做到线程安全(thread-safe)，代码如下：  public class Main implements Runnable{     private AtomicInteger count = new AtomicInteger()          @Override     public void run() {         for(int j=0;j&lt;10000;j++){             count.incrementAndGet();             // count.getAndIncrement();         }     }     public static void main(String[] args) throws InterruptedException {         Main instance=new Main();         Thread t1=new Thread(instance);         Thread t2=new Thread(instance);         t1.start();         t2.start();                  t1.join();         t2.join();         System.out.println(count.get());     } }    它的主要原理就是利用了CAS：Compare and Set。CAS 操作包含三个操作数 ： 内存位置、预期数值和新值。CAS 的实现逻辑是将内存位置处的数值与预期数值想比较，若相等，则将内存位置处的值替换为新值。若不相等，则不做任何操作。在 Java 中，Java 并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的。Java 代码需通过 JNI 才能调用。  CAS 与 Synchronized 的使用情景：　　　     对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。   对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。   补充： synchronized 在 jdk1.6 之后，已经改进优化。synchronized 的底层实现主要依靠 Lock-Free 的队列，基本思路是自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和 CAS 类似的性能；而线程冲突严重的情况下，性能远高于 CAS。  当然CAS也存在一些问题：  ABA问题  谈到 CAS，基本上都要谈一下 CAS 的 ABA 问题。CAS 由三个步骤组成，分别是“读取-比较-写回”。考虑这样一种情况，线程1和线程2同时执行 CAS 逻辑，两个线程的执行顺序如下：     时刻1：线程1执行读取操作，获取原值 A，然后线程被切换走   时刻2：线程2执行完成 CAS 操作将原值由 A 修改为 B   时刻3：线程2再次执行 CAS 操作，并将原值由 B 修改为 A   时刻4：线程1恢复运行，将比较值(compareValue)与原值(oldValue)进行比较，发现两个值相等。   然后用新值(newValue)写入内存中，完成 CAS 操作  如上流程，线程1并不知道原值已经被修改过了，在它看来并没什么变化，所以它会继续往下执行流程。对于 ABA 问题，通常的处理措施是对每一次 CAS 操作设置版本号。  ABA问题的解决思路其实也很简单，就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A了。  java.util.concurrent.atomic 包下提供了一个可处理 ABA 问题的原子类 AtomicStampedReference，这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。  自旋CAS  自旋CAS（不成功，就一直循环执行，直到成功） 如果长时间不成功，会给 CPU 带来非常大的执行开销。如果JVM能支持处理器提供的 pause 指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline），使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起 CPU 流水线被清空（CPU pipeline flush），从而提高 CPU 的执行效率。  其他原子类  我们总结下Java提供的原子类：  原子更新基本类型类     AtomicInteger：原子更新整型   AtomicBoolean：原子更新布尔类型   AtomicLong：原子更新长整型   原子更新数组     AtomicIntegerArray ： 原子更新整型数组里的元素   AtomicLongArray: 原子更新长整型数组里的元素   AtomicReferenceArray： 原子更新引用类型数组里的元素   原子更新引用类型     AtomicReference：原子更新引用类型   AtomicReferenceFieldUpdater：原子更新引用类型里的字段   AtomicMarkableReference：原子更新带有标记为的引用类型   原子更新字段类     AtomicIntegerFieldUpdater：原子更新整型字段的更新器   AtomicLongFieldUpdater：原子更新长整型字段的更新器   AtomicStampedReference：原子更新带有版本号的引用类型   单例模式  在保证线程安全的前提下，最简单的实现方式是“饿汉式”，即在加载单例类的字节码时，在初始化阶段对静态的instance变量进行赋值，代码如下:  //“饿汉式”实现线程安全的单例模式 public class Singleton {     private static Singleton instance = new Singleton();          private Singleton() {     }          public static Singletion getInstance() {         return instance;     } }   如果我们希望延迟初始化这个单例对象，就不能使用上述的“饿汉式”实现，而要使用“懒汉式”的实现。最容易想到的一种实现方式当然是使用synchronized关键字对getInstance()方法进行修饰。代码如下:  //使用同步方法实现的单例模式 public class Singleton {     private static Singleton instance;          private Singleton(){     }          public static synchronized getInstance() {         if (instance == null) {             instance = new Singleton();         }                  return instance;     } }   这是最简单的单例模式的延迟初始化实现版本，并且通过synchonized锁住了Singleton这个类的字节码，保证了线程安全。但是，这种锁字节码的方式粒度太大，同一时间只能有一个线程执行同步方法拿到这个单例，因此，在高并发环境下，吞吐量严重受限。为了提升并发性能，我们使用DCL(double-check-locking)双检查锁机制来实现单例模式，代码如下：  public class SingleInstance {   private static volatile SingleInstance mInstance;    private SingleInstance() {   }    public static SingleInstance newInstance() {     if (mInstance == null) {       synchronized (SingleInstance.class) {         if (mInstance == null) {           mInstance = new SingleInstance();         }       }     }     return mInstance;   } }   DCL方式将同步方法改成了同步代码块，锁的粒度缩小，并发性能更好。当单例对象已经被创建之后，多个线程可以同时执行第一个if条件判断并且拿到单例对象。当单例对象未被创建时，同一时间只有一个线程能进入同步代码块进行第二次if条件判断，如果发现此时单例对象仍没有被其他线程所创建，则创建单例对象。"
  },
  
  {
    "title": "Java多线程之基础",
    "url": "/posts/java-thread/",
    "categories": "Java",
    "tags": "多线程",
    "date": "2016-02-01 00:00:00 +0800",
    "content": "基本概念  说起线程，就不得不先提下进程，在计算机中，我们把一个任务称为一个进程，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。某些进程内部还需要同时执行多个子任务。例如，我们在使用Word时，Word可以让我们一边打字，一边进行拼写检查，同时还可以在后台进行打印，我们把子任务称为线程。  进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。而操作系统调度的最小任务单位就是进程，同一个应用程序，既可以有多个进程，也可以有多个线程。  线程创建  Java中常见的两种创建线程的方法：  继承Thread类  通常我们实例化一个Thread实例，然后调用它的start()方法：  public class Main {     public static void main(String[] args) {         Thread t = new MyThread();         t.start(); // 启动新线程     } }  class MyThread extends Thread {     @Override     public void run() {         System.out.println(\"start new thread!\");     } }   实现Runnable接口  创建Thread实例时，并传入一个Runnable实例：  public class Main {     public static void main(String[] args) {         Thread t = new Thread(new MyRunnable());         t.start(); // 启动新线程     } }  class MyRunnable implements Runnable {     @Override     public void run() {         System.out.println(\"start new thread!\");     } }   守护线程  在Java线程中，有两种线程，一种是用户线程，一种是守护线程。  守护线程是一种特殊的线程，有”陪伴”的含义，当进程中不存在非守护线程了，则守护线程自动销毁。典型的守护线程就是垃圾回收线程。用个通俗的比喻：任何一个守护线程都是整个JVM非守护线程的『保姆』，只要当前JVM实例中还存在任何一个非守护线程没有结束，那么守护线程就在工作。  public class Mythread extends Thread {     private int i = 0;     @Override     public void run() {         try {             while(true){                 i++;                 System.out.println(\"i=\" + i);                 Thread.sleep(1000);             }         } catch(InterruptedException e){             e.printStackTrace(); \t\t}     } }  public class Main {     public static void main(String[] args) {         Mythread t = new Mythread();         t.setDaemon(true);         t.start(); // 启动新线程         try{             Thread.sleep(5000);             System.out.println(\"主线程已经结束了，t线程（守护线程）也不再打印了\")         }catch(InterruptedException e){             e.printStackTrace(); \t\t}              } }   线程方法  暂停执行sleep  我们可以在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），这个正在执行的线程即是this.currentThread()返回的线程。  public class Main {     public static void main(String[] args) {         System.out.println(\"main start...\");         Thread t = new Thread() {             public void run() {                 System.out.println(\"thread run...\");                 try {                     Thread.sleep(10);                 } catch (InterruptedException e) {}                 System.out.println(\"thread end.\");             }         };         t.start();         try {             Thread.sleep(20);         } catch (InterruptedException e) {}         System.out.println(\"main end...\");     } }   join方法  在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其它的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到 join() 方法了。  JDK 中对 join 方法解释为：“等待该线程终止”（Waits for this thread to die），换句话说就是：“当前线程等待子线程的终止”。也就是在子线程调用了 join() 方法后面的代码，只有等到子线程结束了当前线程才能执行。  中断线程interrupt  我们使用interrupt()方法效果并不会像for循环中break那样，马上停止循环，而是在当前线程中打了一个停止的标记，并不是真的停止线程。我们可以通过调用isInterrupted()方法来判断当前线程是否已经结束运行。  public class Main {     public static void main(String[] args) throws InterruptedException {         Thread t = new MyThread();         t.start();         Thread.sleep(1); // 暂停1毫秒         t.interrupt(); // 中断t线程         t.join(); // 等待t线程结束         System.out.println(\"end\");     } }  class MyThread extends Thread { \t     @Override     public void run() {         int n = 0;         while (!isInterrupted()) {             n++;             System.out.println(n + \" hello!\");         }     } }   上面实例中，主线程通过调用t.interrupt()方法中断t线程，但是interrupt()方法仅仅向t线程发出了“中断请求”，至于t线程是否能立刻响应，要看具体代码。而t线程的while循环会检测isInterrupted()，所以上述代码能正确响应interrupt()请求，使得自身立刻结束运行run()方法。  如果线程处于等待状态，例如，t.join()会让main线程进入等待状态，此时，如果对main线程调用interrupt()，join()方法会立刻抛出InterruptedException，因此，目标线程只要捕获到join()方法抛出的InterruptedException，就说明有其他线程对其调用了interrupt()方法，通常情况下该线程应该立刻结束运行。  public class Main {     public static void main(String[] args) throws InterruptedException {         Thread t = new MyThread();         t.start();         Thread.sleep(1000);         t.interrupt(); // 中断t线程         t.join(); // 等待t线程结束         System.out.println(\"end\");     } }  class MyThread extends Thread {     @Override     public void run() {         Thread hello = new HelloThread();         hello.start(); // 启动hello线程         try {             hello.join(); // 等待hello线程结束         } catch (InterruptedException e) {             System.out.println(\"interrupted!\");         }         hello.interrupt();     } }  class HelloThread extends Thread {     @Override     public void run() {         int n = 0;         while (!isInterrupted()) {             n++;             System.out.println(n + \" hello!\");             try {                 Thread.sleep(100);             } catch (InterruptedException e) {                 break;             }         }     } }   main线程通过调用t.interrupt()从而通知t线程中断，而此时t线程正位于hello.join()的等待中，此方法会立刻结束等待并抛出InterruptedException。由于我们在t线程中捕获了InterruptedException，因此，就可以准备结束该线程。在t线程结束前，对hello线程也进行了interrupt()调用通知其中断。如果去掉这一行代码，可以发现hello线程仍然会继续运行，且JVM不会退出。  线程池  在Java中合理的利用线程池能够带来以下好处 ：     降低资源消耗，通过重复利用已创建的线程，从而降低线程创建和销毁带来的消耗。   提高响应速度，当任务到达时，任务可以不需要等到线程创建就能立即执行。   提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不进会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配，调优和监控。   原理  当向线程池提交一个任务时，处理流程是：     线程池判断核心线程池里的线程是否都在执行任务，如果不是，则创建一个新的工作线程来执行任务，如果核心线程池里的线程都在执行任务，则进入下个流程。   线程池判断工作队列是否已经满，如果工作队列没有满，则将新提交的任务存储在这个工作队列中，如果工作队列满了，则进入下个流程。   线程池判断线程池的线程是否都处于工作状态，如果没有，则创建一个新的工作 线程来执行任务，如果已经满了，则交给饱和策略来处理这个任务。   // 1. 创建线程池    // 创建时，通过配置线程池的参数，从而实现自己所需的线程池    Executor threadPool = new ThreadPoolExecutor(                                               CORE_POOL_SIZE,                                               MAXIMUM_POOL_SIZE,                                               KEEP_ALIVE,                                               TimeUnit.SECONDS,                                               sPoolWorkQueue,                                               sThreadFactory                                               );  // 2. 向线程池提交任务：execute（）,summit用于提交有返回值的任务(Future)     // 说明：传入 Runnable对象        threadPool.execute(new Runnable() {             @Override             public void run() {                 ... // 线程执行任务             }         });  // 3. 关闭线程池shutdown()    threadPool.shutdown();       注意上面的关闭线程池，有两种方法  shutdown()和shutdownNow()，他们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法停止，但是他们存在一定的区别：  shutdownNow首先将线程池的状态设置为STOP，然后尝试停止所有正在执行或者暂停任务的线程，并返回等待执行任务的列表。  shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。  只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true，当所有任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true，至于应该用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。  常见的4类线程池  根据参数的不同配置，Java中最常见的线程池有4类：     定长线程池（FixedThreadPool）   定时线程池（ScheduledThreadPool ）   可缓存线程池（CachedThreadPool）   单线程化线程池（SingleThreadExecutor）   定长线程池（FixedThreadPool）  只有核心线程 &amp; 不会被回收、线程数量固定、任务队列无大小限制（超出的线程任务会在队列中等待）,通常应用于控制线程最大并发数场景中。  // 1. 创建定长线程池对象 &amp; 设置线程池线程数量固定为3 ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);  // 2. 创建好Runnable类线程对象 &amp; 需执行的任务 Runnable task =new Runnable(){   public void run(){     System.out.println(\"执行任务啦\");      }   };          // 3. 向线程池提交任务：execute（） fixedThreadPool.execute(task);          // 4. 关闭线程池 fixedThreadPool.shutdown();   定时线程池（ScheduledThreadPool ）  核心线程数量固定、非核心线程数量无限制（闲置时马上回收），通常应用于执行定时 / 周期性 任务场景中。  // 1. 创建 定时线程池对象 &amp; 设置线程池线程数量固定为5 ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);  // 2. 创建好Runnable类线程对象 &amp; 需执行的任务 Runnable task =new Runnable(){        public void run(){               System.out.println(\"执行任务啦\");        } }; // 3. 向线程池提交任务：schedule（） scheduledThreadPool.schedule(task, 1, TimeUnit.SECONDS); // 延迟1s后执行任务 scheduledThreadPool.scheduleAtFixedRate(task,10,1000,TimeUnit.MILLISECONDS);// 延迟10ms后、每隔1000ms执行任务  // 4. 关闭线程池 scheduledThreadPool.shutdown();   可缓存线程池（CachedThreadPool）  只有非核心线程、线程数量不固定（可无限大）、灵活回收空闲线程（具备超时机制，全部回收时几乎不占系统资源）、新建线程（无线程可用时），通常在执行大量、耗时少的任务时使用。  // 1. 创建可缓存线程池对象 ExecutorService cachedThreadPool = Executors.newCachedThreadPool();  // 2. 创建好Runnable类线程对象 &amp; 需执行的任务 Runnable task =new Runnable(){   public void run(){         System.out.println(\"执行任务啦\");   } };  // 3. 向线程池提交任务：execute（） cachedThreadPool.execute(task);  // 4. 关闭线程池 cachedThreadPool.shutdown();  //当执行第二个任务时第一个任务已经完成 //那么会复用执行第一个任务的线程，而不用每次新建线程。   单线程化线程池（SingleThreadExecutor）  只有一个核心线程（保证所有任务按照指定顺序在一个线程中执行，不需要处理线程同步的问题）,它常应用于不适合并发但可能引起IO阻塞性及影响UI线程响应的操作，如数据库操作，文件操作等。  // 1. 创建单线程化线程池 ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();  // 2. 创建好Runnable类线程对象 &amp; 需执行的任务 Runnable task =new Runnable(){   public void run(){         System.out.println(\"执行任务啦\");             }     };  // 3. 向线程池提交任务：execute（） singleThreadExecutor.execute(task);  // 4. 关闭线程池 singleThreadExecutor.shutdown();"
  },
  
  {
    "title": "西安GDG上关于主题[当Android遇上RxJava]的分享总结",
    "url": "/posts/xian-gdg-share/",
    "categories": "Android",
    "tags": "RxJava",
    "date": "2016-01-10 00:00:00 +0800",
    "content": "前言 1月10号这一天，也是值得高兴的日子，一大早起来打开手机看到《RxJava Essentials》一书的作者Ivan.Morgillo给我在推特上发的消息点赞并转发后关注了我，这让我激动不已，可能对于我这种没见过大世面的人来说，这点小事或许就足以让我自己心里乐上三天。然后就是昨天下午在西安GDG做了关于RxJava的分享，下面是分享内容的总结。  ##分享内容总结  大致分为以下三个主题线：     1.介绍了ReactiveX、RxJava   2.Android开发中遇到的常见场景   3.关于RxJava与Android的学习   ReactiveX的介绍  我把它总结为以下三点：     1.扩展的观察者模式：通过订阅可观测对象的序列流然后做出反应。   2.迭代器模式：对对象序列进行迭代输出从而使订阅者可以依次对其处理。   3.函数式编程思想：简化问题的解决的步骤，让你的代码更优雅和简洁   然后介绍了ReactiveX在各个语言和平台上的实现,官方地址 最后对上面三点展开进行详细介绍：     1.先介绍GoF书中的观察者模式，被观察者发出事件，然后观察者（事件源）订阅然后进行处理。并指出其中的不足：比如观察者不知道是否出错与完成，还有就是整个过程是同步，会阻塞线程，从而引出所谓的“扩展”的观察者模式，除了提到的不足作为补充外，另外还有一点：如果没有观察者，被观察者是不会发出任何事件的。   2.迭代器模式：提供一种方法顺序访问一个聚合对象中的各种元素,而又不暴露该对象的内部表示，用《RxJava Essentials》一书做的的对比：迭代器模式在事件处理上采用的是“同步/拉式”的方式，而被观察者采用的是“异步/推式”的方式，而对观察者而言，显然后者更灵活。   3.对于函数式编程举例展示了代码风格的不同。   RxJava的介绍  我也按照三点作为介绍     1.RxJava的核心   2.RxJava操作符   3.RxJava的扩展   然后对这三点展开来讲，其中最花时间的也是这一部分。 RxJava的核心对象  先是通过一个Hello World的例子介绍了几个容易混淆的类/接口：     Observable   OnSubscribe   Observer   Subscription   Subscriber   代码展示如下： Observable&lt;String&gt; myObservable = Observable         .create(new Observable.OnSubscribe&lt;String&gt;() {             @Override             public void call(Subscriber&lt;? super String&gt; subscriber) {                 subscriber.onNext(\"Hello World!\");                 subscriber.onCompleted();             }         });  Subscriber&lt;String&gt; mySubscriber = new Subscriber&lt;String&gt;() {     @Override     public void onCompleted() {}      @Override     public void onError(Throwable e) {}      @Override     public void onNext(String s) {         Log.i(\"基础写法：\", s);     } };  myObservable.subscribe(mySubscriber);    简化一下： Observable&lt;String&gt; myObservable = Observable.just(\"Hello World!\");  Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() {      @Override     public void call(String s) {         Log.v(\"Action1简化后:\", s);     } };  myObservable.subscribe(onNextAction);   匿名函数写法： Observable.just(\"Hello World!\").subscribe(new Action1&lt;String&gt;() {             @Override             public void call(String s) {                 Log.v(\"匿名函数写法：\",s);             }         });   最后用Java 8 lambdas(Retrolambda)表达式： Observable.just(\"Hello World!\").subscribe(s -&gt; Log.v(\"lambdas写法\",s));   其中这一部分从源码角度简单概括了从被观察者创建，到观察者创建，最后再订阅的过程，并顺便指出了上面几个易混淆的类/接口之间的关系。  第二部分是关于异步的话题：  先是介绍这几种调度器：     1.Schedulers.immediate()   2.Schedulers.newThread()   3.Schedulers.trampoline()   4.Schedulers.io()   5.Schedulers.computation()   6.AndroidSchedulers.mainThread()   然后就是两个操作符：    subscribeOn()：指定 subscribe() 所发生的线程，事件产生的线程   observeOn()：指定 Subscriber 所运行在的线程，事件消费的线程   RxJava操作符  在讲操作符之前，先是介绍了直观有趣的宝石图：这里引用了一张官方的图片,另外再附上一个国外程序员创建的动态的宝石图网站，虽然不全，但是作者一直在更新，相信后面会有更多，这有助于我们来理解操作符。  大致分为这几类展开介绍：    创建操作符：Create, Defer, From, Interval, Just, Range, Repeat, Timer等。   变换操作符：Map、FlatMap、ConcatMap等。   过滤操作符：Debounce, Distinct, ElementAt, Filter, First, Last, Sample, Skip, SkipLast, Take, TakeLast等。   合买操作符以及自定义操作符。   最后用一个例子做了下总结，需求如下：     将一个为数字的字符串数组元素转换为数字   过滤掉大于10的数字   去重   取最后面3个元素   累计求和   用代码实现就是： String[] numbers = {\"11\", \"2\", \"2\", \"13\", \"4\", \"5\",\"7\"}; Observable.from(numbers)         .map(s -&gt; Integer.parseInt(s))         .filter(i -&gt; i &lt; 10)         .distinct()         .takeLast(3)         .reduce((number1,number2) -&gt; number1 + number2)         .subscribe(i -&gt; System.out.println(i));   其中创建操作符例子如下： String[] strings = {\"张三\",\"李四\",\"王五\",\"赵六\"}; Observable.from(strings)         .subscribe(new Action1&lt;String&gt;() {             @Override             public void call(String s) {                 Log.i(\"name\", s);             }         });   变换操作符例子： public void showUserName(String userName){     textView.setText(userName); }   public void showUserName(String userName){     Observable.just(userName).subscribe( new  Action1&lt;String&gt;(){              @Override              public void call(String s){                 textView.setText(s);             }     }); }   如果需要在显示前对这个字符串做处理，然后再展示，比如加“张三，你好”     方法1：我们可以对字符串本身操作   (不合适)   方法2：我们可以放到Action1.call()方法里做处理   （不合适）   方法3：使用操作符做变换：map    （RxJava的做法）   public void showUserName(String userName){     Observable.just(userName).map(new Func1&lt;String,String&gt;(){           public String call(String text){              return handleUserName(text);            }     }).subscribe( new Action1&lt;String&gt;(){         public void call(String s){             textView.setText(s);           }     }); }   关于flatMap() //打印出中国的所有省份名称。 List&lt;Province&gt;  provinceList = … Observable.from(provinceList)     .map(new Func1&lt;Province,String&gt;(){         @Override         public String call(Province province){             return province.getName();         }     }).subscribe(new Action1&lt;String&gt;(){          @Override          public void call(String s){             Log.i(“省份名称”,s)          }     });   //打印出中国每个省份的所有城市  (不合适) List&lt;Province&gt;  provinceList = … Observable.from(provinceList)     .subscribe(new Action1&lt;Province&gt;(){         @Override         public void call(Province province){             List&lt;City&gt; cities = province.getCities();             for (int i = 0; i &lt; cities.size(); i++) {                    City city = cities.get(i);                    Log.i(“城市”, city.getName());             }         }     });   //RxJava做法 List&lt;Province&gt;  provinceList = … Observable.from(provinceList)     .flatMap(new Func1&lt;Province,Observable&lt;City&gt;&gt;(){         @Override         public Observable&lt;City&gt; call(Province province){                  return Observable.from(province.getCities());         }     })     .subscribe(new Action1&lt;City&gt;(){             @Override             public void call(City city){                Log.i(“城市”, city.getName());             }     });   关于flatMap的应用扩展 //介绍回调地狱 restAdapter.getApiService().getToken(new Callback&lt;String&gt;(){     @Override     public void success(String token) {         restAdapter.getApiService().getUserInfo(token,new Callback&lt;UserInfo&gt;(){             @Override             public void success(UserInfo userInfo) {                      showMessage(userInfo.getUser);             }              @Override             public void failure(RetrofitError error) {                 //处理错误                 ...             }         });     }      @Override     public void failure(RetrofitError error) {         // Error handling         ...     } });   如何用RxJava来解决： restAdapter.getApiService()     .getToken()     .flatMap(new Func1&lt;String,Observable&lt;UserInfo&gt;&gt;(){             @Override             public Observable&lt;UserInfo&gt; call(String token){                      return restAdapter.getApiService().getUserInfo(token);             }     })     .subscribe(new Action1&lt;UserInfo&gt;(){             @Override             public void call(UserInfo userInfo){                      showMessage(userInfo.getUser);             }     })   加入线程切换  restAdapter.getApiService().getToken()     .flatMap(new Func1&lt;String,Observable&lt;UserInfo&gt;&gt;(){             @Override             public Observable&lt;UserInfo&gt; call(String token){                      return restAdapter.getApiService().getUserInfo(token);             }     })     .subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程     .observeOn(AndroidSchedulers.mainThread())// 指定 Subscriber 的回调发生在主线程     .subscribe(new Action1&lt;UserInfo&gt;(){             @Override             public void call(UserInfo userInfo){                      showMessage(userInfo.getUser);             }     })   #####操作符复用：  先介绍不合适的做法：  &lt;T&gt; Observable&lt;T&gt; applySchedulers(Observable&lt;T&gt; observable) {     return observable.subscribeOn(Schedulers.io())      .observeOn(AndroidSchedulers.mainThread()); }   应用后，破坏了链式调用 applySchedulers(restAdapter.getApiService().getToken()     .flatMap(new Func1&lt;String,Observable&lt;UserInfo&gt;&gt;(){             @Override             public Observable&lt;UserInfo&gt; call(String token){                      return restAdapter.getApiService().getUserInfo(token);             }     })     ).subscribe(new Action1&lt;UserInfo&gt;(){             @Override             public void call(UserInfo userInfo){                      showMessage(userInfo.getUser);             }     })   我们加入转换器与Compose() Transformer：继承Func1&lt;Observable, Observable&gt;的一个接口，其实是将一个Observable转换为另一个Observable &lt;T&gt; Transformer&lt;T, T&gt; applySchedulers() {      return new Transformer&lt;T, T&gt;() {        @Override        public Observable&lt;T&gt; call(Observable&lt;T&gt; observable) {          return observable.subscribeOn(Schedulers.io())              .observeOn(AndroidSchedulers.mainThread());        }      }; }   用compose操作符做法：  restAdapter.getApiService().getToken()     .flatMap(new Func1&lt;String,Observable&lt;UserInfo&gt;&gt;(){             @Override             public Observable&lt;UserInfo&gt; call(String token){                      return restAdapter.getApiService().getUserInfo(token);             }     })     .compose(applySchedulers())     .subscribe(new Action1&lt;UserInfo&gt;(){             @Override             public void call(UserInfo userInfo){                      showMessage(userInfo.getUser);             }     })   RxJava的扩展 主要是针对以下几个开源库展开来说：    1.Rxbinding：用RxJava实现onClick,TextWatcher,check等事件绑定。   2.RxBus：用RxJava实现EventBus或者Otto。   3.RxPreferences：用RxJava实现Android中的SharedPreferences。   4.RxLifecycle：用来严格控制由于发布了一个订阅后，由于没有及时取消，导致Activity/Fragment无法销毁导致的内存泄露。   5.ReactiveNetwork：使用RxJava来监听网络连接状态和wifi信号强度变化。   6.RxPermissions：针对 Android 6.0 权限管理进行一个 Rx 封装的一个类库。   7.rxloader：用RxJava对loader的一个封装。   还有更多…   Android应用场景     1.避免嵌套回调地狱问题。   2.使用debounce减少频繁的网络请求。避免每输入（删除）一个字就做一次联想。   3.使用combineLatest合并最近N个结点,注册的时候所有输入信息（邮箱、密码、电话号码等）合法才点亮注册按钮。   4.使用merge合并两个数据源,最后做统一处理。   5.使用concat和first做缓存，依次检查memory、disk和network中是否存在数据，任何一步一旦发现数据后面的操作都不执行。   6.使用timer做定时操作。   7.使用interval做周期性操作。   8.使用throttleFirst防止按钮重复点击   9.做响应式的界面。   更多…   部分例子代码： RxTextView.textChanges(searchEditText)      .debounce(150, MILLISECONDS)      .switchMap(Api::searchItems)      .subscribe(this::updateList, t-&gt;showError());   Observable.merge(getNews(), getHotNews(),     new Func2&lt;Response&lt;News&gt;, MyResponse&lt;News&gt;, Boolean&gt;() {         @Override         public Boolean call(Response&lt;News&gt; response, Response&lt;News&gt; response2) {             mData.clear();             mData.addAll(response);             mData.addAll(response2.msg);             return true;         }     })     .subscribeOn(Schedulers.io())     .observeOn(AndroidSchedulers.mainThread())     .subscribe(new Subscriber&lt;Boolean&gt;() {         @Override         public void onCompleted() {}         @Override         public void onError(Throwable e) {}         @Override         public void onNext(Boolean o) {                mAdapter.notifyDataSetChanged();         }     });   RxView.clicks(button)       .throttleFirst(1, TimeUnit.SECONDS)       .subscribe(new Observer&lt;Object&gt;() {           @Override           public void onCompleted() {                 log.d (\"completed\");           }            @Override           public void onError(Throwable e) {                 log.e(\"error\");           }            @Override           public void onNext(Object o) {                log.d(\"button clicked\");           }       });   SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(this); RxSharedPreferences rxPreferences = RxSharedPreferences.create(preferences);  Preference&lt;Boolean&gt; checked = rxPreferences.getBoolean(\"checked\", true);  CheckBox checkBox = (CheckBox) findViewById(R.id.cb_test); RxCompoundButton.checkedChanges(checkBox)         .subscribe(checked.asAction());   Observable&lt;String&gt; memory = Observable     .create(new Observable.OnSubscribe&lt;String&gt;() {         @Override         public void call(Subscriber&lt;? super String&gt; subscriber) {             if (memoryCache != null) {                 subscriber.onNext(memoryCache);             } else {                 subscriber.onCompleted();             }         }     });  Observable&lt;String&gt; disk = Observable     .create(new Observable.OnSubscribe&lt;String&gt;() {         @Override         public void call(Subscriber&lt;? super String&gt; subscriber) {             String cachePref = rxPreferences.getString(\"cache\").get();             if (!TextUtils.isEmpty(cachePref)) {                 subscriber.onNext(cachePref);             } else {                 subscriber.onCompleted();             }         }     });  Observable&lt;String&gt; network = Observable.just(\"network\");  //依次检查memory、disk、network Observable.concat(memory, disk, network)     .first()     .subscribeOn(Schedulers.newThread())     .subscribe(s -&gt; {         memoryCache = \"memory\";         System.out.println(\"subscribe: \" + s);     });   感谢/参考  感谢Jake大神的启蒙，感谢Ivan.Morgillo的书《RxJava Essentials》,感谢扔物线的文章和大头鬼的翻译文章，同时也是一路看他们的文章走过来的，最后感谢所有分享RxJava的小伙伴们。     http://gank.io/post/560e15be2dca930e00da1083   http://blog.csdn.net/lzyzsd/article/details/41833541   http://blog.csdn.net/theone10211024/article/details/50435325   《RxJava Essentials》   http://reactivex.io   关于RxJava和Android的学习  主要从渠道，知识点和资源几方面介绍了下学习，提到MobDevGroup这个资源站。  GDG总结  由于时间上的问题，没有对一些原理进行讲解，尤其是变换等，大部分是在讲应用，总之呢除了对自己知识点一次不错的总结外，也是对自己的一次历练，接下来再接再厉。最后附上这次的PPT下载地址：     Mac keynote   Windows PowerPoint"
  },
  
  {
    "title": "RxJava Essentials翻译总结",
    "url": "/posts/rxjava-essentials/",
    "categories": "Android",
    "tags": "RxJava",
    "date": "2016-01-08 00:00:00 +0800",
    "content": "##前言 在前年的时候，一直忙于工作，偶尔关注下开源社区，平时在使用retrofit的库时一直采用传统的回调，当时看官网发现也可以Observable对象，很好奇，但是一直不知道这是什么？慢慢的，关注Jake大神，才知道是RxJava，当时并没有引起我对RxJava 的好奇，也就没有太在意，但是我的心里一直有个梗就是在使用回调时如何让嵌套回调的代码看起来不是那么槽糕，用今天的话说就是回调地狱，直到去年，国内一些积极推动RxJava的大神们才真正让我认识了它，可能最让我印象深刻的一点就是它解决了我这么多年的那个梗，从大头鬼的深入浅出系列到扔物线的给Android开发者的RxJava详解，我决定想系统的学一下它，一直想找本中文书，可是没找到，直到有一天发现国外的这本《RxJava Essentials》，看了一下之后，欣喜之余，决定把它翻译出来，算是巩固学习。  ##书内容介绍 全书分了八章，前两章介绍Rx，并引出Rx在Android中的引用，三四五六章着重讲RxJava的操作符，从创建、过滤一直讲到变换、组合，最后一张结合Android开源库Retrofit来一起使用，总之对于Android开发者来讲是本不错的基础书。  1.RX-from .NET to RxJava     本章带你进入reactive的世界。我们会比较reactive 方法和传统方法，进而探索它们之间的相似和不同的地方。   2.Why Observables?     本章会对观察者模式做一个概述，如何实现它以及怎样用RxJava来进行扩展，被观察者是什么，以及被观察者如何与迭代联系到一起的。   3.Hello Reactive World     本章会利用我们所学的知识来创建第一个reactive Android应用。   4.Filtering Observables     本章我们会研究Observable序列的本质:filtering.我们也将学到如何从一个发出的Observable中选取我们想要的值，如何获得一个有限的数值，如何处理溢出的场景，以及更多有用的技巧。   5.Transforming Observables     本章将讲述如何通过变换Observable序列来创建出我们所需要的序列。   6.Combining Observables     本章将研究与函数结合，同时也会学到当创建我们想要的Observable时又如何与多个Observable协同工作。   7.Schedulers-Defeating the Android MainThread Issue     本章将介绍如何使用RxJava Schedulers 来处理多线程和并发编程。我们也将用reactive的方式来创建网络操作、内存访问、耗时处理。   8.REST in peace-RxJava and Retrofit     本章教会你如何让Square公司的Retrofit和RxJava结合来一起使用，来创建一个更高效的REST客户端程序。   后续 Rx给了我们一种新的学习扩展和并发的方式，它和面向对象一样是一种新的思想，熟练的使用它可以很容易的帮助我们处理日常繁杂的业务逻辑，同时又不会搞乱你的代码，建议开发者都可以学习下，另外这里也推荐另外一本《Learning Reactive Programming》，是它的姊妹篇，介绍响应式编程，同样推荐看看。  【RxJava Essentials】   【Learning Reactive Programming】  《RxJava Essentials》翻译中文版电子书下载地址  《RxJava Essentials》英文版下载地址  《Learning Reactive Programming》英文版下载地址"
  },
  
  {
    "title": "Android磁盘缓存",
    "url": "/posts/disk-lru-cache/",
    "categories": "Android",
    "tags": "cache",
    "date": "2015-11-24 00:00:00 +0800",
    "content": "1.概述 在上一篇文章中简单介绍了内存缓存，其核心就是LruCache这个类，我们知道它的优点就是直接可以读取内存，当然速度就会很快，但是它同时也有下面不足的地方：    手机内存空间十分有限，所以我们不能随意的设置内存缓存大小。   内存紧张时可能会优先被GC回收掉。   退出应用时就回收掉，不能离线存储数据   基于以上原因，于是就有了磁盘缓存，Android开源届Jake大神为我们提供了一种解决方案:DiskLruCache,也是现在应用的最广泛的一种，并且已经获得谷歌官方认可。  2.使用 打开缓存 通过源码我们可以看到DiskLruCache的构造方法时私有的，所以不能通过new的方法来获取到它的实例，但是作者给我们提供了一种方式来创建实例，通过调用open方法，其中的四个参数刚好与构造函数中的四个参数相吻合:    directory指定缓存的目录   appVersion指定应用程序的版本号   valueCount指定一个key可以对应多少个缓存文件，一般情况下我们都指定这个参数为1   maxSize指定我们最多可以缓存多大的字节数       private DiskLruCache(File directory, int appVersion, int valueCount, long maxSize) {  this.directory = directory;  this.appVersion = appVersion;  this.journalFile = new File(directory, JOURNAL_FILE);  this.journalFileTmp = new File(directory, JOURNAL_FILE_TEMP);  this.journalFileBackup = new File(directory, JOURNAL_FILE_BACKUP);  this.valueCount = valueCount;  this.maxSize = maxSize;   }   /** * Opens the cache in {@code directory}, creating a cache if none exists * there. * * @param directory a writable directory * @param valueCount the number of values per cache entry. Must be positive. * @param maxSize the maximum number of bytes this cache should use to store * @throws IOException if reading or writing the cache directory fails */   public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize)    throws IOException {  if (maxSize &lt;= 0) {    throw new IllegalArgumentException(\"maxSize &lt;= 0\");  }  if (valueCount &lt;= 0) {    throw new IllegalArgumentException(\"valueCount &lt;= 0\");  }   // If a bkp file exists, use it instead.  File backupFile = new File(directory, JOURNAL_FILE_BACKUP);  if (backupFile.exists()) {    File journalFile = new File(directory, JOURNAL_FILE);    // If journal file also exists just delete backup file.    if (journalFile.exists()) {      backupFile.delete();    } else {      renameTo(backupFile, journalFile, false);    }  }   // Prefer to pick up where we left off.  DiskLruCache cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);  if (cache.journalFile.exists()) {    try {      cache.readJournal();      cache.processJournal();      cache.journalWriter = new BufferedWriter(          new OutputStreamWriter(new FileOutputStream(cache.journalFile, true), Util.US_ASCII));      return cache;    } catch (IOException journalIsCorrupt) {      System.out          .println(\"DiskLruCache \"              + directory              + \" is corrupt: \"              + journalIsCorrupt.getMessage()              + \", removing\");      cache.delete();    }  }   // Create a new empty cache.  directory.mkdirs();  cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);  cache.rebuildJournal();  return cache;   }          然后缓存路径为：/sdcard/Android/data//cache 这个路径下面，但这里我们通常的做法就是判断是否有SD卡，没有的话就放在内部存储里面，缓存路径为：/data/data//cache     public File getDiskCacheDir(Context context, String uniqueName) {    String cachePath;    if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())            || !Environment.isExternalStorageRemovable()) {        cachePath = context.getExternalCacheDir().getPath();    } else {        cachePath = context.getCacheDir().getPath();    }    return new File(cachePath + File.separator + uniqueName);   }            这里的uniqueName值作为我们区分不同的数据的一个唯一值，如存放图片的缓存文件夹（images），存放视频的缓存文件夹(videos)，存放文本文件的缓存文件夹（txt）。 第二个参数获取版本号就很简单了     public int getAppVersion(Context context) {    try {        PackageInfo info = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);        return info.versionCode;    } catch (NameNotFoundException e) {        e.printStackTrace();    }    return 1;   }            第三个参数上面提到了为1，第四个参数假定我们设为10M，那么就有了：     DiskLruCache mDiskLruCache = null;   try {    File cacheDir = getDiskCacheDir(context, \"images\");    if (!cacheDir.exists()) {        cacheDir.mkdirs();    }    mDiskLruCache = DiskLruCache.open(cacheDir, getAppVersion(context), 1, 10 * 1024 * 1024);   } catch (IOException e) {    e.printStackTrace();   }             存缓存到磁盘 这点类似SharePreferences,DiskLruCache给我们提供了一个内部类Editor，它用来完成针对缓存文件的读取、储存、删除、修改等等操作：通过调用实例的edit方法传入key值来把文件缓存到磁盘，然后针对函数返回的Editor实例调用commit方法完成最后的提交。 mDiskLruCache.edit(key).commit();   mDiskLruCache.flush();    这里的key值我们一般使用MD5加密后的字符串来做唯一处理，当然也可以调用abort来放弃提交。  读取缓存文件 读取缓存文件通过get(key)方法来进行： InputStream is = mDiskLruCache.get(key).getInputStream(0); //TODO 然后再对流做进一步的处理   移除缓存 移除缓存调用remove(key)方法： mDiskLruCache.remove(key);   获取缓存大小 通过size()方法返回当前缓存路径下面所有缓存数据的字节数，以byte为单位。  关闭缓存 调用close()方法，通常在界面销毁的时候调用  删除缓存 调用delete()方法,即可清除缓存"
  },
  
  {
    "title": "Android内存缓存",
    "url": "/posts/lru-cache/",
    "categories": "Android",
    "tags": "cache",
    "date": "2015-11-23 00:00:00 +0800",
    "content": "1.概述 通常情况下，我们为了实现更好的用户体验从而引入了缓存的概念，这在Android应用于图片列表加载上显得更为重要。我们为了让内存维护在一个合理的范围，通常会把移除屏幕的图片进行回收处理，让GC去操作这些不在持有图片的引用，为了App有更流畅的体验，比如在界面上更加流畅的加载图片，而不得不考虑的一个问题就是图片回收之后，这时候用户又将刚刚回收的图片重新滑入屏幕内，这时候又回去加载一遍刚刚回收的图片，这无疑给性能带来了诸多问题，因此我们引入内存缓存。  2.原理 内存缓存对于那些大量占用程序宝贵内存资源的图片来说很好用，它提供了快速访问内存的方法，在过去，我们经常通过软引用或者弱引用(SoftReference or WeakReference)的方式，但是现在已经不推荐使用，自从Android 2.3（API Level 9）开始，JVM做了调整，使得垃圾回收器更容易倾向于回收持有软引用或者是弱引用的对象，折让弱引用或者软引用就变得不可靠，另外，Android3.0（API Level 11）中，图片的数据会存储在本地的内存中，也没有一个可预见的方式来释放它，这就给应用程序的崩溃或内存溢出埋下了隐患。因此在谷歌官方给我们在v4包中提供了LruCache类，它主要算法原理是将对象用强引用存储在LinkedHashMap中，并且把最近最少使用的对象在缓存值达到预设值之前从内存中移除，来释放它。     /**      * @param maxSize for caches that do not override {@link #sizeOf}, this is      *     the maximum number of entries in the cache. For all other caches,      *     this is the maximum sum of the sizes of the entries in this cache.      */     public LruCache(int maxSize) {         if (maxSize &lt;= 0) {             throw new IllegalArgumentException(\"maxSize &lt;= 0\");         }         this.maxSize = maxSize;         this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);     }   关于LinkedHashMap的介绍 LinkedHashMap是HashMap的子类，它保留了插入的顺序，并维护者运行所有元素的一个双重链表，默认是按插入顺序排序(即构造函数最后一个参数false)，如果指定按访问顺序排序（最近最少使用，构造函数最后一个为true），那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。  3.使用    初始化      // 获取到可用内存的最大值，使用内存超出这个值会引起OutOfMemory异常。   // LruCache通过构造函数传入缓存值，以KB为单位。   int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);   // 使用最大可用内存值的1/8作为缓存的大小。   int cacheSize = maxMemory / 8;   mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) {       @Override      protected int sizeOf(String key, Bitmap bitmap) {           // 重写此方法来衡量每张图片的大小，默认返回图片数量。           return bitmap.getByteCount() / 1024;       }   };             提供访问方法 ``` public void addBitmapToMemoryCache(String key, Bitmap bitmap) {   if (getBitmapFromMemCache(key) == null) {       mMemoryCache.put(key, bitmap);   }  }   public Bitmap getBitmapFromMemCache(String key) {      return mMemoryCache.get(key);  }  上面使用了系统分配给应用程序的八分之一作为缓存大小，在一些手机上大概是4M的内存空间，通常我们在加载图片的时候会先去缓存中取，如果取不到，则会开启一个后台线程去加载图片  public void loadBitmap(String url ,ImageView iv){     String key = md5(url);     Bitmap bitmap = getBitmapFromMemCache(key);     if(bitmap != null){         iv.setImageBitmap(bitmap);     }else{         //TODO 开启线程去下载     } }  //在下载完图片后还需要保存在缓存中 class ImageDownLoaderTask extends AsyncTask&lt;Integer,Void,Bitmap&gt;{     @Override     protected Bitmap doInBackground(Integer… params) {          //取到Bitmap         …         …         addBitmapToMemoryCache(String.valueOf(params[0]), bitmap);          return bitmap;      }  }  ### 4.源码解析 1. 成员变量  private final LinkedHashMap&lt;K, V&gt; map;      /** Size of this cache in units. Not necessarily the number of elements. */   private int size; //已经存储的大小 private int maxSize; //规定的最大存储空间  private int putCount;  //put的次数 private int createCount;  //create的次数 private int evictionCount;  //回收的次数 private int hitCount;  //命中的次数 private int missCount;  //丢失的次数  /**  * For caches that do not override {@link #sizeOf}, this returns the number  * of entries in the cache. For all other caches, this returns the sum of  * the sizes of the entries in this cache.  */ public synchronized final int size() {     return size; }  /**  * For caches that do not override {@link #sizeOf}, this returns the maximum  * number of entries in the cache. For all other caches, this returns the  * maximum sum of the sizes of the entries in this cache.  */ public synchronized final int maxSize() {     return maxSize; }  /**  * Returns the number of times {@link #get} returned a value that was  * already present in the cache.  */ public synchronized final int hitCount() {     return hitCount; }  /**  * Returns the number of times {@link #get} returned null or required a new  * value to be created.  */ public synchronized final int missCount() {     return missCount; }  /**  * Returns the number of times {@link #create(Object)} returned a value.  */ public synchronized final int createCount() {     return createCount; }  /**  * Returns the number of times {@link #put} was called.  */ public synchronized final int putCount() {     return putCount; }  /**  * Returns the number of values that have been evicted.  */ public synchronized final int evictionCount() {     return evictionCount; } ```      取缓存 ```  /**            Returns the value for {@code key} if it exists in the cache or can be       created by {@code #create}. If a value was returned, it is moved to the       head of the queue. This returns null if a value is not cached and cannot       be created.       通过key来取对应的元素，或者返回新创建的元素，相应的这个元素会移动到队列的头部，如果这个元                素没有被缓存，也不能创建，则会返回null   */  public final V get(K key) {  if (key == null) {      throw new NullPointerException(“key == null”);  }          V mapValue;  synchronized (this) {      mapValue = map.get(key);      if (mapValue != null) {          hitCount++; //命中  找到了          return mapValue;      }      missCount++;  //丢失，没有命中  }          /*                    Attempt to create a value. This may take a long time, and the map           may be different when create() returns. If a conflicting value was           added to the map while create() was working, we leave that value in           the map and release the created value.   */                   V createdValue = create(key);  if (createdValue == null) {      return null;  }          synchronized (this) {      createCount++;      mapValue = map.put(key, createdValue);           if (mapValue != null) {      // There was a conflict so undo that last put      map.put(key, mapValue);// 如果前面存在oldValue,那么就撤销最后一次的put  } else {      size += safeSizeOf(key, createdValue);  }  }                   if (mapValue != null) {      entryRemoved(false, key, createdValue, mapValue);      return mapValue;  } else {      trimToSize(maxSize);      return createdValue;  }  } ```                  存缓存 ```  /**            Caches {@code value} for {@code key}. The value is moved to the head of       the queue.   *                @return the previous value mapped by {@code key}.   */  public final V put(K key, V value) {  if (key == null || value == null) {      throw new NullPointerException(“key == null || value == null”);  }          V previous;  synchronized (this) {      putCount++;      size += safeSizeOf(key, value);      previous = map.put(key, value);//返回的先前的value值      if (previous != null) {           size -= safeSizeOf(key, previous);      }  }          if (previous != null) {      entryRemoved(false, key, previous, value);  }          trimToSize(maxSize);  return previous;  } ```                  清掉占用的内存空间 ```  /**            Remove the eldest entries until the total of remaining entries is at or       below the requested size.   *       @param maxSize the maximum size of the cache before returning. May be -1       to evict even 0-sized elements.   */  public void trimToSize(int maxSize) {      while (true) {          K key;          V value;          synchronized (this) {              if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) {   throw new IllegalStateException(getClass().getName()           + “.sizeOf() is reporting inconsistent results!”);              }                    if (size &lt;= maxSize || map.isEmpty()) {              break;          }           Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();          key = toEvict.getKey();          value = toEvict.getValue();          map.remove(key);          size -= safeSizeOf(key, value);          evictionCount++;      }       entryRemoved(true, key, value, null);  }  }           /**            Removes the entry for {@code key} if it exists.       删除key相应的cache项，返回相应的value                @return the previous value mapped by {@code key}.   */  public final V remove(K key) {  if (key == null) {      throw new NullPointerException(“key == null”);  }          V previous;  synchronized (this) {      previous = map.remove(key);      if (previous != null) {          size -= safeSizeOf(key, previous);      }  }          if (previous != null) {      entryRemoved(false, key, previous, null);  }          return previous;  }                  /**            Called for entries that have been evicted or removed. This method is       invoked when a value is evicted to make space, removed by a call to       {@link #remove}, or replaced by a call to {@link #put}. The default       implementation does nothing.   *                The method is called without synchronization: other threads may               access the cache while this method is executing.   *       @param evicted true if the entry is being removed to make space, false       if the removal was caused by a {@link #put} or {@link #remove}.       @param newValue the new value for {@code key}, if it exists. If non-null,       this removal was caused by a {@link #put}. Otherwise it was caused by       an eviction or a {@link #remove}.   */  protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {}           /**            Called after a cache miss to compute a value for the corresponding key.       Returns the computed value or null if no value can be computed. The       default implementation returns null.   *                The method is called without synchronization: other threads may               access the cache while this method is executing.   *                If a value for {@code key} exists in the cache when this method               returns, the created value will be released with {@link #entryRemoved}       and discarded. This can occur when multiple threads request the same key       at the same time (causing multiple values to be created), or when one       thread calls {@link #put} while another is creating a value for the same       key.   */  protected V create(K key) {  return null;  }           private int safeSizeOf(K key, V value) {      int result = sizeOf(key, value);      if (result &lt; 0) {          throw new IllegalStateException(“Negative size: “ + key + “=” + value);      }      return result;  }      /**            Returns the size of the entry for {@code key} and {@code value} in       user-defined units.  The default implementation returns 1 so that size       is the number of entries and max size is the maximum number of entries.       默认返回元素的个数，一般我们来重写，比如上面我们让他返回占用的最小内存单元                An entry's size must not change while it is in the cache.   */  protected int sizeOf(K key, V value) {  return 1;  }                   /**            Clear the cache, calling {@link #entryRemoved} on each removed entry.       清空cache   */  public final void evictAll() {  trimToSize(-1); // -1 will evict 0-sized elements  } ```"
  },
  
  {
    "title": "Andriod源码之IntentService用法与原理",
    "url": "/posts/android-intentservice/",
    "categories": "Android",
    "tags": "源码分析",
    "date": "2015-07-28 00:00:00 +0800",
    "content": "IntentService从名字来看就知道是一个Service，它是Service的子类，由于在Service里不能执行耗时操作，所以Google设计了一个IntentService，它在IntentService内部维护了一个工作线程来处理耗时操作，其实也就是HandlerThread，当任务执行完成后，IntentService会自动停止。先来看下如何使用：  public class MyService extends IntentService {     /**      * Creates an IntentService.  Invoked by your subclass's constructor.      *      * @param name Used to name the worker thread, important only for debugging.      */     public MyService(String name) {         super(name);     }      @Override     protected void onHandleIntent(@Nullable Intent intent) {          String action = intent.getStringExtra(\"action\");          try {             Thread.sleep(2000);         } catch (InterruptedException e) {             e.printStackTrace();         }     } } // 记得在AndroidManifest.xml注册  Intent intent = new Intent(this,MyService.class); intent.putExtra(\"action\", \"download\"); startService(intent);    源码分析  public abstract class IntentService extends Service {     ...      private final class ServiceHandler extends Handler {         public ServiceHandler(Looper looper) {             super(looper);         }          @Override         public void handleMessage(Message msg) {             onHandleIntent((Intent)msg.obj);             stopSelf(msg.arg1);         }     }      @Override     public void onCreate() {         // TODO: It would be nice to have an option to hold a partial wakelock         // during processing, and to have a static startService(Context, Intent)         // method that would launch the service &amp; hand off a wakelock.          super.onCreate();         HandlerThread thread = new HandlerThread(\"IntentService[\" + mName + \"]\");         thread.start();          mServiceLooper = thread.getLooper();         mServiceHandler = new ServiceHandler(mServiceLooper);     }      @Override     public void onStart(@Nullable Intent intent, int startId) {         Message msg = mServiceHandler.obtainMessage();         msg.arg1 = startId;         msg.obj = intent;         mServiceHandler.sendMessage(msg);     }      @Override     public int onStartCommand(@Nullable Intent intent, int flags, int startId) {         onStart(intent, startId);         return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;     }      @WorkerThread     protected abstract void onHandleIntent(@Nullable Intent intent);      @Override     public void onDestroy() {         mServiceLooper.quit();     }      ... }   如果之前对HandlerThread和Handler机制比较了解，上面源码也比较简单，当我们启动服务时，在onCreate方法里，其实就是HandlerThread的使用，我们在ServiceHandler里处理传过来的消息，并暴露给子类去覆写onHandleIntent来实现，这个方法我们可以执行我们的工作任务或者耗时操作。然后我们在onStart方法中，通过Message将Intent任务请求，发送给mServiceHandler，Intent任务请求就是我们上面的startActivity(intent)传入的intent。mServiceHandler接受任务请求，调用onHandlerIntent方法处理请求任务，处理完所有请求后，调用stopSelf()结束IntentService，因此我们不需要再额外调用停止服务的操作。"
  },
  
  {
    "title": "Android源码之HandlerThread用法与原理",
    "url": "/posts/android-handlerthread/",
    "categories": "Android",
    "tags": "源码分析",
    "date": "2015-07-26 00:00:00 +0800",
    "content": "在android开发中，当我们用Thread和Handler构造一个消息循环的需求时，往往这样做：  Handler mHandler; private void createThreadWithHandler() {   new Thread() {       @Override         public void run() {             super.run();             Looper.prepare();  // 创建一个与当前线程绑定的Looper实例             mHandler = new Handler(Looper.myLooper()); // 创建Handler实例             Looper.loop(); // 生成消息循环         }     }.start(); }   上面几行代码也加了注释，而Google也在这里给我们设计了一个便捷的类，方便我们管理线程的交互。一起来看下它的使用  使用  public class DownloadHandlerThread extends HandlerThread implements Handler.Callback {      private Handler mWorkHandler;     private Handler mUIHandler;      public DownloadHandlerThread(String name) {         super(name);     }      @Override     protected void onLooperPrepared() {         super.onLooperPrepared();         mWorkHandler = new Handler(getLooper(), this);          Message message = mWorkHandler.obtainMessage();         Bundle bundle = new Bundle();         bundle.putString(\"URL\", \"https://XXX\");         message.setData(bundle);         mWorkHandler.sendMessage(message);     }      public void setUIHandler(Handler uiHandler){         this.mUIHandler = uiHandler;     }      @Override     public boolean handleMessage(@NonNull Message msg) {         if(msg == null || msg.getData() == null) {             return false;         }         String url = (String)msg.getData().get(\"URL\");          //省略执行下载任务的逻辑                   //通知主线程更新UI         this.mUIHandler.sendEmptyMessage(1);          return true;     } }  //MainActivity.java DownloadHandlerThread downloadHandlerThread = new DownloadHandlerThread(\"DownloadTask\"); downloadHandlerThread.setUIHandler(this); downloadHandlerThread.start();  上面实现了一个简单的下载任务，子线程Handler发送下载任务的通知,在handleMessage中处理耗时操作，完了之后借助主线程Handler发送通知消息操作UI。  源码分析 @Override public void run() {     mTid = Process.myTid();     Looper.prepare();     synchronized (this) {         mLooper = Looper.myLooper();         notifyAll();     }     Process.setThreadPriority(mPriority);     onLooperPrepared();     Looper.loop();     mTid = -1; }  public Looper getLooper() {     if (!isAlive()) {         return null;     }      boolean wasInterrupted = false;      // If the thread has been started, wait until the looper has been created.     synchronized (this) {         while (isAlive() &amp;&amp; mLooper == null) {             try {                 wait();             } catch (InterruptedException e) {                 wasInterrupted = true;             }         }     }      /*          * We may need to restore the thread's interrupted flag, because it may          * have been cleared above since we eat InterruptedExceptions          */     if (wasInterrupted) {         Thread.currentThread().interrupt();     }      return mLooper; }   在run方法内部调用Looper.prepare方法，创建了一个Looper对象和当前线程绑定，另外在创建Looper的过程中，也同时创建了一个消息队列MessageQueue，然后通过Hander的消息的方式通知HandlerThread执行下一个具体的任务，这里通过Looper.loop方法实现消息循环，同时我们也可以使用quit或者quitSafely方法来结束循环。这里注意下quit方法可能会让正在发送的消息发送失败，所以如果还有延迟的任务没有结束可以考虑使用后者quitSafely方法。  public boolean quit() {     Looper looper = getLooper();     if (looper != null) {         looper.quit();         return true;     }     return false; }  public boolean quitSafely() {     Looper looper = getLooper();     if (looper != null) {         looper.quitSafely();         return true;     }     return false; }   总结     当我们使用HandlerThread构造函数创建一个对象，同时执行它的run方法，这时候在run方法内部，创建了一个Looper对象，并和当前线程绑定，同时也初始化了一个消息队列MessageQueue，并通过调用Looper的loop方法实现消息循环。   根据上一步创建的Looper对象传入我们在主线程创建的Handler，就能将子线程的消息发送到MessageQueue队列，经Looper不断的取出消息交给我们的handler来处理。   最后我们在不用的时候可以通过quit或者quitSafely终止这个循环。   HandlerThread 是一个自带 Looper 的线程，因此只能作为子线程使用。   HandlerThread必须配合Handler使用，通过覆写Handler的callback开实现HanderThread中做的事情   子线程的Handler与HandlerThread建立关系是通过构造子线程Handler时传入HandlerThread的Looper，所以在次之前，必须先调用HandlerThread的run方法，让Looper创建出来。"
  },
  
  {
    "title": "Android源码之AsyncTask用法与原理",
    "url": "/posts/android-asynctask/",
    "categories": "Android",
    "tags": "源码分析",
    "date": "2015-07-20 00:00:00 +0800",
    "content": "在android开发中，主线程不能执行耗时操作，否则程序容易出现ANR，并且崩溃掉，所以我们常常会把主线程耗时操作放在子线程去做，同时把子线程执行的结果通过handler传递到主线程，执行刷新UI操作。否则就会抛出异常：     android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.   上面过程，Android帮我们很好的封装了一个类AsyncTask，它可以很方便的让异步耗时任务放在子线程去执行，并且将执行结果返回给主线程，好让我们执行操作UI的逻辑。  基本用法  我们先来创建一个下载任务看下：  class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; {      @Override     protected void onPreExecute() {         progressDialog.show();     }      @Override     protected Boolean doInBackground(Void... params) {         try {             while (true) {                 int downloadPercent = doDownload();                 publishProgress(downloadPercent);                 if (downloadPercent &gt;= 100) {                     break;                 }             }         } catch (Exception e) {             return false;         }         return true;     }      @Override     protected void onProgressUpdate(Integer... values) {         progressDialog.setMessage(\"当前下载进度：\" + values[0] + \"%\");     }      @Override     protected void onPostExecute(Boolean result) {         progressDialog.dismiss();         if (result) {             Toast.makeText(context, \"下载成功\", Toast.LENGTH_SHORT).show();         } else {             Toast.makeText(context, \"下载失败\", Toast.LENGTH_SHORT).show();         }     } }  // 执行 DownloadTask mDownloadTask = new DownloadTask(); mDownloadTask.execute();   参数  从上面代码中，我们知道，AsynTask是一个抽象类，使用AsynTask需要自定义自己的任务类并继承AsynTask。它接收三个泛型参数,都继承自Object：          Params      用于指定方法doInBackground方法中的参数类型以及实例运行execute方法中的参数类型。           Progress      这个参数用于指定onProgressUpdate(Params… values)方法的参数类型。其实也就是指定后台任务的进度单位。示例中指定的是Integer，表示用整型来指定进度单位，如10%,20%,..,90%,100%。同样地，这里的values也是一个不定长参数。           Result      这个参数指定doInBackground 方法的返回类型，同时也是 onPostExecute(Boolean result) 的参数类型。在这里指定的是Boolean，表示doInBackground结束后会返回一个Boolean类型的数据到onPostExecute中，接下来 onPostExecute就可以使用这个返回的数据来做UI更新的逻辑了。      方法     onPreExecute(): 主线程执行 这个方法是AsyncTask最先执行的方法，在这里一般可以做一些简单的UI初始化操作，如进度条的显示等。   doInBackground(Params… params): 子线程执行  这个方法是AsyncTask一个最重要的方法。这个方法不会由主线程来执行，因此可以把耗时的逻辑操作交给这个方法来处理。当这个方法结束后，能够把处理完的结果返回到主线程中。这时，主线程中的界面元素就能够使用该返回结果更新数据了。   publishProgress(Progress… values):  子线程执行  这个方法用于通知任务进度的更新情况。举个例子，比如你想每完成10%就更新一次进度条，那就可以每隔10%调用一次这个函数来告诉AsynTask进度条可以更新了，AsynTask得到这个通知后就会尝试去执onProgressUpdate这个函数来更新进度显示了。   onProgressUpdate(Progress… values): 主线程执行  这个方法用于更新进度的显示，如进度条的更新。   onPostExecute(Result result): 主线程执行 这个方法用于UI组件的更新。doInBackground返回的结果会被传到这个方法中作为更新UI的数据。   源码分析  在进行分析之前需要对Java并发编程的一些知识有一些了解：Executor线程池、Callable、Future、FutureTask等  在示例中，我们先从mDownloadTask.execute()方法入手：  @MainThread public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) {     return executeOnExecutor(sDefaultExecutor, params); } @MainThread public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,                                                                    Params... params) {     if (mStatus != Status.PENDING) {         switch (mStatus) {             case RUNNING:                 throw new IllegalStateException(\"Cannot execute task:\"                                                 + \" the task is already running.\");             case FINISHED:                 throw new IllegalStateException(\"Cannot execute task:\"                                                 + \" the task has already been executed \"                                                 + \"(a task can be executed only once)\");         }     }      mStatus = Status.RUNNING;      onPreExecute();      mWorker.mParams = params;     exec.execute(mFuture);      return this; }   可以看到，上面execute方法执行了executeOnExecutor方法，并传入了两个参数sDefaultExecutor和params,其中params参数是我们执行task任务时传入的，而sDefaultExecutor是Android自己实现的一个默认的线程池。稍后我们再看这个线程池。  在executeOnExecutor方法中，我们关注下最后几行代码，其中onPreExecute方法就是我们示例中覆写的方法了，它运行在主线程，而mWorker是AsyncTask的私有变量,它实现了Callable接口，这个接口类似于Runnable，工作在子线程，不过和后者区别是它可以返回结果。  private final WorkerRunnable&lt;Params, Result&gt; mWorker; private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; {     Params[] mParams; }   最后进入到exec.execute(mFuture)方法，其中exec是参数传进来的，也就是前面的sDefaultExecutor，而方法参数mFuture同样是AsyncTask的私有变量，它是一个FutureTask对象，该对象实现了Runnable和Future接口，内部持有Callable的引用，通过执行run方法间接调用Callable的call方法，并获得结果，通过get方法可以拿到：  private final FutureTask&lt;Result&gt; mFuture;  mFuture = new FutureTask&lt;Result&gt;(mWorker) {     @Override     protected void done() {         try {             postResultIfNotInvoked(get());         } catch (InterruptedException e) {             android.util.Log.w(LOG_TAG, e);         } catch (ExecutionException e) {            throw new RuntimeException(\"An error occurred while executing doInBackground()\",                         e.getCause());         } catch (CancellationException e) {             postResultIfNotInvoked(null);         }     } };   到这里我们看下上面的executor方法，它是一个线程池的方法，调用方是sDefaultExecutor，来看下它的实现：  private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;  public static final Executor SERIAL_EXECUTOR = new SerialExecutor();  private static class SerialExecutor implements Executor {     final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();     Runnable mActive;      public synchronized void execute(final Runnable r) {         mTasks.offer(new Runnable() {             public void run() {                 try {                     r.run();  // 其实是调用的FutureTask的run方法                 } finally {                     scheduleNext();                 }         });         if (mActive == null) {             scheduleNext();         }     }      protected synchronized void scheduleNext() {          if ((mActive = mTasks.poll()) != null) {             THREAD_POOL_EXECUTOR.execute(mActive);         }     }  }    从上面这段代码可以看出，sDefaultExecutor本质就是一个默认的串行线程池，内部维护了一个任务队列ArrayDeque，所有任务都是按照入队的顺序一个一个执行，因为mFuture是FutureTask对象，实现了Runnable接口，所以提交到这里的FutureTask会通过ArrayDeque的offer方法被加入到任务队列队尾，紧接着执行scheduleNext方法，该方法内部通过ArrayDeque在队首取出一个任务，放入线程池执行。  前面看到，在创建FutureTask实例的时候传入了一个mWorker对象，它是WorkerRunnable&lt;Params, Result&gt;类型，本质上就是Callable任务。它是在AsyncTask构造函数中被实例化：  public AsyncTask(@Nullable Looper callbackLooper) {         mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper()             ? getMainHandler()             : new Handler(callbackLooper);          mWorker = new WorkerRunnable&lt;Params, Result&gt;() {             public Result call() throws Exception {                 mTaskInvoked.set(true);                 Result result = null;                 try {                     Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);                     //noinspection unchecked                     result = doInBackground(mParams);                     Binder.flushPendingCommands();                 } catch (Throwable tr) {                     mCancelled.set(true);                     throw tr;                 } finally {                     postResult(result);  // 返回结果                 }                 return result;             }         };          mFuture = new FutureTask&lt;Result&gt;(mWorker) {             @Override             protected void done() {                 try {                     postResultIfNotInvoked(get());                 } catch (InterruptedException e) {                     android.util.Log.w(LOG_TAG, e);                 } catch (ExecutionException e) {                     throw new RuntimeException(\"An error occurred while executing doInBackground()\",                             e.getCause());                 } catch (CancellationException e) {                     postResultIfNotInvoked(null);                 }             }         };     }    而我们前面提到的FutureTask实例也是在AsyncTask中被实例化。在mWorker的call方法中我们看到了doInBackground(mParams)方法，那么也印证了该方法在mFuture（FutureTask类型）的run方法中被执行。紧接着，我们看到了postResult方法  private Result postResult(Result result) {         @SuppressWarnings(\"unchecked\")     Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,       new AsyncTaskResult&lt;Result&gt;(this, result))     message.sendToTarget();     return result; }   这个postResult其实是把result构造进一个Message对象，然后通过getHandler()获取一个handler处理这个消息。Handler处理消息其实也就是handleMessage()的重写了:  private static Handler getHandler() {     synchronized (AsyncTask.class) {         if (sHandler == null) {             sHandler = new InternalHandler();         }         return sHandler;     } }  private static class InternalHandler extends Handler {     public InternalHandler() {         super(Looper.getMainLooper());     }      @SuppressWarnings({\"unchecked\", \"RawUseOfParameterizedType\"})     @Override     public void handleMessage(Message msg) {         AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;         switch (msg.what) {             case MESSAGE_POST_RESULT:                 // There is only one result                 result.mTask.finish(result.mData[0]);                 break;             case MESSAGE_POST_PROGRESS:                 result.mTask.onProgressUpdate(result.mData)                                       break;         }     } }   在InternalHandler的实现中，我们看到了覆写的handleMessage方法，另外这里还有一种消息类型MESSAGE_POST_PROGRESS，它执行我们的onProgressUpdate(result.mData)来更新进度，这个handler是绑定在AsyncTask的构造函数中，所以onProgressUpdate也就执行在了主线程，而发送的消息是在publishProgress中  protected final void publishProgress(Progress... values) {     if (!isCancelled()) {         getHandler().obtainMessage(MESSAGE_POST_PROGRESS,                 new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget();     } }   我们从实例中可以看到，publishProgress执行在doInBackground方法中，这里将消息包装成一个MESSAGE_POST_PROGRESS的Message然后通过handler回到主线程，处理进度条更新。最后在handleMessage中，执行finish方法：  private void finish(Result result) {     if (isCancelled()) {         onCancelled(result);     } else {         onPostExecute(result);     }     mStatus = Status.FINISHED }   这个方法执行了onPostExecute回调，又因为finish执行在主线程，所以该回调也是执行在主线程。  总结          用户调用mDownloadTask.execute()方法，进入到executeOnExecutor方法中国，执行了onPreExecute方法，将任务交给sDefaultExecutor调度。           mFuture(FutureTask类型)配合mWorker(Callable实现)开启子线程，即在线程池执行mFuture的run方法，间接调用了mWorker的call方法，在其call方法中，执行了doInBackground方法。           在第二步将执行结果交给内部单例InternalHandler处理返回结果并返回到主线程，根据Message处理onProgressUpdate()或onPostExecute()。"
  },
  
  {
    "title": "Java并发编程之Callable、Future和FutureTask",
    "url": "/posts/java-concurrency/",
    "categories": "Java",
    "tags": "并发编程",
    "date": "2015-07-14 00:00:00 +0800",
    "content": "基本概念  我们知道创建线程，经常使用两种方式，即：     直接继承Thread   另一种是实现Runnable接口   但是上面两种方式都有一个问题就是，在执行完任务之后无法直接获取执行的结果。而Callable的出现就是为了解决这个问题，下面是这两个接口的定义：  // Callable.java public interface Callable&lt;V&gt; {     V call() throws Exception; }  // Runnable.java public interface Runnable {     public abstract void run(); }   从上面源码中，我们可以看出来区别：     Runnable没有返回值；Callable可以返回执行结果（泛型）   Runnable异常只能在内部处理，不能往上继续抛出；Callable接口的call()方法允许抛出异常   Callable在使用过程中经常需要配合FutureTask或Future使用，因为它们可以对Callable任务执行取消，查询，获取结果等操作：     判断任务是否执行完成   取消任务并可以判断任务是否取消成功   获取任务执行的结果   下面是Future的定义：  public interface Future&lt;V&gt; {     boolean cancel(boolean mayInterruptIfRunning);     boolean isCancelled();     boolean isDone();     V get() throws InterruptedException, ExecutionException;     V get(long timeout, TimeUnit unit)         throws InterruptedException, ExecutionException, TimeoutException; }   FutureTask则实现了RunnableFuture接口，RunnableFuture继承了Runnable接口和Future接口  public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;{      }   public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; {     void run(); }   简单用法          先来看下Runnable：      Runnable runnable = new Runnable() {     @Override     public void run() {         System.out.println(\"线程执行中...\");     } }; Thread thread = new Thread(runnable); thread.start();                接下来是Callable             配合Future           Callable &lt;String&gt; callable = new Callable &lt;String&gt; () {     @Override     public String call() throws Exception {         System.out.println(\"线程执行中...\");         return \"Success\";     } }; ExecutorService service = Executors.newCachedThreadPool(); Future&lt;String&gt; future = service.submit(callable); // 等待1秒，让线程执行 try {     Thread.sleep(1000); } catch (InterruptedException e) {     e.printStackTrace(); } if(futureTask.isDone()) {     System.out.println(\"获取执行结果：\" + future.get()); }                  配合FutureTask           Callable &lt;String&gt; callable = new Callable &lt;String&gt; () {     @Override     public String call() throws Exception {         System.out.println(\"线程执行中...\");         return \"Success\";     } }; FutureTask &lt;String&gt; futureTask = new FutureTask &lt;String&gt; (callable); new Thread(futureTask).start(); // 第二种方式 // ExecutorService service = Executors.newCachedThreadPool(); // service.execute(futureTask);  // 执行Runnable无返回结果 // Future&lt;String&gt; future = service.submit(futureTask); // 执行Runnable有返回结果     // 等待1秒，让线程执行 try {     Thread.sleep(1000); } catch (InterruptedException e) {     e.printStackTrace(); } if(futureTask.isDone()) {     System.out.println(\"获取执行结果：\" + futureTask.get()); }           综上我们可以得出Runnable与Callable的一些区别：                      Runnable是自从java1.1就有了，而Callable是1.5之后才加上去的。                       Callable要实现的方法是call(),Runnable要实现的方法是run()。                       Callable的任务执行后可返回值，而Runnable的任务是不能返回值(是void)。                       call方法可以抛出异常，run方法不可以。                       运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。                       加入线程池运行，Runnable使用ExecutorService的execute方法，Callable使用submit方法。                  FutureTask      FutureTask内部提供了一个Callable的引用，在执行构造函数时将其传入，当运行FutureTask任务时，会执行其run方法，在run方法里面会调用上面Callable引用的call方法，并获得一个结果。 其部分源码如下：      public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; {     ...     private Callable&lt;V&gt; callable;     private Object outcome; // non-volatile, protected by state reads/writes     public FutureTask(Callable&lt;V&gt; callable) {         if (callable == null)             throw new NullPointerException();         this.callable = callable;         this.state = NEW;       // ensure visibility of callable     }     public V get() throws InterruptedException, ExecutionException {         int s = state;         if (s &lt;= COMPLETING)             s = awaitDone(false, 0L);         return report(s);     }             private V report(int s) throws ExecutionException {         Object x = outcome;         if (s == NORMAL)             return (V)x;    // 返回结果         if (s &gt;= CANCELLED)             throw new CancellationException();         throw new ExecutionException((Throwable)x);     }             protected void set(V v) {         if (U.compareAndSwapInt(this, STATE, NEW, COMPLETING)) {             outcome = v;             U.putOrderedInt(this, STATE, NORMAL); // final state             finishCompletion();         }     }             public void run() {         if (state != NEW ||             !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread()))             return;         try {             Callable&lt;V&gt; c = callable;             if (c != null &amp;&amp; state == NEW) {                 V result;                 boolean ran;                 try {                     result = c.call();  // 执行Callable的call方法                     ran = true;                 } catch (Throwable ex) {                     result = null;                     ran = false;                     setException(ex);                 }                 if (ran)                     set(result);  //并把结果赋值给outcome             }         } finally {             // runner must be non-null until state is settled to             // prevent concurrent calls to run()             runner = null;             // state must be re-read after nulling runner to prevent             // leaked interrupts             int s = state;             if (s &gt;= INTERRUPTING)                 handlePossibleCancellationInterrupt(s);         }     }             ... }"
  },
  
  {
    "title": "Android线程间通信之Handle机制原理",
    "url": "/posts/android-handler/",
    "categories": "Android",
    "tags": "Handler, 源码分析",
    "date": "2015-06-12 00:00:00 +0800",
    "content": "在Android开发中，我们 经常会用到Handler，主要是子线程完成耗时操作后，通过Handler向主线程发送消息Message，用来刷新UI。我们都知道下面这两个原则：     不能在子线程更新UI   不能在主线程执行耗时操作   Android中，界面主要是由主线程绘制的，所以界面的更新一般都限制在主线程内，这个异常是在viewRootIimpl.checkThread()方法中抛出来的，如果我们在它还没创建出来的时候就可以偷偷更新ui了。阅读过Activity启动流程的读者知道，ViewRootImpl是在onCreate方法之后被创建的，所以我们可以在onCreate方法中创建个子线程更新UI，那么就可以绕过这个异常限制，但是往往我们也不会这样做，谷歌这样设计也是为了App更加的安全。不能在子线程更新UI是因为会产生不可预期的后果，这一点还是由于线程安全引起的，而传统的加锁来解决的话，我们知道，加锁很重，会有性能损耗，尤其是对于UI操作来说。  在主线程执行耗时操作，这样很容易导致ANR，所以我们通常会把耗时操作放在子线程，然后子线程执行完会返回结果，这时候更新UI如果放在主线程，就需要切换线程来执行。综合上面两点，handler也就显得越来越重要了，我们先来看下一般在程序中如何使用它：  public class MainActivity extends AppComposeActivity{     ...;     // 第一种方法：使用callBack创建handler     public void onCreate(Bundle savedInstanceState){         super.onCreate(savedInstanceState);         Handler handler = Handler(Looper.myLooper(),new CallBack(){             @Override             public Boolean handleMessage(Message msg) {                 TODO(\"Not yet implemented\")             }         });     }          // 第二种方法：继承Handler并重写handlerMessage方法     static MyHandler extends Hanlder{         public MyHandler(Looper looper){             super(looper);         }         @Override         public void handleMessage(Message msg){             super.handleMessage(msg);             // TODO(重写这个方法)         }     } }   我们一点一点分析源码来分析：  先从构造函数  // Handler.java public Handler(@Nullable Callback callback, boolean async) {         if (FIND_POTENTIAL_LEAKS) {             final Class&lt;? extends Handler&gt; klass = getClass();             if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;                     (klass.getModifiers() &amp; Modifier.STATIC) == 0) {                 Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" +                     klass.getCanonicalName());             }         } \t\t     \t// 初始化Looper         mLooper = Looper.myLooper();         if (mLooper == null) {             throw new RuntimeException(                 \"Can't create handler inside thread \" + Thread.currentThread()                         + \" that has not called Looper.prepare()\");         }     \t// 初始化MessageQueue         mQueue = mLooper.mQueue;         mCallback = callback;         mAsynchronous = async; }   Handler中最重要的两个对象都是由Looper提供，具体代码如下：  // Looper.java public static @Nullable Looper myLooper() {     return sThreadLocal.get(); }   mylooper方法通过一个线程本地变量来取出Looper对象。而MessageQueue是我们的应用启动时初始化的，我们都知道当Activity启动时，ActivityThread的main方法是一个新的App进程入口，具体实现：  // ActivityThread.java public static void main(String[] args) {     ……     Looper.prepareMainLooper();     ……     if (sMainThreadHandler == null) {         sMainThreadHandler = thread.getHandler();     }      if (false) {         Looper.myLooper().setMessageLogging(new                                             LogPrinter(Log.DEBUG, \"ActivityThread\"));     }      ……     Looper.loop(); }    上面代码中Looper.prepareMainLooper()就是初始化当前Looper对象， Looper.loop()方法开启无限循环。  // Looper.java public static void prepareMainLooper() {     prepare(false);     synchronized (Looper.class) {         if (sMainLooper != null) {             throw new IllegalStateException(\"The main Looper has already been prepared.\");         }         sMainLooper = myLooper();     } }  ……  private static void prepare(boolean quitAllowed) {     if (sThreadLocal.get() != null) {         throw new RuntimeException(\"Only one Looper may be created per thread\");     }     sThreadLocal.set(new Looper(quitAllowed)); }   private Looper(boolean quitAllowed) {     mQueue = new MessageQueue(quitAllowed);     mThread = Thread.currentThread(); }   上面代码中prepare方法创建了一个Looper对象，并且把它存储在了线程本地变量中，和当前线程绑定在了一起。  而MessageQueue在Looper构造函数中创建了。上面第8行sMainLooper从sThreadLocal变量中取出Looper对象并赋给它。  注意prepare方法中会对Looper进行判断，如果已经存在，就会抛出上面异常，即一个线程中Looper.prepare()只能调用一次，实例如下：  class MainActivity : AppCompatActivity() {      override fun onCreate(savedInstanceState: Bundle?) {         super.onCreate(savedInstanceState)         setContentView(R.layout.activity_main)                  Looper.prepare()     } }   上面代码中由于在Activity启动时，Looper.prepare()方法已经在main方法中执行过一次，所以再次执行就会报错，所以一个线程只有一个Looper，又因为MessageQueue在Looper构造函数中被初始化，所以MessageQueue在一个线程中也只有一个。后续我们通过Handler发送的消息都会被发送到MessageQueue中。  Looper.loop  接着上面，Looper.loop开启了一个无限循环，这个无限循环也是Android App进程能够保持运行的原因，它并不会阻塞UI线程，反而还能接受来自屏幕的各种事件。这一点可以通过MessageQueue的next方法可以看出：  //Looper.java public static void loop() {     final Looper me = myLooper();     if (me == null) {         throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");     }          ……              for (;;) {         if (!loopOnce(me, ident, thresholdOverride)) {             return;         }     } }  private static boolean loopOnce(final Looper me,             final long ident, final int thresholdOverride) {          Message msg = me.mQueue.next(); // might block     if (msg == null) {         // No message indicates that the message queue is quitting.         return false;     }      ……      try {         msg.target.dispatchMessage(msg);         ……     }      ……      return true; }   // MessageQueue.java Message next() {     ……      for (;;) {         if (nextPollTimeoutMillis != 0) {             Binder.flushPendingCommands();         }          nativePollOnce(ptr, nextPollTimeoutMillis);          synchronized (this) {             // Try to retrieve the next message.  Return if found.             final long now = SystemClock.uptimeMillis();             Message prevMsg = null;             Message msg = mMessages;             if (msg != null &amp;&amp; msg.target == null) {                 // Stalled by a barrier.  Find the next asynchronous message in the queue.                 do {                     prevMsg = msg;                     msg = msg.next;                 } while (msg != null &amp;&amp; !msg.isAsynchronous());             }             if (msg != null) {                 if (now &lt; msg.when) {                     // Next message is not ready.  Set a timeout to wake up when it is ready.                     nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);                 } else {                     // Got a message.                     mBlocked = false;                     if (prevMsg != null) {                         prevMsg.next = msg.next;                     } else {                         mMessages = msg.next;                     }                     msg.next = null;                     if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);                     msg.markInUse();                     return msg;                 }             } else {                 // No more messages.                 nextPollTimeoutMillis = -1;             }             ……         }     }  }   上面next方法中nativePollOnce 方法是一个 native 方法，当调用此 native 方法时，主线程会释放 CPU 资源进入休眠状态，直到下条消息到达或者有事务发生，通过往 pipe 管道写端写入数据来唤醒主线程工作，这里采用的 epoll 机制。另外每次通过next()方法从MessageQueue中取出一个Message消息，如果消息不为空，则通过dispatchMessage方法分发出去，而这个target就是我们前面的Handler对象，这一点我们可以从Message源码中看出来。  public final class Message implements Parcelable {     public int what;      /**      * arg1 and arg2 are lower-cost alternatives to using      * {@link #setData(Bundle) setData()} if you only need to store a      * few integer values.      */     public int arg1;      /**      * arg1 and arg2 are lower-cost alternatives to using      * {@link #setData(Bundle) setData()} if you only need to store a      * few integer values.      */     public int arg2;          ……              Handler target;     …… }   而进入到Handler的dispatchMessage方法，我们看下：  //Handler.java public void dispatchMessage(@NonNull Message msg) {     if (msg.callback != null) {         handleCallback(msg);     } else {         if (mCallback != null) {             if (mCallback.handleMessage(msg)) {                 return;             }         }         handleMessage(msg);     } }   首先判断msg.callback是否为空，而这个callback就是我们post一个Runnable，如果是普通对象则通过handleMessage方法来处理，而这个方法也正是我们创建Handler时需要覆写的方法。  // Handler.java public final boolean post(@NonNull Runnable r) {     return  sendMessageDelayed(getPostMessage(r), 0); } private static Message getPostMessage(Runnable r) {     Message m = Message.obtain();     m.callback = r;     return m; } public static Message obtain() {     // 保证线程安全     synchronized (sPoolSync) {         if (sPool != null) {             Message m = sPool;             sPool = m.next;             m.next = null;             // flags为移除使用标志             m.flags = 0; // clear in-use flag             sPoolSize--;             return m;         }     }     return new Message(); } public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) {     if (delayMillis &lt; 0) {         delayMillis = 0;     }     return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); } public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) {     MessageQueue queue = mQueue;     if (queue == null) {         RuntimeException e = new RuntimeException(             this + \" sendMessageAtTime() called with no mQueue\");         Log.w(\"Looper\", e.getMessage(), e);         return false;     }     return enqueueMessage(queue, msg, uptimeMillis); }  private static void handleCallback(Message message) {     message.callback.run(); }   而前面的如果callback不为空就通过handleCallback执行Runnable的run方法，注意这里的Runnable就是一个回调方法，和线程没有关系。综上：如果Message的callback为空，则一般通过sendMessage发送消息，交给handlerMessage方法来处理，而不为空则通过handleCallback来处理。另外Google官方不建议我们通过new Message来创建消息对象，而是通过obtain方法复用Message来获得，这里不得不提一下sPool这个消息池。我们看下Message是如何回收的：  //Message.java void recycleUnchecked() {     // Mark the message as in use while it remains in the recycled object pool.     // Clear out all other details.     // 添加正在使用标志位，其他情况就除掉     flags = FLAG_IN_USE;     what = 0;     arg1 = 0;     arg2 = 0;     obj = null;     replyTo = null;     sendingUid = -1;     when = 0;     target = null;     callback = null;     data = null;     //拿到同步锁，以避免线程不安全     synchronized (sPoolSync) {         if (sPoolSize &lt; MAX_POOL_SIZE) {             next = sPool;             sPool = this;             sPoolSize++;         }     } }  // Handler.java public static Message obtain() {     // 保证线程安全     synchronized (sPoolSync) {         if (sPool != null) {             Message m = sPool;             sPool = m.next;             m.next = null;             // flags为移除使用标志             m.flags = 0; // clear in-use flag             sPoolSize--;             return m;         }     }     return new Message(); }   详细解释一下上面的sPool和next，将sPool看成一个指针，通过next来将对象组成一个链表，因为每次只需要从池子里拿出一个对象，所以不需要关心池子里具体有多少个对象，而是拿出当前这个sPool所指向的这个对象就可以了，sPool从思路上理解就是通过左右移动来完成复用和回收，  假设消息对象池为空，从new message开始，到这个message被取出使用后，准备回收          next=sPool，因为消息对象池为空，所以此时sPool为null，同时next也为null。     spool = this，将当前这个message作为消息对象池中下一个被复用的对象。     sPoolSize++，默认为0，此时为1，将消息对象池的数量+1，这个数量依然是全系统共共享的。      这时候假设又调用了这个方法，之前的原来的第一个Message对象假定为以为msg1，依旧走到上面的循环。          next=sPool，因为消息对象池为msg1，所以此时sPool为msg1，同时next，即下一个Message对象也为msg1。     sPool = this，将当前这个message作为消息对象池中下一个被复用的对象。     sPoolSize++，此时为1，将消息对象池的数量+1，sPoolSize为2，这个数量依然是全系统共共享的。      以此类推，直到sPoolSize=50(MAX_POOL_SIZE = 50)，这里回收可以看到采用的是链表的头插法。  假设上面已经回收了一个Message对象，又从这里获取一个message，看看obtain如何复用？          判断sPool是否为空，如果消息对象池为空，则直接new Message并返回     Message m = sPool，将消息对象池中的对象取出来，为m。     sPool = m.next，将消息对象池中的下一个可以复用的Message对象(m.next)赋值为消息对象池中的当前对象。(如果消息对象池就之前就一个，则此时sPool=null)     将m.next置为null，因为之前已经把这个对象取出来了。     m.flags = 0，设置m的标记位，标记位正在被使用     sPoolSize–，因为已经把m取出了，这时候要把消息对象池的容量减一。      Handler  上面Message中的target是如何赋值呢 ？我们接着往下看消息的发送相关代码：  // Handler.java public final boolean sendMessage(@NonNull Message msg) {     return sendMessageDelayed(msg, 0); } public final boolean sendEmptyMessageDelayed(int what, long delayMillis) {     Message msg = Message.obtain();     msg.what = what;     return sendMessageDelayed(msg, delayMillis); } public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) {     if (delayMillis &lt; 0) {         delayMillis = 0;     }     return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); } public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) {     MessageQueue queue = mQueue;     if (queue == null) {         RuntimeException e = new RuntimeException(             this + \" sendMessageAtTime() called with no mQueue\");         Log.w(\"Looper\", e.getMessage(), e);         return false;     }     return enqueueMessage(queue, msg, uptimeMillis); }   通过sendMessage方法，经过几层调用，最后我们来到了sendMessageAtTime方法中，最终会调用enqueueMessage方法将Message插入到消息队里中，即前面在ActivityThread中通过Looper创建的MessageQueue中去  接着往下看这个enqueueMessage方法：  // Handler.java private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,                                long uptimeMillis) {     msg.target = this;     msg.workSourceUid = ThreadLocalWorkSource.getUid();      if (mAsynchronous) {         msg.setAsynchronous(true);     }     return queue.enqueueMessage(msg, uptimeMillis); }  // MessageQueue.java boolean enqueueMessage(Message msg, long when) {     if (msg.target == null) {         throw new IllegalArgumentException(\"Message must have a target.\");     }      synchronized (this) {         if (msg.isInUse()) {             throw new IllegalStateException(msg + \" This message is already in use.\");         }          if (mQuitting) {             IllegalStateException e = new IllegalStateException(                 msg.target + \" sending message to a Handler on a dead thread\");             Log.w(TAG, e.getMessage(), e);             msg.recycle();             return false;         }          msg.markInUse();         msg.when = when;         Message p = mMessages;         boolean needWake;         if (p == null || when == 0 || when &lt; p.when) {             // New head, wake up the event queue if blocked.             msg.next = p;             mMessages = msg;             needWake = mBlocked;         } else {             // Inserted within the middle of the queue.  Usually we don't have to wake             // up the event queue unless there is a barrier at the head of the queue             // and the message is the earliest asynchronous message in the queue.             needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();             Message prev;             for (;;) {                 prev = p;                 p = p.next;                 if (p == null || when &lt; p.when) {                     break;                 }                 if (needWake &amp;&amp; p.isAsynchronous()) {                     needWake = false;                 }             }             msg.next = p; // invariant: p == prev.next             prev.next = msg;         }          // We can assume mPtr != 0 because mQuitting is false.         if (needWake) {             nativeWake(mPtr);         }     }     return true; }   上面代码可以看到，在Handler的enqueueMessage方法中，将Handler自身设置为msg.target对象，因此就对应上了前面的msg.target.dispatchMessage方法，即会用此Handler来调用dispatchMessage方法。  而MessageQueue的enqueueMessage方法中，可以看出MessageQueue其实是一个队列。另外还有一个问题就是，如果Message是一个阻塞消息，那么先postDelay10秒一个Runnable A，消息队列会一直阻塞，然后再 post一个Runnable B，B岂不是会等A执行完了再执行？正常使用时显然不是这样的，那么问题出在哪呢？我们先来看下上面的needWake变量，它被mBlocked赋值，而mBlocked是在上面MessageQueue的next 方法中被赋值:  Message next() {     ...     for (;;) {         if (nextPollTimeoutMillis != 0) {             Binder.flushPendingCommands();         }          nativePollOnce(ptr, nextPollTimeoutMillis);          synchronized (this) {             // Try to retrieve the next message.  Return if found.             final long now = SystemClock.uptimeMillis();             Message prevMsg = null;             Message msg = mMessages;             if (msg != null &amp;&amp; msg.target == null) {                 // Stalled by a barrier.  Find the next asynchronous message in the queue.                 do {                     prevMsg = msg;                     msg = msg.next;                 } while (msg != null &amp;&amp; !msg.isAsynchronous());             }             if (msg != null) {                 if (now &lt; msg.when) {                     // Next message is not ready.  Set a timeout to wake up when it is ready.                     nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);                 } else {                     // Got a message.                     mBlocked = false;                     if (prevMsg != null) {                         prevMsg.next = msg.next;                     } else {                         mMessages = msg.next;                     }                     msg.next = null;                     if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);                     msg.markInUse();                     return msg;                 }             } else {                 // No more messages.                 nextPollTimeoutMillis = -1;             }             ……         }     } }   在上面的next方法内部，如果有阻塞（可能是没有消息或者是只有Delay的消息），就会把Blocked这个变量标记为true，在下一个Message插入队列的时候，会判断这个message的位置，如果在队首就会调用nativeWake()方法。另外postDelay能够精确的延迟指定时间，也可以从这里看出来，在enqueueMessage()的时候把应该执行的时间（上面Hanlder调用路径的第三步延迟已经加上了现有时间，所以叫when）设置到msg里面，即上面的msg.when，如果头部的这个Message是有延迟而且延迟时间没到的话（now &lt; msg.when），会计算一下时间（保存为变量nextPollTimeoutMillis），然后在循环开始的时候判断如果这个Message有延迟，就调用nativePollOnce(ptr, nextPollTimeoutMillis)进行阻塞。nativePollOnce()的作用类似与object.wait()，只不过是使用了Native的方法对这个线程精确时间的唤醒。  那么上面那个问题就比较清晰了：     先postDelay10秒一个Runnable A，消息插入队列，MessageQueue调用nativePollOnce阻塞，Looper阻塞。   紧接着再post一个Runnable B，消息插入队列，判断现在A时间还没到，正在阻塞，就把B消息插入队列的头部，即A的前面，然后调用nativeWake()方法唤醒线程。   当调用MessageQueue的next()方法取出消息时，重新开始读取消息链表，第一个消息B无延时，直接返回给Looper。   Looper处理完这个消息再次调用next方法，MessageQueue继续读取消息链表，第二个消息A还没到时间，计算一下剩余时间，如果大于0那么继续调用nativePollOnce()本地方法进行阻塞，直到阻塞时间到或者下一次有Message插入队列。   最后说下Handler消息的同步屏障机制  Handler发送的消息分为普通消息、屏障消息、异步消息，一旦Looper在处理消息时遇到屏障消息，那么就不再处理普通的消息，而仅仅处理异步的消息。不再使用屏障后，需要撤销屏障，不然就再也执行不到普通消息了。这样设计的目的是为了让某些特殊的消息得以更快被执行的机制。比如绘制界面，这种消息可能会明显的被用户感知到，稍有不慎就会引起卡顿、掉帧之类的，所以需要及时处理（可能消息队列中有大量的消息，如果像平时一样挨个进行处理，那绘制界面这个消息就得等很久，这是不想看到的）。  平时我们发送普通消息时，这个target是不能为空的，  /MessageQueue.java boolean enqueueMessage(Message msg, long when) {     if (msg.target == null) {         throw new IllegalArgumentException(\"Message must have a target.\");     }     if (msg.isInUse()) {         throw new IllegalStateException(msg + \" This message is already in use.\");     } }   但是在发送屏障消息的时候，target是可以为空的，它本身仅仅是起屏蔽普通消息的作用，所以不需要target。MessageQueue中提供了postSyncBarrier()方法用于插入屏障消息。  //MessageQueue.java /**  * @hide  */ public int postSyncBarrier() {     return postSyncBarrier(SystemClock.uptimeMillis()); }  private int postSyncBarrier(long when) {     synchronized (this) {         //这个token在移除屏障时会使用到         final int token = mNextBarrierToken++;         final Message msg = Message.obtain();         msg.markInUse();         msg.when = when;         msg.arg1 = token;          //在屏障的时间到来之前的普通消息，不会被屏蔽         Message prev = null;         Message p = mMessages;         if (when != 0) {             while (p != null &amp;&amp; p.when &lt;= when) {                 prev = p;                 p = p.next;             }         }           //插入到单链表中         if (prev != null) { // invariant: p == prev.next             msg.next = p;             prev.next = msg;         } else {             msg.next = p;             mMessages = msg;         }         return token;     } }   如上面代码：     屏障消息和普通消息区别在于屏幕没有target，普通消息有target是因为它需要将消息分发给对应的target，而屏幕不需要被分发，它就是用来挡住普通消息来保证异步消息优先处理的   屏障和普通消息一样可以根据时间来插入到消息队列中的适当位置，并且只会挡住它后面的同步消息的分发   postSyncBarrier会返回一个token，利用这个token可以撤销屏障   postSyncBarrier是hide的，使用它得用反射   插入普通消息会唤醒消息对了，但插入屏障不会   这时候屏障消息已经插入到队列中了，那么它是如何挡住普通消息而只去执行异步消息的呢？还是看下上面MessageQueue的next方法  //MessageQueue.java Message next() {     ...     int pendingIdleHandlerCount = -1;     int nextPollTimeoutMillis = 0;     for (;;) {         //如有消息被插入到消息队列或者超时时间到，就被唤醒，否则会阻塞在这里         nativePollOnce(ptr, nextPollTimeoutMillis);          synchronized (this) {             final long now = SystemClock.uptimeMillis();             Message prevMsg = null;             Message msg = mMessages;             //遇到屏障  它的target是空的             if (msg != null &amp;&amp; msg.target == null) {                 //找出屏障后面的异步消息，                 do {                     prevMsg = msg;                     msg = msg.next;                     //isAsynchronous()返回true才是异步消息                 } while (msg != null &amp;&amp; !msg.isAsynchronous());             }              //如果找到了异步消息             if (msg != null) {                 if (now &lt; msg.when) {                     //还没到处理时间，再等一会儿                     nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);                 } else {                     //到处理时间了，就从链表中移除，返回这个消息                     mBlocked = false;                     if (prevMsg != null) {                         prevMsg.next = msg.next;                     } else {                         mMessages = msg.next;                     }                     msg.next = null;                     msg.markInUse();                     return msg;                 }             } else {                 //如果没有异步消息就一直休眠，等待被唤醒                 nextPollTimeoutMillis = -1;             }             ...         }         ...     } }   在MessageQueue中取下一个消息时，如果遇到屏障，就遍历消息队列，取最近的一个异步消息，然后返回出去。如果没有异步消息，则一直休眠在那里，等待着被唤醒。  上面postSyncBarrier()被标记位hide，google不让使用，但可以通过系统调用这个方法添加屏障（在ViewRootImpl中requestLayout时会使用到），添加异步消息有两种方法：     使用异步类型的Handler发送的全部Message都是异步的   通过Message的setAsynchronous()方法给Message标记异步   Handler 构造函数有一个参数async可以决定是否是异步Handler,但是被标记为@hide，从API28以后又提供了2个方法可以帮助创建异步的Handler，但是需要API版本是28以上。  //Handler.java /**  * @hide  */ public Handler(Looper looper, Callback callback, boolean async) {     mLooper = looper;     mQueue = looper.mQueue;     mCallback = callback;     mAsynchronous = async; } public static Handler createAsync(@NonNull Looper looper) {     if (looper == null) throw new NullPointerException(\"looper must not be null\");     return new Handler(looper, null, true); } public static Handler createAsync(@NonNull Looper looper, @NonNull Callback callback) {     if (looper == null) throw new NullPointerException(\"looper must not be null\");     if (callback == null) throw new NullPointerException(\"callback must not be null\");     return new Handler(looper, callback, true); }   而系统添加同步屏障是在View的绘制时，即在 viewRootImpl.requestLayout() 方法开始，这个方法会去执行上面的三大绘制任务，就是测量、布局和绘制。调用requestLayout()方法之后，并不会马上开始进行绘制任务，而是会给主线程设置一个同步屏障，并设置 ASYNC 信号监听。当 ASYNC 信号的到来，会发送一个异步消息到主线程Handler，执行我们上一步设置的绘制监听任务，并移除同步屏障。  //ViewRootImpl.java @Override public void requestLayout() {     if (!mHandlingLayoutInLayoutRequest) {         checkThread();         mLayoutRequested = true;         scheduleTraversals();     } } void scheduleTraversals() {     if (!mTraversalScheduled) {         mTraversalScheduled = true;         //插入屏障         mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();         //监听Vsync信号，然后发送异步消息 -&gt; 执行绘制任务         mChoreographer.postCallback(                 Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);         if (!mUnbufferedInputDispatch) {             scheduleConsumeBatchedInput();         }         notifyRendererOfFramePending();         pokeDrawLockIfNeeded();     } }   在等待Vsync信号的时候主线程什么事都没干，这样的好处是保证在Vsync信号到来时，绘制任务可以被及时执行，不会造成界面卡顿。  这样的话，我们发送的普通消息可能会被延迟处理，在Vsync信号到了之后，移除屏障，才得以处理普通消息。改善这个问题的办法是使用异步消息，发送异步消息之后，即时是在等待Vsync期间也可以执行我们的任务，让我们设置的任务可以更快得被执行（如有必要才这样搞，UI绘制高于一切）且减少主线程的Looper压力。  总结          应用启动是从 ActivityThread 的 main 开始的，先是执行了 Looper.prepare()，该方法先是 new 了一个 Looper 对象，在私有的构造方法中又创建了 MessageQueue 作为此 Looper 对象的成员变量，Looper 对象通过 ThreadLocal 绑定在了MainThread 中，这样以来，Looper就和线程绑定在了一起；           当我们创建 Handler 子类对象时，在构造方法中通过 ThreadLocal 获取绑定的 Looper 对象，并获取此 Looper 对象的成员变量 MessageQueue 作为该 Handler 对象的成员变量；           在子线程中调用上一步创建的 Handler 子类对象的 sendMesage(msg) 或者post(Runnable)方法时，在该方法中将 msg 的 target 属性设置为Handler自己本身，同时调用成员变量 MessageQueue 对象的 enqueueMessag() 方法将 msg 放入 MessageQueue 中；           主线程创建好之后，会执行 Looper.loop() 方法，该方法中获取与线程绑定的 Looper 对象，继而获取该 Looper 对象的成员变量 MessageQueue 对象，并开启一个会阻塞（不占用资源）的死循环，只要 MessageQueue 中有 msg，就会通过其next()获取该 msg，并执行 msg.target.dispatchMessage(msg) 方法（msg.target 即上一步引用的 handler 对象），此方法中调用了我们第二步创建 handler 子类对象时覆写的 handleMessage() 或者handleCallback()方法。这样一来，一个发送消息和处理消息的完整流程就梳理完了。           就是这个消息发送的过程，我们在不同的线程发送消息，线程之间的资源是共享的。也就是任何变量在任何线程都可以修改，只要做并发操作就好了。上述代码中插入队列就是加锁的synchronized，Handler中我们使用的是同一个MessageQueue对象，同一时间只能一个线程对消息进行入队操作。消息存储到队列中后，主线程的Looper还在一直循环loop()处理。这样主线程就能拿到子线程存储的Message对象，在我们没有看见的时候完成了线程的切换。           所以总结来讲就是：      1.创建了一个Looper对象保存在ThreadLocal中。这个Looper同时持有一个MessageQueue对象。      2.创建Handler获取到Looper对象和MessageQueue对象。在调用sendMessage方法的时候在不同的线程（子线程）中把消息插入MessageQueue队列。      3.在主线程中（UI线程），调用Looper的loop()方法无限循环查询MessageQueue队列是否有消息保存了。有消息就取出来调用dispatchMessage()方法处理。这个方法最终调用了我们自己重写了消息处理方法handleMessage(msg);这样就完成消息从子线程到主线程的无声切换。"
  }
  
]

