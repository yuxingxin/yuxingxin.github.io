[
  
  {
    "title": "基于Hacker News的内容热度推荐算法",
    "url": "/posts/recommendation-algorithm/",
    "categories": "Algorithm",
    "tags": "Recommendation, algorithm",
    "date": "2019-03-10 00:00:00 +0800",
    





    "snippet": "### 前言近期公司产品需要做一个内容推荐的功能，但限于人员和能力有限，经过调研，确定了一个简单相对我们可以实现的方案。一篇文章产生，随着用户浏览、点赞、分享、收藏、评论，热度逐渐攀升，进入榜单到推荐页面，但随着时间的推移，这篇文章也不能永久的霸占榜单，让后面新产生的文章没有机会到推荐页，因此也就有了时间衰减的因素，从而可以让榜单能够动态的变化，除了上面基本的原理以外，还需要人为干预因素，通过加权或者降权的方式来影响排名。#### 因子1. 用户活跃度（以积分的形式）2. 浏览量3. 点赞数4. 收藏数5. 评论数6. 分享数7. 时间衰减8. 平台编辑推荐（人为因素介入干预）#### 基本原理![img1](https://pic1.zhimg.com/80/v2-5807f2036274e5d082dc5cb2b83742d4_hd.png)##### 初始热度  Hinit与最后的推荐指数呈正相关（注意不是成正比），影响其的因素有：- 创作者：暂时以用户活跃度来界定- 内容属性：以篇幅、类别来区分##### 互动热度  Hinteract与最后的推荐指数呈正相关（注意不是成正比），用户行为数据是决定一篇文章是否热门的重要因素，通过对这些数据评级来进行调整行为分：比如： 浏览+1分，点赞+3分，评论+8分，收藏+10分，分享+15分。##### 时间衰减 Htime与最后的推荐指数呈负相关（注意不是成反比）大部分内容属于一次性消费品，用户看过也就过了，若推荐榜单总是那么几条， 可能很快就觉得乏味 ，从而转向别的产品。所以我们自然希望内容能不断更新，而若只看初始热度+互动热度，那么后来者必定很难超越前者。所以还必须考虑一个因素就是时间衰减，通常这个也不是线性衰减，往往是一个指数函数：即过了一定时间后，持续衰减，热度直到无限趋于0##### 权重 Hweight运营或编辑人为干预来调整权重也很重要，毕竟算法是死的，人是活的，虽然大部分都遵循这样一个规律，但也不排除偶然或者极端情况，比如恶意刷榜，这时候就需要人为的干预图形曲线：![image-20191029102231667](https://pic1.zhimg.com/80/v2-60770e14bf4cf2dd9748d91f77bf2b24_hd.jpg)#### 总结公式![img2](https://pic2.zhimg.com/80/v2-8ae6e823be2d4823be05d973e6aaaa0d_hd.jpg)参数解释：**Hinit** ： 初始热度值，可以以用户活跃度来衡量，比如以积分的形式，积分积累的途径有：1. 发文章2. 发笔记3. 发动态4. 提问题5. 回答问题6. 评论7. 系统、平台编辑推荐在其他条件一定的情况下，初始热度越高，其最终热度也就越高**Hinteract**：互动热度值，根据用户行为数据来衡量，参考点有以下几项：1. 浏览量2. 点赞量3. 评论量4. 收藏量5. 分享量在其他条件一定的情况下，互动热度越高，其最终热度也就越高**Htime**：时间衰减因子， 加2是为了防止最新发表的会导致分母过小 ，这个值可调，在前期平台人数较少时调整大一些，在后期人数增长起来后，可以调整的小一些，比如，因为用户对平台资源有一个消化时间。并不是一发出来就有数据的。**G**：重力因子，它决定了热度随时间下降的速度，前期平台人员较少时，相对应得发的资源也会比较少，这时可以把G调小一点，减缓时间推移对热度下降的影响，后期平台人员增多时，相对应的资源也会增加，这时可以把G调大一点，加速时间推移对热度下降的影响。比如：1.2-1.8**Hweight**: 加减权重，初始值可以为0，在某些偶然或者极端情况下需要人为干预的时候，可以动态调整其值，使其能够及时的控制其热度。#### 反作弊1. 可以通过权重来干预2. 可以制定社区规则来动态调整Hinit### 参考1. [Hacker News 帖子热度排序算法]( https://medium.com/hacking-and-gonzo/how-hacker-news-ranking-algorithm-works-1d9b0cf2c08d )2. [掘金文章内容热度排序算法]( https://juejin.im/post/5cc80ad7e51d45789161d0e1 )"
  },
  
  {
    "title": "关于Code Review的一些思考总结",
    "url": "/posts/code-review/",
    "categories": "CodeStyle",
    "tags": "CodeReview",
    "date": "2018-06-17 00:00:00 +0800",
    





    "snippet": "## Code Review- 提高代码质量- 提前发现bug- 统一代码规范- 提高团队成员代码技能总之，前期找问题（代码规范、潜在缺陷、BUG，代码设计等等），后期演变成开发者技术交流和员工成长### 如何开展- 代码规范：**明确Coding规则**- 检视清单：**结合业务特点，check重点**- 总结优化：**透明问题，持续优化**- 激励措施：**激发主观能动性**### 开展方式- **强制&非强制**- **线上交流（小组review）&线下会议（团队review）**- **小片段&大模块**- **发布前&发布后**- **高频率&低频率**### 阻力因素1. 领导或者团队骨干不认同2. 为了疲于应付3. 以**需求多，没时间**做为偷懒借口### 组织类型- 小组内review，通常是模块负责人或者项目负责人review，频率比较高，一天至少一次- 团队review，通常是整个团队review代码，团队负责人牵头，频率可以低一点，鉴于公司情况一周至少1次吧### review内容#### 统一团队代码风格和编程规范  静态代码检查工具  1. **Java类**：Checkstyle、FindBugs、PMD、Infer等  2. **JavaScript类**：JSLint、ESLint等  3. **Object-C类**：OCLint、Clang Static Analyzer、Infer等  4. **C#**类：StyleCode等  可以参考的一些编码规范(https://github.com/Kristories/awesome-guidelines)#### 发现『bad smell』的代码以及bug  相关书籍：《重构-改善既有代码的设计》《代码整洁之道》#### 团队成员好的经验  - 什么写法可能导致性能低下？  - 哪个接口要慎用？  - 哪些设计方式需要规避？  - 什么习惯容易引发内存泄漏？  ……#### 开发者由于当初时间紧迫而觉得设计不合理的功能  - 功能不完善  - 设计有欠缺  - 代码有更好实现方案  - 重视项目代码的可读性总之，代码是否符合团队约定的代码风格规范、代码是否切合它所实现的业务、代码是否安全、代码性能、对后续开发者是否友好，即是否容易维护等### 注意事项1. GitLab可以设置master和develop分支保护，开发者不能向这两个分支push代码，只能通过PR/MR形式。2. 可以通过设置git pre-commit hook来check，从而使不符合规范的代码禁止提交仓库。3. 配合CI检查，作为build的第一步。4. 用户角色有：**所有者/主程/开发者/报告者/访客**，其中只有所有者和主程才有review代码和合并代码权限。5. 注意小组至少有两个人有权限review并合并代码，避免一个人请假或者不在，导致代码合不上去。6. 主程一定要注意，避免过多模块工作堆积在自己身上，一定要学会合理分配任务，因为你还需要有精力去review代码，这也是一部分额外任务。7. 提交的 feature 分支全部走 gitlab 的 MR ，**develop分支不允许提交，只用来合并**，并且只合并那些经过review过的代码，**master分支不允许提交，也只用来合并**，并且只合并来自develop分支的代码。8. 不一定职称越高，就更有可能比别人review代码，code review知识共享更受重视，通过review发现bug是有的，但不是最终目的，增进团队共识，保护团队一致性其实更重要。9. 尽量避免开发经验不足的开发者或者刚进公司对业务不熟悉的人员（哪怕高级工程师）review 代码。10. 如果可以尽可能写单元测试，不一定cover全面，如果时间紧迫可以只对关键模块做。11. 提交PR/MR，记得在IM上通知相关人员review，比如项目负责人或者模块负责人。12. 控制团队review的时间，半个小时到1个小时，最好不要超过1个小时，30-40分钟为宜，项目负责人具体把握。13. 根据公司情况团队review一周在至少一次比较合适。14. review可能需要多次才被允许合入代码，这也就意味着，可能你的代码需要给多次修改才能改好。15. 避免代码堆积，造成一次review大量代码，一方面急于review，这样容易放水，同时也浪费时间，造成效果不理想。16. 建议由1人做好记录，把每次review的改进点以清单形式汇总列清楚发给所有参会人员。### 总结由于工期紧、需求变更快，如果不想清楚为什么要做 Code Review ，遇到障碍会非常容易妥协，慢慢 Code Review 就会走样，最终流于形式。反之，在我们遇到障碍，review 代码不顺利时就会以积极的心态来解决问题。Code Review会影响开发效率，事实上追求高质量的代码本身就降低了局部的开发效率，但是放眼长远，这样写出来的代码更加健壮，不会或很少出现“诡异”的bug，降低了后期维护的成本。所以Code Review本身没有问题，其实是人容易出问题。"
  },
  
  {
    "title": "关于fastlane已存在的证书复用问题",
    "url": "/posts/fastlane-reuse-certs/",
    "categories": "iOS",
    "tags": "fastlane",
    "date": "2018-01-10 00:00:00 +0800",
    





    "snippet": "### 前言iOS开发在团队项目协作中，面临着许许多的挑战，除了被大家诟病的nib文件和故事板以外，还有就是今天要说的证书管理问题，相信做过iOS开发的用户对fastlane已经不陌生了，它提供了很多有用的功能来帮助开发者从繁琐的重复性劳动中解脱出来，这里列举出一些：![](https://ws3.sinaimg.cn/large/006tNc79ly1fnbcmq6spkj30to0sbtag.jpg)* deliver: 上传截图, 元数据, app应用程序到App Store* supply: 上传Android app应用程序和元数据到Google Play* snapshot: 自动捕获iOS app应用程序本地截图* screengrab: 自动捕获Android app应用程序本地截图* frameit: 快速截屏并将截屏放入设备中* pem: 自动生成和更新推送通知配置文件* sigh: 开发证书和描述文件下载* produce: 使用命令行在iTunes Connect上创建新的app和开发入口* cert: 自动创建和配置iOS代码签名证书* spaceship: Ruby 库访问 Apple开发者中心和 iTunes Connect* pilot: 最好的方式管理你的TestFlight 测试人员和从终端构建* boarding: 最简单的方式邀请你的TestFlight beta测试人员* gym: iOS app打包签名自动化工具* match: 使用Git同步你的团队证书和配置文件* scan: 最简单方式测试你的 iOS 和 Mac apps今天说的其实是match，我们知道，苹果公司在个人开发者账号上面对于证书的生成是有严格的数量限制的，`development` 和 `distribution`证书类型只能生成2个，所以如果按照fastlane每次build不同的target或者不同的Bundle ID的话，它都会重新去生成一个新的证书并以此生成对应的描述文件，这样以来，我们也只能最多同时用该开发者账号签名两个App安装在真机上，想用第三个就必须revoke掉以前生成的证书，当然了，一旦把证书revoke掉了，这也就意味着我们用该证书签名的App也不能在真机上面使用了。所以就得考虑一下，该如果复用现有证书。#### 1. 拿到你想要复用证书的ID关于这个证书ID，从钥匙串和openssl工具库中没有找到方法来取到，但是可以通过spaceship这个库来实现，下面是相关脚本：```require 'spaceship'Spaceship.login('your@apple.id')Spaceship.select_teamSpaceship.certificate.all.each do |cert|   cert_type = Spaceship::Portal::Certificate::CERTIFICATE_TYPE_IDS[cert.type_display_id].to_s.split(\"::\")[-1]  puts \"Cert id: #{cert.id}, name: #{cert.name}, expires: #{cert.expires.strftime(\"%Y-%m-%d\")}, type: #{cert_type}\"end```执行上面代码，会输出所有证书的相应信息，你可以从中找到你想复用的那个证书的ID。#### 2. 创建远程仓库来保存证书。建立一个远程仓库，并在该目录下创建`certs/distribution`和 `certs/development`目录，分别存放生产和开发环境下的相关证书文件。#### 3. 通过钥匙串导出你想要复用的那个证书导出对应的cer文件和p12文件。#### 4. 执行下面命令，导出私钥文件```openssl pkcs12 -nocerts -nodes -out key.pem -in certificate.p12```#### 5. 生成最后需要的证书```openssl aes-256-cbc -k  -in key.pem -out .p12 -aopenssl aes-256-cbc -k  -in certificate.cer -out .cer -a```这里的cert_id是上面我们保存的证书id，其中执行完上述步骤后，就生成了fastlane match想要的证书，当执行fastlane match development/adhoc/appstore命令后，match就不会在Apple Development Center重新生成证书了，而是用现有的。将证书分别放到对应的git仓库目录中，提交并推送到远程仓库。#### 6. 在开发者网站上面生成App ID```fastlane produce -u  -a  --skip_itc```如果你的App需要在ITC（iTunes Connect）中创建，则移除`--skip_itc`选项。#### 7. 生成证书对应的描述文件```fastlane match  ```其中type有四种：development/adhoc/distribution/appstore如果执行过程中，出现输入Git Repo密码后，密码错误导致的不能解密repo，可以尝试着用`fastlane match change_password`来重置密码。如果修改密码后，发现还是不行的话，可以在与distribution同级目录下创建一个txt文件：\"match_version.txt\"，内容为fastlane版本号即可，再重新执行。> [22:57:23]: Cloning remote git repo...> [22:57:28]: Migrating to new match...> [22:57:28]: Enter the passphrase that should be used to encrypt/decrypt your certificates> [22:57:28]: This passphrase is specific per repository and will be stored in your local keychain> [22:57:28]: Make sure to remember the password, as you'll need it when you run match on a different machine> Passphrase for Git Repo: ******> Type passphrase again: ******> [22:57:34]: 🔒 Successfully encrypted certificates repo> [22:57:34]: Cloning remote git repo...> [22:57:39]: Couldn't decrypt the repo, please make sure you enter the right password!> version: 256> class: \"inet\"> ：：：：> ：：：：### 关于注册新设备在这之前我们都是通过开发者中心来添加和管理更新设备以及描述文件，有了fastlane提供的match命令则可以帮助我们做这些事情。**注册新设备****我们可以**通过添加action的方式**更新Fastfile文件：****直接添加设备**```register_devices(  devices: {    \"Luka iPhone 6\" => \"1234567890123456789012345678901234567890\",    \"Felix iPad Air 2\" => \"abcdefghijklmnopqrstvuwxyzabcdefghijklmn\"  }) # Simply provide a list of devices as a Hash```**通过文件添加设备**```register_devices(  devices_file: \"./devices.txt\") # Alternatively provide a standard UDID export .txt file, see the Apple Sample (http://devimages.apple.com/downloads/devices/Multiple-Upload-Samples.zip)```文件格式参考demo：[http://devimages.apple.com/downloads/devices/Multiple-Upload-Samples.zip](http://link.zhihu.com/?target=http%3A//devimages.apple.com/downloads/devices/Multiple-Upload-Samples.zip)你也可以添加参数：```register_devices(  devices_file: \"./devices.txt\", # You must pass in either `devices_file` or `devices`.  team_id: \"XXXXXXXXXX\",         # Optional, if you\"re a member of multiple teams, then you need to pass the team ID here.  username: \"luka@goonbee.com\"   # Optional, lets you override the Apple Member Center username.)```**更新描述文件**```match(type: \"adhoc\", force_for_new_devices: true)```注意这里的type，对应我们前面提到的几种类型，除此之外，我们也可以通过命令行的方式来更新描述文件：```fastlane match adhoc --force_for_new_devices```这样以来，fastlane会重新更新描述文件并提交到我们的证书仓库。后面我们需要做的就是，只需重新打包，然后将包通过Airport安装到新的设备上就可以了，经测试以前用该描述文件打的包也可以安装到新设备上面去。### 关于Apple ID开启双重验证如果开启双重验证，默认苹果会在新设备登录时，需要手动输入验证码，这时候如果是在CI上面构建，就会带来问题，此时我们可以通过以下方式解决：1. 访问[Apple ID网站](https://appleid.apple.com/),找到 安全 - App 专用密码，生成一个专用密码2. 然后在构建服务器上面配置环境变量: vim ~/.bash_profile```export FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD=```3. 执行 fastlane spaceauth -u  按提示获取session信息4. 复制session信息（很长一大段） 配置环境变量: vim ~/.bash_profile```export FASTLANE_SESSION=‘YOUR SESSION’```### 参考1. [Simplify your life with fastlane match](http://macoscope.com/blog/simplify-your-life-with-fastlane-match/)2.  [register_devices - fastlane docs](https://docs.fastlane.tools/actions/register_devices/)3.  [match - fastlane docs](https://docs.fastlane.tools/actions/match/)"
  },
  
  {
    "title": "Git使用过程中的一些常见场景问题总结",
    "url": "/posts/git-scenes/",
    "categories": "Tools",
    "tags": "Git",
    "date": "2017-12-11 00:00:00 +0800",
    





    "snippet": "之前在公司内部推Git，写了一份[git使用教程](https://devops.yuxingxin.com)，后来又在团队内部做了一次分享，内容是关于Git使用过程中经常会遇到的一些场景，并有了这份总结。### git基础基于feature的工作流- 添加忽略文件   .gitignore (http://gitignore.io/)- 基于develop分支开发：feature分支   bugfix分支   版本节点tag- 问题排查: diff 、log  、reflog、blame- 撤销操作: checkout  、reset、revert、commit --amend- 删除操作: rm  clean- 储藏操作: stash- 分支操作：创建、删除（注意远程分支的删除）、切换、合并（--no-ff 、rebase）- 标签操作更多详细查看上面教程链接### 场景#### 1. 本地已经存在的项目/分支与如何远程仓库关联```git remote add origin ```#### 2. 刚刚提交了的commit log发现错了，想修改```git commit --amend -m \"your new log\"```#### 3. 查看某次提交的日志和ID```git reflog```#### 4. 查看某次提交的内容```git show ```#### 5. 只是修改了工作区的文件，想恢复到原来修改前的样子```git reset --hard HEADgit checkout -- ```#### 6. 被修改的文件已经添加到了暂存区，想撤销添加```git reset --mixed HEAD```#### 7. 被修改的文件已经commit提交，想撤销提交```git reset --soft HEAD^```#### 8. 已经提交到远程主机的文件，想撤销```git revert git revert HEAD```#### 9. 已经开发一半的功能，但是没有开发完，这时候有个bug要紧急处理，需要放下手头的功能，赶去修改BUG```// 保存现场git stash  // 恢复现场git stash pop```#### 10. 加入过历史版本的文件，因某些原因被删除了想恢复```git checkout  -- ```另外你也可以用reset命令来完成#### 11. 需要单独把多次提交中的某一次提交从你的分支迁移到另外一个分支上，即跨分支应用commit```git cherry-pick ```比如：我想把以下分支```A-B  master   \\    C-D-E-F-G develop```中的D，F 两次提交移动到master分支，而保持其他commit不变，结果就像这样```A-B-D-F  master       \\        C-E-G develop```那么，思路是将D，F 用cherry-pick应用到master分支上，然后将develop分支对master分支变基。```$ git checkout master  $ git cherry-pick D  $ git cherry-pick F  $ git checkout develop  $ git rebase master```注意有些情况下使用cherry-pick会存在冲突，解决方法和我们平时合并分支遇到冲突一样。#### 12. 遇到文件冲突，可以手动解决，或者用你配置的工具解决，记得把文件标位resolved：add/rm如：常见的拉取同事的代码合并引起冲突```1. 手动处理冲突2. 文件标志位置为resolved：git add 3. 继续合并  git merge --continue当然也可以选择放弃合并：git merge --abort```#### 13. 让自己本地分支上面的每一次提交日志变得更有意义，有时候需要我们选择有意义的提交日志信息合并上去比如我们在bugfix分支上面由于修改bug提交了很多次，修复好了之后，我们想把这些提交合并入我们的master分支```git checkout mastergit merge --squash bugfixgit commit -m \"bug fixed\"```上面操作会将bugfix分支上的所有commit都合并为一个commit，并把它并入我们的master分支上去。这里还有一点需要注意的是：--squash含义代表的是本地内容与不使用该选项的合并结果相同，但是不提交，不移动HEAD指针，所以我们要另外多一条语句来移动我们的HEAD指针，即最后的commit。#### 14. 有时候需要整理我们本地的commits，可以使用Squash```git rebase -i ```举例：```git rebase -i HEAD~5执行完后，Git会把所有commit列出来，让你进行一些修改，修改完成之后会根据你的修改来rebase。HEAD-5的意思是只修改最近的5个commit。pick 033beb4 b1pick b426a8a b2pick c216era b3pick d627c9a b4pick e416c8b b5# Rebase 033beb4..e416c8b onto 033beb4## Commands:#  p, pick = use commit#  r, reword = use commit, but edit the commit message#  e, edit = use commit, but stop for amending#  s, squash = use commit, but meld into previous commit#  f, fixup = like \"squash\", but discard this commit's log message#  x, exec = run command (the rest of the line) using shell## If you remove a line here THAT COMMIT WILL BE LOST.# However, if you remove everything, the rebase will be aborted.#```上面pick是要执行的commit指令，另外还有reword、edit、squash、fixup、exec这5个，具体的含义可以看上面的注释解释，比较简单，这里就不说了。我们要合并就需要修改前面的pick指令：```pick 033beb4 b1squash b426a8a b2squash c216era b3squash d627c9a b4squash e416c8b b5```也就是下面这4个提交合并到最前面的那个提交里面，按esc，打上:wq提交保存离开。接着是输入新的commit message```b# This is a combination of 2 commits.# The first commit's message is:# b1## This is the 2nd commit message:## b2## This is the 3rd commit message:## b3## This is the 4th commit message:## b4## This is the 5th commit message:## b5## Please enter the commit message for your changes. Lines starting# with '#' will be ignored, and an empty message aborts the commit.# Not currently on any branch.# Changes to be committed:# (use \"git reset HEAD ...\" to unstage)## modified:   a.txt#```其中第一行的b就是需要我们输入的新信息，同样编辑完保存，出现类似下面的信息：```Successfully rebased and updated refs/heads/develop.```最后可以用git log指令来验证commits是不是我们要变成的样子。#### 15. 多人协作开发项目，想知道某个文件的当前改动情况通常查问题时想知道某个文件的某部分代码是谁改动的，那么git blame 就派上用场了。```git blame ```你也可以具体指定到某一行或者某几行代码```git blame -L , ```#### 16. 执行push命令向多个仓库同时提交代码有时候会做代码备份，将代码保存在几个不同的Git代码管理平台，这时候就需要用到了```修改本地仓库目录下.git/config文件[core]\trepositoryformatversion = 0\tfilemode = true\tbare = false\tlogallrefupdates = true\tignorecase = true\tprecomposeunicode = true[remote \"origin\"]\turl = git@github.com:yuxingxin/blog.git    url = ……    url = ……\tfetch = +refs/heads/*:refs/remotes/origin/*```如上 在remote处可以添加多个远程地址。#### 17. 从多次提交中快速定位某一次提交的bug```# 开始 bisect$ git bisect start# 录入正确的 commit$ git bisect good xxxxxx# 录入出错的 commit$ git bisect bad xxxxxx# 然后 git 开始在出错的 commit 与正确的 commit 之间开始二分查找，这个过程中你需要不断的验证你的应用是否正常$ git bisect bad$ git bisect good$ git bisect good...# 直到定位到出错的 commit，退出 bisect$ git bisect reset```### 总结当然了，git的一些常见场景，还远不止这些，限于本人能力有限，如果你在平时的工作中遇到一些很实用的命令，也欢迎反馈给我，我好一并学习。更多的详细可以参考之前总结的一系列文档: https://devops.yuxingxin.com。 学习git命令是一件很有意思的事情，我想它能帮助使用git命令的人更好的理解这一代码管理工具，从而不至于犯一些低级错误，MobDevGroup网站上面也分享过几个学习命令的网站，可以供参考：https://mobdevgroup.com/tools/assistant"
  },
  
  {
    "title": "Android Studio 和Gradle Plugin 3.0 迁移不完全指南",
    "url": "/posts/migrate-android-studio-3-guide/",
    "categories": "Android",
    "tags": "Android, Studio",
    "date": "2017-11-03 00:00:00 +0800",
    





    "snippet": "Android Studio 3.0 默认Gradle版本为4.1，如果你需要手动升级版本的话，记得修改gradle/wrapper/gradle-wrapper.properties文件的URL地址：```distributionUrl=https\\://services.gradle.org/distributions/gradle-4.1-all.zip```对应的Gradle插件版本为3.0.0，手动修改的话，需要修改项目级的build.gradle文件：```buildscript {    repositories {        ...        // You need to add the following repository to download the        // new plugin.        google()    }    dependencies {        classpath 'com.android.tools.build:gradle:3.0.0'    }}```注意上面记得添加google这个repository，某些官方依赖需要下载对应我们的构建工具buildToolsVersion版本为26.0.2，对应Module级项目build.gradle文件：```android {    compileSdkVersion 26    ...    defaultConfig {      ...    }}```## 使用变体感知（variant-aware）依赖管理机制Android 3.0的插件使用一种新的依赖机制，这种机制能自动的匹配我们项目中依赖库的变体，即app变体debug会自动消费它所依赖的library的debug变体。当然了，我们在给产品定制不同的风味时，它依然能够适用。所以呢为了保证能够准确的匹配这些变体，我们需要为所有的产品风味声明风味维度（flavor dimensions），以及不可能直接匹配的需要我们提供matching fallbacks（PS：不知道怎么翻译了...）好了，上面说了那么多\"废话\"，其实只是想说明一点，如果你项目中用了build type 或者product flavor一种或一种以上， 那么你就需要注意了，这里可能需要做相应的适配：### 添加风味维度的声明当我们在配置文件中配置产品风味的时候，现在需要声明风味维度，然后在每个产品风味中指定你前面所声明的某一个风味维度，如下：```//定义两个风味维度flavorDimensions \"api\", \"mode\"productFlavors {    demo {        //指定风味维度        dimension \"mode\"        ...    }    full {        dimension \"mode\"        ...    }    minApi24 {        dimension \"api\"        minSDKVersion '24'        versionNameSuffix \"-minApi24\"    }    minApi23 {        dimension \"api\"        minSDKVersion '23'        versionNameSuffix \"-minApi23\"    }    minApi21 {        dimension \"api\"        minSDKVersion '21'        versionNameSuffix \"-minApi21\"    }}   ```如上，配置完后，Gradle创建的构建变体数量等于每个风味维度中的风味数量与你配置的构建类型数量的乘积，在 Gradle 为每个构建变体或对应 APK 命名时，属于较高优先级风味维度的产品风味首先显示，之后是较低优先级维度的产品风味，再之后是构建类型。以上面的构建配置为例，Gradle 可以使用以下命名方案创建总共 12 个构建变体：构建变体：[minApi24, minApi23, minApi21][Demo, Full][Debug, Release]对应 APK：app-[minApi24, minApi23, minApi21]-[demo, full]-[debug, release].apk例如构建变体：minApi24DemoDebug，对应 APK：app-minApi24-demo-debug.apk当然如果有些特定的变体不是你需要的，你也可以过滤：```android{    variantFilter { variant ->        def names = variant.flavors*.name        // To check for a certain build type, use variant.buildType.name == \"\"        if (names.contains(\"minApi21\") && names.contains(\"demo\")) {        // Gradle ignores any variants that satisfy the conditions above.        setIgnore(true)        }    }}```如果组合多个产品风味，产品风味之间的优先级将由它们所属的风味维度决定。上面所列示的第一个风味维度中的产品风味比第二个维度中的产品风味拥有更高的优先级，以此类推。此外，与属于各个产品风味的源集相比，你为产品风味组合创建的源集拥有更高的优先级。如果不同源集包含同一文件的不同版本，Gradle 将按以下优先顺序决定使用哪一个文件（左侧源集替换右侧源集的文件和设置）：构建变体 > 构建类型 > 产品风味 > 主源集 > 库依赖项如以下优先级顺序：* src/demoDebug/（构建变体源集）* src/debug/（构建类型源集）* src/demo/（产品风味源集）* src/main/（主源集）这里说下源集的概念，Android Studio 按逻辑关系将每个模块的源代码和资源分组称为源集，默认情况下，Android Studio 会创建 main/源集和目录，用于存储要在所有构建变体之间共享的一切资源。然而，我们也可以创建新的源集来控制 Gradle 要为特定的构建类型、产品风味（以及使用风味维度时的产品风味组合）和构建变体编译和打包的确切文件。例如，可以在 main/ 源集中定义基本的功能，使用产品风味源集针对不同的客户更改应用的品牌，或者仅针对使用调试构建类型的构建变体包含特殊的权限和日志记录功能等。* `src/main/`：此源集包括所有构建变体共用的代码和资源。* `src//`：创建此源集可加入特定构建类型专用的代码和资源。* `src//`：创建此源集可加入特定产品风味专用的代码和资源。* `src//`：创建此源集可加入特定构建变体专用的代码和资源。配置完后我们可以通过Android Studio窗口右侧Gradle，导航至YourApplication>Tasks>android下双击sourceSets，在Android Studio底部右下角 Gradle Console处查看项目是如何组织源集的### 关于构建类型的配置假设App中配置了一个叫做\"jniDebug\"的构建类型，但是该App所依赖的库中没有配置，这时候当我们构建\"jniDebug\"的时候，插件就不知道库该使用什么构建类型，这时候就会给报出下面的错误：```Error:Failed to resolve: Could not resolve project :mylibrary.Required by:project :app```这类问题就是由于上面的依赖管理机制变化导致的，我们可以下面的几种情况来分别解决：#### 你的 Module App 包含了它所依赖的库没有的构建类型例如，我们的App包含了一个jniDebug的构建类型，但是它所依赖的库中没有这个，而是有debug和release这两个构建类型，这时候我们就可以在Module App的build.gradle文件中使用matchingFallbacks 来指定可以替换的匹配项，如下：```android {    buildTypes {        debug {}        release {}        jniDebug {            // Specifies a sorted list of fallback build types that the            // plugin should try to use when a dependency does not include a            // \"jniDebug\" build type. You may specify as many fallbacks as you            // like, and the plugin selects the first build type that's            // available in the dependency.            matchingFallbacks = ['debug', 'release']        }    }}```值得一提的是插件会选择matchingFallbacks列表中第一个可用的构建类型来替换匹配项。> 注意当依赖的库中包含了Module App没有的构建类型，则不会出现上述问题。#### 对于一个给定的存在于App和它所依赖的库中的风味维度，我们的主Module App包含了库中没有的风味例如，主Module App和库中都包含了一个mode的风味维度，我们的App中指定mode维度的是free和paid风味，而库中指定mode维度的是demo和paid风味，这时候我们就可以用`matchingFallbacks 来为App中的free指定可以替换的匹配项。如下：```android {    defaultConfig{    // Do not configure matchingFallbacks in the defaultConfig block.    // Instead, you must specify fallbacks for a given product flavor in the    // productFlavors block, as shown below.    }    flavorDimensions 'mode'    productFlavors {        paid {            dimension 'mode'            // Because the dependency already includes a \"paid\" flavor in its            // \"mode\" dimension, you don't need to provide a list of fallbacks            // for the \"paid\" flavor.        }        free {            dimension 'mode'            // Specifies a sorted list of fallback flavors that the plugin            // should try to use when a dependency's matching dimension does            // not include a \"free\" flavor. You may specify as many            // fallbacks as you like, and the plugin selects the first flavor            // that's available in the dependency's \"mode\" dimension.            matchingFallbacks = ['demo', 'trial']        }    }}```值得注意的是，上述情况中，如果说库中包含了一个主Module App没有的产品风味，则不会出现上述问题。#### 库中包含了一个主Module App没有的风味维度例如，库中声明了一个minApi的风味维度，但是你的App中只有mode维度，因此当你要构建freeDebug这个变种版本的App时，插件就不知道你是想用minApi23Debug还是用minApi25Debug变种版本的库，这时候我们可以在主Module App中的defaultConfig代码块通过配置missingDimensionStrategy来让插件从丢失的维度中指定默认的风味，当然你也可以在productFlavors代码块中覆盖先前的选择，因此每一个风味都可以为丢失的维度指定一个不同的匹配策略。```android {    defaultConfig{        // Specifies a sorted list of flavors that the plugin should try to use from        // a given dimension. The following tells the plugin that, when encountering        // a dependency that includes a \"minApi\" dimension, it should select the        // \"minApi23\" flavor. You can include additional flavor names to provide a        // sorted list of fallbacks for the dimension.        missingDimensionStrategy 'minApi', 'minApi23', 'minApi25'        // You should specify a missingDimensionStrategy property for each        // dimension that exists in a local dependency but not in your app.        missingDimensionStrategy 'abi', 'x86', 'arm64'    }    flavorDimensions 'mode'    productFlavors {        free {            dimension 'mode'            // You can override the default selection at the product flavor            // level by configuring another missingDimensionStrategy property            // for the \"minApi\" dimension.            missingDimensionStrategy 'minApi', 'minApi25', 'minApi23'        }        paid {}    }}```> 值得注意的是，当你的主Module App中包含了一个库中依赖项没有的风味维度时，则不会出现上述问题。例如，当库中依赖项不包含abi这个维度时，freeX86Debug版本将会使用freeDebug版本的依赖。## 使用新的依赖配置先来看下以前的配置：```android {...}...dependencies {    // The 'compile' configuration tells Gradle to add the dependency to the    // compilation classpath and include it in the final package.    // Dependency on the \"mylibrary\" module from this project    compile project(\":mylibrary\")    // Remote binary dependency    compile 'com.android.support:appcompat-v7:26.1.0'    // Local binary dependency    compile fileTree(dir: 'libs', include: ['*.jar'])}```上面也是我们常见的三种依赖项声明：1. 模块依赖项compile project(':mylibrary') 行声明了一个名为“mylibrary”的本地 Android 库模块作为依赖项，并要求构建系统在构建应用时编译并包含该本地模块。2. 远程二进制依赖项compile 'com.android.support:appcompat-v7:26.1.0' 行会通过指定其 JCenter 坐标，针对 Android 支持库的 26.1.0 版本声明一个依赖项。3. 本地二进制依赖项compile fileTree(dir: 'libs', include: ['*.jar']) 行告诉构建系统在编译类路径和最终的应用软件包中包含 app/libs/ 目录内的任何 JAR 文件。先来看下以前配置的关键字：* compile指定编译时依赖项。Gradle 将此配置的依赖项添加到类路径和应用的 APK。这是默认配置。* apk指定 Gradle 需要将其与应用的 APK 一起打包的仅运行时依赖项。我们可以将此配置与 JAR 二进制依赖项一起使用，而不能与其他库模块依赖项或 AAR 二进制依赖项一起使用。* provided指定 Gradle 不与应用的 APK 一起打包的编译时依赖项。如果运行时无需此依赖项，这将有助于缩减 APK 的大小。我们可以将此配置与 JAR 二进制依赖项一起使用，而不能与其他库模块依赖项或 AAR 二进制依赖项一起使用。* 使用构建变体或者测试源集的名称配置关键字这种方式可以为特定的构建变体或者测试源集配置依赖项，如：```dependencies {    ...    // Adds specific library module dependencies as compile time dependencies    // to the fullRelease and fullDebug build variants.    fullReleaseCompile project(path: ':library', configuration: 'release')    fullDebugCompile project(path: ':library', configuration: 'debug')    // Adds a compile time dependency for local tests.    testCompile 'junit:junit:4.12'    // Adds a compile time dependency for the test APK.    androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'}```我们再来看下新的配置项：  * implementation     原有compile已经废弃掉，新增了implementation，用它来配置模块时，它是用来告诉Gradle该Module不会在编译时暴露其依赖给其他Module，而仅仅是在运行时才会暴露出来，即对其他Module可用。因此它也常常用在该模块不需要有别的模块依赖时声明使用，例如我们的App Module或者test Module。这样做的好处是减少了我们构建的时间。  * api     同原有compile，它和上面的区别就是它在编译器和运行期都会暴露它所配置的模块，因此也常常用在\t\t\t\t\t\t\t\tlibrary module中。这是因为一旦我们api配置的这个Module有变化，Gradle会在编译期重新编译那个依赖项的所有依赖。所以，如果我们项目中有大量的api配置项依赖，那么无形中就增加了构建的时间，除非你想暴露这个模块的API给其他Module使用，否则，我们应尽可能使用implementation来代替。  * compileOnly     同上面的provided，只在编译时用，不会打包到我们的APK中  * runtimeOnly     同上面的apk## 一些API的变化尤其注意的是我们重命名打包的APK文件，以及输出路径。变化前：```applicationVariants.all { variant ->    variant.outputs.each { output ->        def outputFile = output.outputFile        if (outputFile != null && outputFile.name.endsWith('.apk')) {            if (variant.buildType.name == 'lotteryTest') {                def fileName = \"myApp_v${defaultConfig.versionName}_${releaseTime()}.apk\"                output.outputFile = new File(outputFile.parent, fileName)            }        }    }}```变化后：```applicationVariants.all { variant ->    variant.outputs.all { output ->        def outputFile = output.outputFile        if (outputFile != null && outputFile.name.endsWith('.apk')) {            if (variant.buildType.name == 'lotteryTest') {                def fileName = \"myApp_v${defaultConfig.versionName}_${releaseTime()}.apk\"                outputFileName = new File(fileName)            }        }    }}```即我们需要修改each() 和 outputFile() 方法为 all() 和 outputFileName## 默认启用AAPT2  在迁移的过程中，如果发现由于aapt2导致的异常，可以在gradle.properties中加入：  ```  android.enableAapt2=false  ```## 支持Java8新特性### Gradle带来全新的Java8支持方案desugar该方案启用十分简单，只需要配置下面代码：```compileOptions {    sourceCompatibility JavaVersion.VERSION_1_8    targetCompatibility JavaVersion.VERSION_1_8}```如果你不想使用，也可以禁用，可以在gradle.properties中加入：```android.enableDesugar=false```记得删除上面的兼容Java8代码。### 移除Jack工具链，不再支持```android {...defaultConfig {    ...    // Remove this block.    jackOptions {        enabled true        ...    }}// Keep the following configuration in order to target Java 8.compileOptions {    sourceCompatibility JavaVersion.VERSION_1_8    targetCompatibility JavaVersion.VERSION_1_8}}```### 移除Retrolambda插件项目级build.gradle 文件：```buildscript {...dependencies {    // Remove the following dependency.    classpath 'me.tatarka:gradle-retrolambda:'}}```Module级build.gradle文件：```// Remove the following plugin.apply plugin: 'me.tatarka.retrolambda'...// Remove this block after migrating useful configurations.retrolambda {...// If you have arguments for the Java VM you want to keep,// move them to your project's gradle.properties file.jvmArgs '-Xmx2048m'}```### 目前兼容支持的功能特性有：* Lambda expressions* Method References* Type Annotations* Default and static interface methods* Repeating annotations## 参考* https://developer.android.com/studio/write/java8-support.html#migrate* https://android-developers.googleblog.com/2017/10/android-studio-30.html* https://developer.android.com/studio/build/gradle-plugin-3-0-0.html#known_issues* https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration.html"
  },
  
  {
    "title": "依赖注入库Dagger2",
    "url": "/posts/dagger2/",
    "categories": "Android",
    "tags": "Dagger2",
    "date": "2017-06-26 00:00:00 +0800",
    





    "snippet": "### 依赖注入Dagger2之前在项目中要用到这个库，后来就给团队内部分享完Dagger2后做的一个提纲总结。### 解决的痛点  依赖管理问题### 角色  1. 依赖实例  2. 注入对象  3. 注入方式### 提供依赖的方式  1. @Inject  2. @Module  优先级更高     @provide### 注入在哪里  @Inject### 注入方式：连接的桥梁#### @Component  注入方法：void inject();  提供中间桥梁：Application  getApplication();  依赖的实体：modules  依赖的传递：dependencies  本质是将依赖的Component的引用传递给了被依赖的Component#### @SubComponent：Component的拓展  公用依赖实例#### 区别##### Component Dependencies： 单纯依赖  1. 你想保留独立的单个组件  2. 要明确的显示该组件所使用的其他依赖##### Subcomponent：有点类似继承  1. 两个组件之间的关系紧密  2. 你只关心Component，而Subcomponent只是作为Component的拓展### 限定符  @Qualifier  自定义注解  区分多个依赖对象，单独为其打上标记### 作用域#### @Scope  自定义注解  管理依赖的生命周期  默认实现：@Singleton   局部单例  > Module中provide方法使用了@scope, 对应的Component中也必须加上@scope,  注解名字也是一样的，这时候 provide提供的方法就会在Component中保持『局部单例』，如果只是在Component中标注@scope,Module中的provide方法没有标注，这时候scope就不会起作用，仅仅是为了编译通过  实现单例：  1. 依赖在Component中是单例的（供该依赖的provide方法和对应的Component类使用同一个Scope注解。）  2. 对应的Component在App中只初始化一次，每次注入依赖都使用这个Component对象。（在Application中创建该Component）  自定义其他scope：@ActivityScope  @FragmentScope等等### 延迟注入Lazy  初始化的时候不注入，等到调用get方法的时候才去初始化依赖实例注入依赖### 多实例注入Provider  有时候不仅仅是注入单个实例，我们需要多个实例，每次调用它的 get() 方法都会调用到 `@Inject 构造函数`创建新实例或者 Module 的 provide 方法返回新实例"
  },
  
  {
    "title": "终端下Python镜像源管理工具pprm",
    "url": "/posts/pprm/",
    "categories": "Tools",
    "tags": "registry",
    "date": "2017-03-01 00:00:00 +0800",
    





    "snippet": "我们在使用Python做开发的时候，常常会用到第三方库，.虽然用easy_install和pip来安装第三方库很方便，但默认的第三方库是从Python的[官方源](https://pypi.python.org/pypi)下载的，因为某些原因，官方的网站访问时快时慢，很不稳定，有时候也直接打不开了，网上可以找一些国内的镜像源可以做为替换，通过修改配置文件(`~/.pip/pip.conf`)pip.conf即可，其实这个小工具的作用就是帮我们做这个事情，另外也提供了增删查等其他相关命令。### 安装```$  npm install -g pprm```### 使用##### 列出所有的镜像源地址：```$ prm ls  pypi --- https://pypi.python.org/simple/* douban - https://pypi.doubanio.com/simple/  ali ---- http://mirrors.aliyun.com/pypi/simple/  tsinghua  https://pypi.tuna.tsinghua.edu.cn/simple/  ustc --- https://mirrors.ustc.edu.cn/pypi/web/simple/```##### 切换镜像源：```$ prm use aliRegistry has been set to: http://mirrors.aliyun.com/pypi/simple/```##### 查看当前镜像源：```$ prm currentdouban```##### 添加镜像源：```$ prm add 'registry_name' 'registry_url' 'registry_home_url'# 参数依次是镜像源的名称、地址、项目首页```##### 删除指定的镜像源：```$ del 'registry_name'```##### 用浏览器打开主页：```prm home 'registry_name'```##### 测试镜像源地址的响应速度：```prm test 'registry_name'```##### 帮助中心```prm help```![pprm](http://upload-images.jianshu.io/upload_images/450566-ae3ae41a9170f4e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)##### 版本```prm version```### 项目地址：* [GitHub_pprm](https://github.com/yuxingxin/pprm)* [npm_pprm](https://www.npmjs.com/package/pprm)"
  },
  
  {
    "title": "博客的迁移及自动化部署并全站https化",
    "url": "/posts/deploy-via-https/",
    "categories": "Others",
    "tags": "https",
    "date": "2017-02-17 00:00:00 +0800",
    





    "snippet": "过完年来想把博客做一个迁移，放到自己购买的服务器上，并实现\u0015自动化部署，并启用全站HTTPS## hexo本地部署这一步骤网上有很多教程，这里不再多说了## 服务器自动化部署大体的流程就是，我们通过`hexo g`命令在本地生成静态文件以后，通过git push到我们的远程仓库(这里我用的是GitHub)，然后由于我们事先在项目库中配置了webhooks，由它post到你的服务器一个请求链接，我们的服务器收到请求后，对应执行我们提前写好的脚本，再将push的内容同步到我们的服务器，从而更新了服务器的内容。## 服务器环境配置我们通过ssh(windows用户可以通过putty登录)登录到我们的服务，我这里用的是Ubuntu系统，安装好nodejs,git,nginx后，将我们的文件从远程仓库拉下来```mkdir blogcd bloggit initgit remote add origin https://github.com/yuxingxin/yuxingxin.github.io.gitgit pull origin master```### 配置nginx这个配置之前写的有相关文章，不明白的可以看[这里](http://www.jianshu.com/p/3531a011b7b6)，不过这里的系统是Ubuntu，所以nginx的安装路径也不太一样(`/etc/nginx`)，默认我们需要在`/etc/nginx/conf.d/`目录下添加配置文件`blog.conf`，**注意这里的后缀名一定是`.conf`**```vim /etc/nginx/conf.d/blog.conf```然后配置上我们的域名，端口和映射地址```server {    listen       80;  #修改这里为其他端口如8081    server_name  yuxingxin.com www.yuxingxin.com; # 这里是你的域名    location / {        root   /root/blog/; #修改这里的路径为自己的路径        index  index.html index.htm;    }}```然后重启nginx通过域名就可以访问我们的博客了```nginx -s reload```### webhooks配置也就是人们常说的钩子，是一个很有用的工具。你可以通过定制 Webhook 来监测你在 Github.com 上的各种事件，最常见的莫过于 push 事件,如果你设置了一个监测 push 事件的 Webhook，那么每当你的这个项目有了任何提交，这个 Webhook 都会被触发，这时 Github 就会发送一个 HTTP POST 请求到你配置好的地址。如此一来，你就可以通过这种方式去自动完成一些重复性工作；比如，你可以用 Webhook 来自动触发一些持续集成（CI）工具的运作，比如 Travis CI；又或者是通过 Webhook 去部署你的线上服务器。Webhook 的配置是十分简单的。首先进入你的 repo 主页，通过点击页面上的按钮 [settings] -> [Webhooks & service] 进入 Webhooks 配置主页面。在Payload URL配置链接，比如：```http://xxxxx.com:8246/webhooks/push/deploy```这样一来，仓库的配置就算好了，接下来看服务器端如何响应### 服务器配置webhooks响应首先我们在我们的博客目录下创建一个js文件，用来启动我们的监听服务，端口就是我们在仓库配置那里的端口地址：8246```var http = require('http')var exec = require('child_process').exechttp.createServer(function (req, res) {    if(req.url === '/webhooks/push/deploy'){        exec('sh ./deploy.sh',function(error,stdout,stderr){\t     if(error){\t\t  console.log(error.stack);\t\t  console.log('Error code:'+ error.code);\t     }else{\t          console.log('success');\t     }\t})    }    res.end()}).listen(8246)```这段代码就能启动一个nodejs服务，监听8246端口，当请求过来的url完全匹配的时候，执行deploy.sh。再新建一个deploy.sh文件处理部署相关脚本：```git pull origin master```### 运行nodejs服务```node ./webhooks.js```如果你使用上面的命令运行nodejs服务，nodejs服务会在前台运行，可以使用[pm2](https://www.npmjs.com/package/pm2)使nodejs运行在后台。```# 安装npm install pm2 -g# 启动服务pm2 start webhooks.js# 停止服务pm2 stop webhooks.js# 重启服务pm2 restart webhooks.js# 实时查看pm2的日志服务pm2 logs```到此为止我们的自动化部署就全部完成了，以后我们只需在本地将文件push到远程仓库，就会自动同步到我们的服务器上## 启用全站HTTPS这里简单总结下在 Nginx 配置 HTTPS 服务器：主要签署第三方可信任的证书和配置HTTPS### 关于证书SSL证书需要向国际公认的证书证书认证机构（简称CA，Certificate Authority）申请。CA机构颁发的证书有3种类型：1. 域名型SSL证书（DV SSL）：信任等级普通，只需验证网站的真实性便可颁发证书保护网站；2. 企业型SSL证书（OV SSL）：信任等级强，须要验证企业的身份，审核严格，安全性更高；3. 增强型SSL证书（EV SSL）：信任等级最高，一般用于银行证券等金融机构，审核严格，安全性最高，同时可以激活绿色网址栏。关于证书服务，市面上大体的都是收费的证书，当然也有部分是免费的，比如Let's Encrypt  刚刚又拍云也上线了免费的 SSL [证书](http://weibo.com/ttarticle/p/show?id=2309404057245016043005#_0)，另外StartSSL也提供免费证书，有效期3年；另外还有腾讯云和阿里云都有相关的免费证书，这里我使用的是Let's Encrypt ,这也是目前最知名的开源SSL证书。### 证书申请申请 Let's Encrypt 证书不但免费，还非常简单，虽然每次只有 90 天的有效期，但可以通过脚本定期更新，配好之后一劳永逸。Let's Encrypt 的证书签发过程使用的就是 ACME 协议,这里也推荐一个小工具就是[acme-tiny](https://github.com/diafygi/acme-tiny),它可以帮助我们简化创建证书的流程。#### 创建帐号创建一个目录存放私钥证书等各种文件，然后进入后创建我们的RSA账户私钥```mkdir sslcd sslopenssl genrsa 4096 > account.key```#### 创建 CSR 文件这一步生成我们的证书签名文件，即CSR，首先要创建RSA私钥```openssl genrsa 4096 > domain.key```接下来就可以生成我们的证书文件了，单个域名和多个域名生产的参数还不太一样.```//单个域名openssl req -new -sha256 -key domain.key -subj \"/CN=yuxingxin.com\" > domain.csr//多个域名（比如yuxingxin.com和www.yuxingxin.com）openssl req -new -sha256 -key domain.key -subj \"/\" -reqexts SAN -config  domain.csr```#### 配置验证服务CA 在签发 DV（Domain Validation）证书时，需要验证域名所有权，而大部分都是通过邮件验证的方式，Let's Encrypt 则是在你的服务器上生成一个随机验证文件，再通过创建 CSR 时指定的域名访问，如果可以访问则表明你对这个域名有控制权。首先创建用于存放验证文件的目录```mkdir ~/www/challenges/```然后配置一个 HTTP 服务，以 Nginx 为例：```server {    listen       80;    # 这里改成自己的域名    server_name yuxingxin.com www.yuxingxin.com;    location /.well-known/acme-challenge/ {        alias /root/www/challenges/;        try_files $uri =404;    }}```#### 生成网站证书先把acme-tiny脚本保存到之前的ssl目录```wget https://raw.githubusercontent.com/diafygi/acme-tiny/master/acme_tiny.py```指定账户私钥、CSR 以及验证目录，在ssl目录下执行脚本```python acme_tiny.py --account-key ./account.key --csr ./domain.csr --acme-dir /root/www/challenges/ > ./signed.crt```如果一切正常，当前目录ssl下就会生成一个 signed.crt，这就是申请好的证书文件。这里遇到一个错误,大致如下：```ValueError: Wrote file to /root/www/challenges/oJbvpIhkwkBGBAQUklWJXyC8VbWAdQqlgpwUJkgC1Vg, but couldn't download http://www.yuxingxin.com/.well-known/acme-challenge/oJbvpIhkwkBGBAQUklWJXyC8VbWAdQqlgpwUJkgC1Vg```网上查了一些方案，觉得有一个比较靠谱，也得到了解决，大致就是原来库做了一个验证导致有些情况通不过，这里有人fork源库修改了部分代码，地址在[这里](https://github.com/frezbo/acme-tiny)，如果出现上述错误，可以获取这个库的脚步然后在执行上面那条命令。#### 下载中间证书```wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem > intermediate.pemcat signed.crt intermediate.pem > chained.pem```#### 为了后续能顺利启用 OCSP Stapling，我们再把根证书和中间证书合在一起：```wget -O - https://letsencrypt.org/certs/isrgrootx1.pem > root.pemcat intermediate.pem root.pem > full_chained.pem```#### 修改nginx证书配置```server {    listen 443;    #修改成自己的域名    server_name yuxingxin.com www.yuxingxin.com;    ssl on;    #这里注意证书路径    ssl_certificate /root/ssl/chained.pem;    ssl_certificate_key /root/ssl/domain.key;    ssl_session_timeout 5m;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA;    ssl_session_cache shared:SSL:50m;    ssl_dhparam /root/ssl/dhparam.pem;    ssl_prefer_server_ciphers on;    resolver 8.8.8.8;    ssl_stapling on;    ssl_trusted_certificate /root/ssl/signed.crt;    add_header Strict-Transport-Security \"max-age=31536000; includeSubdomains;preload\";    location / {        # 这里要改成自己存放博客静态网页的目录        root  /root/blog;        index  index.html index.htm;    }}server {    listen       80;    # 这里改成自己的域名    server_name yuxingxin.com www.yuxingxin.com;    ssl_certificate /root/ssl/chained.pem;    ssl_certificate_key /root/ssl/domain.key;    location / {        return 301 https://$host$request_uri;    }    location /.well-known/acme-challenge/ {        alias /root/www/challenges/;        try_files $uri =404;    }    #error_page  404              /404.html;    # redirect server error pages to the static page /50x.html    #    error_page   500 502 503 504  /50x.html;    location = /50x.html {        root   html;    }}```### 配置自动更新Let's Encrypt 签发的证书只有 90 天有效期，推荐使用脚本定期更新创建脚本文件并赋予执行权限```mkdir shellcd shellvi renew_cert.sh```并复制下面内容```#!/bin/bashcd /root/ssl/python acme_tiny.py --account-key account.key --csr domain.csr --acme-dir /root/www/challenges/ > signed.crt || exitwget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem > intermediate.pemcat signed.crt intermediate.pem > chained.pemservice nginx reload```这里借助crontab来定时执行任务，它是一个可以用来根据时间、日期、月份、星期的组合来调度对重复任务的执行的守护进程。在终端执行：```crontab -e```然后添加如下内容：```0 0 1 * * /root/shell/renew_cert.sh >/dev/null 2>&1```这样以后证书每个月都会自动更新，一劳永逸。另外这里也推荐一个网站，可以监测你的证书的有效期[https://letsmonitor.org](https://letsmonitor.org/)这样的话就算完了，但是有几点需要注意下：1. dhparam的生成```openssl dhparam -out /etc/nginx/ssl/dhparam.pem 2048```2. 强制HTTPS```#另外还有两种其他的配置方式，可以自行Google location / {        return 301 https://$host$request_uri;    }```3. 关于HSTSHTTP Strict Transport Security的缩写，即：“HTTP严格传输安全”。假设一个用户从来没有访问过我的网站，并且他第一次访问的时候访问的是 http://yuxingxin.com ，在正常的情况下，我的服务器就会给这位用户返回一个 301 跳转到 https://yuxingxin.com ，并且带上上面配置的HSTS头，在用户下次访问我的博客时，只要 HSTS 还在有效期中，浏览器就会直接跳转到相对应的 https 页面，并且这是不需要经过数据传输的，直接在本地浏览器进行的处理。目前大部分浏览器对HSTS的支持已经相当完美，具体各浏览器和版本的支持情况可以在[这里](http://caniuse.com/#search=HSTS)上查看。 但是HSTS是有缺陷的，第一次访问网站的客户端，HSTS并不工作。 要解决这个问题，就需要我们下面要讲解的HSTS preload list。它是一个站点的列表，并通过硬编码写入 Chrome 浏览器中，列表中的站点将会默认使用 HTTPS 进行访问，此外，Firefox 、Safari 、IE 11 和 Edge 也同样用一份 HSTS 站点列表，它申请加入需要一些条件：4. 有一张有效的证书（如果是使用了 SHA-1 证书签名算法的必须在 2016 年前失效）5. 重定向所有的 HTTP 流量到 HTTPS （ HTTPS ONLY ）6. 全部子域名的流量均通过 HTTPS ，如果子域名的 www 存在的话也同样需要通过 HTTPS 传输。* 在相应的域名中输出 HSTS 响应头1 过期时间至少大于 18 周（10886400 秒）2 必须声明 includeSubdomains3 必须声明 preload4 跳转过去的那个页面也需要有 HSTS 头点击[这里](https://hstspreload.org/)开始申请，申请成功后，你的域名就会加入到[这个列表](https://code.google.com/p/chromium/codesearch#chromium/src/net/http/transport*security*state_static.json)![ssl.png](http://upload-images.jianshu.io/upload_images/450566-d5d44b46903e8552.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)如果大多数浏览器都已经更新到新的列表，那么针对国内的 VPS ，不打开80端口，只打开 443 ，浏览器同样会跳转过来，这样就可以免备案了，不过好像这样对搜索引擎就不太友好。## 测试所有这些工作完成以后，我们可以对证书进行检测。这里是[检测地址](https://www.ssllabs.com/ssltest/index.html) ，下面是我的域名的检测报告。![report.jpeg](http://upload-images.jianshu.io/upload_images/450566-082a2a529b747654.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)如果是A+,则说明你的配置是好着的。另外这里也给出一个国内的[检测网站](https://www.chinassl.net/ssltools/ssl-checker.html)，除了以上这些步骤，可能觉得有些繁琐，就有人写了一个[脚本](https://github.com/xdtianyu/scripts/blob/master/lets-encrypt/README-CN.md),它是一个快速获取/更新 Let's encrypt 证书的 shell script，使用该脚本可以简化上面的流程。"
  },
  
  {
    "title": "西安GDG上《以开发者的角度再聊Material Design》的总结",
    "url": "/posts/material-design/",
    "categories": "Android",
    "tags": "Material, Design",
    "date": "2016-07-17 00:00:00 +0800",
    





    "snippet": "## 概述谷歌在2014年I/O大会上推出了Material Design,旨在为手机、平板电脑、台式机和“其他平台”提供更一致、更广泛的“外观和感觉”。在国内有好几种版本的翻译：材料设计/材质设计/质感设计（官方文档）/原质设计（国内设计师更倾向于这个）。## 三大设计原则### 隐喻通过纸墨做比，光影打造空间层次和符合客观规律的特效来隐喻表面质感、光效以及运动感。### 鲜明、形象、深思熟虑借鉴了传统的印刷设计，从排版、网格、空间、比例、配色、图像使用上做了精心处理，尤其对色彩、图像、字体、留白明确了规范，力求构建鲜明的用户界面。### 有意义的动画效果通过符合客观运动规律的特效效果，让物体的变化以更连续、更平滑的方式呈现给用户，从而吸引用户的注意。比如转场、触摸反馈、循环揭示等关于界面的层次：![image](/assets/images/md1.png)从下往上依次可以分为：* 界面的内容* 顶部导航条 App Bar* 浮动按钮  FAB* 状态栏&底部虚拟导航键* 抽屉菜单* 通知栏等系统信息## 六大部分官方文档分别从动画、样式、布局、组件、模式、可用性六个方面对Material Design的设计规范进行了详细阐释。这里主要列一些5.0以后引入的新特性：### 1.触控涟漪![image](/assets/images/md2.gif)首先在视图 XML 中应用此功能* ?android:attr/selectableItemBackground 指定有界的波纹。* ?android:attr/selectableItemBackgroundBorderless 指定越过视图边界的波纹。 它将由一个非空背景的视图的最近父项所绘制和设定边界。注意这个是API21引入的新特性如果要改变默认触摸反馈颜色，可以在我们自定义的主题下面主题的添加 android:colorControlHighlight 属性。相关类是RippleDrawable。在drawable-v21中：```                                    ```如果要兼容5.0以下版本，我们可以使用第三方开源库[RippleEffect](https://github.com/traex/RippleEffect)否则可以在drawable中定义selector指定不同的状态即可### 2. View状态改变动画StateListAnimator定义当视图的状态改变的时候运行动画，如下代码：```                                    ```给视图分配动画使用android:stateListAnimator属性,代码实现可以借助AnimationInflater.loadStateListAnimator()和View.setStateListAnimator()方法。* 注意当你的主题是继承的Material主题，按钮默认有一个Z轴动画。如果需要避免这个动画，设置android:stateListAnimator属性为@null即可。与此相似的是animated-selector：android5.0的一些系统组件默认使用这些动画。```                                                                    ...                ...```### 3.循环揭示它提供视觉上的持续性挡显示或者隐藏一组界面元素。通过ViewAnimationUtils.createCircularReveal()方法可以使用动画效果来揭示或者隐藏一个视图。![image](/assets/images/md3.gif)关键代码揭示一个先前隐藏的视图```Animator anim =    ViewAnimationUtils.createCircularReveal(myView, cx, cy, 0, finalRadius);myView.setVisibility(View.VISIBLE);anim.start();```隐藏一个先前显示的视图```Animator anim =    ViewAnimationUtils.createCircularReveal(myView, cx, cy, initialRadius, 0);anim.addListener(new AnimatorListenerAdapter() {    @Override    public void onAnimationEnd(Animator animation) {        super.onAnimationEnd(animation);        myView.setVisibility(View.INVISIBLE);    }});anim.start();```针对5.0以下如果实现，可以借用第三方库：[CircularReveal](https://github.com/ozodrukh/CircularReveal)### 共享元素转场android 5.0(api 21)提供以下进入和退出效果：* explode(分解)  * slide(滑动)   * fade(淡入淡出)接下来猪脚登场,共享元素过渡效果：* changeBounds - 改变目标视图的布局边界* changeClipBounds - 裁剪目标视图边界* changeTransform - 改变目标视图的缩放比例和旋转角度* changeImageTransform - 改变目标图片的大小和缩放比例![image](/assets/images/SceneTransition.png)首先在我们继承的主题上，使用android:windowContentTransitions属性开启窗口内内容过渡效果* 以共享元素启动一个操作行为```ActivityOptionsCompat options = ActivityOptionsCompat.    makeSceneTransitionAnimation(this, (View)ivAvatar, \"avatar\");startActivity(intent, options.toBundle());```* 以多个共享元素启动一个操作行为```Pair p1 = Pair.create((View)ivProfile, \"profile\");Pair p2 = Pair.create(vPalette, \"palette\");Pair p3 = Pair.create((View)tvName, \"text\");ActivityOptionsCompat options = ActivityOptionsCompat.    makeSceneTransitionAnimation(this, p1, p2, p3);startActivity(intent, options.toBundle());```### Scrolling Animations放到后面### 高度和阴影![image](/assets/images/md4.png)Z = elevation + translationZ主要借助elevation属性### 着色利用 Android 5.0（API 级别 21）及更高版本,可为位图以及定义为 Alpha 蒙版的点九图着色，主要借助android:tint 以及 android:tintMode 属性设置您的布局中的着色颜色和模式。### 裁剪视图![image](/assets/images/md5.png)* 扩展 ViewOutlineProvider 类别。* 重写 getOutline() 方法。* 利用 View.setOutlineProvider() 方法设置轮廓。### 矢量图片添加动画先是xml文件，对应类是VectorDrawable```                    ```设置drawable，对应类是AnimatedVectorDrawable```           ```上面是使用了两个属性动画，对应类是ObjectAnimator其中旋转动画和变形动画：```   ```### 从图像萃取颜色如果要萃取这些颜色，可以通过如下函数：![image](/assets/images/md6.png)```Palette.from(bitmap).generate()Palette.generateAsync(bitmap,paletteAsyncListener)```然后可以通过 Palette.getVibrantColor方法获取色值## 样式### 颜色颜色不宜过多。选取一种主色、一种辅助色（非必需），在此基础上进行明度、饱和度变化，构成配色方案。(https://www.materialpalette.com)### 图标建议模仿现实中的折纸效果，通过扁平色彩表现空间和光影。这里也推荐下这个插件：https://github.com/konifar/android-material-design-icon-generator-plugin### 图片优先使用图像。然后可以考虑使用插画。### 文字英文官方建议Roboto字体，中文推荐Noto(思源黑体)，另外官方也开源了[字体库](http://fonts.google.com/),需翻墙## 布局这里列出部分尺寸：* 所有可操作元素最小点击区域尺寸：48dp X 48dp。* 栅格系统的最小单位是8dp，一切距离、尺寸都应该是8dp的整数倍。以下是一些常见的尺寸与距离：（推荐网格校正工具：keyline pushing）* 顶部状态栏高度：24dp* Appbar最小高度：56dp* 底部导航栏高度：48dp* 悬浮按钮尺寸：56x56dp/40x40dp* 用户头像尺寸：64x64dp/40x40dp* 小图标点击区域：48x48dp* 侧边抽屉到屏幕右边的距离：56dp* 卡片间距：8dp* 分隔线上下留白：8dp* 大多元素的留白距离：16dp推荐国外开发者贡献的一个开源库：https://github.com/DmitryMalkovich/material-design-dimens  里面总结了一些Material Design的设计规范，另外也推荐一款网格校正工具：[keyline pushing](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0ahUKEwiB17eglZvOAhVJ72MKHdcIADUQFggfMAA&url=https%3A%2F%2Fplay.google.com%2Fstore%2Fapps%2Fdetails%3Fid%3Dcom.faizmalkani.keylines%26hl%3Dzh_CN&usg=AFQjCNFaXp2sbsfOHk8bifBkhuS38VukCw&sig2=pEOMduInSxFH9v2qvjPcYw)## 组件这里列出来一些官方组件，可供我们开发Material Design时使用* RecyclerView* CardView* DrawerLayout* NavigationView* Toolbar* FloatingActionButton* Snackbar* TextInputLayout* TextInputEditText* CoordinatorLayout* TabLayout* AppBarLayout* SwipeRefreshLayout* CollapsingToolbarLayout* BottomSheetBehavior* PercentRelativeLayout* Palette* PagerTabStrip* PagerTitleStrip* SlidingPanelLayout### RecyclerView关于RecyclerView的几点总结：* RecyclerView.LayoutManager\t:负责Item视图的布局的显示管理* RecyclerView.ItemDecoration\t:给每一项Item视图添加子View,如加分割线等* RecyclerView.ItemAnimator:负责处理数据添加或者删除时候的动画效果* RecyclerView.Adapter:为每一项Item创建视图* RecyclerView.ViewHolder:承载Item视图的子布局与ListView的对比：* RecyclerView需借助ViewHolder模式来实现Adapter* RecyclerView可以自定义Item布局：listview只能以垂直线性排列的方式来布局Item,而RecyclerView借助RecyclerView.LayoutManager可以实现多种布局，如网格、瀑布流等* Item 动画：借助RecyclerView.ItemAnimator很容易实现item动画* 数据源：listview针对不同的数据源可以有不同的适配器，而RecyclerView需要借助RecyclerView.Adapter自定义实现适配器来提供数据。* Item Decoration：listview可以通过android:divider很容易实现分割线等，而RecycerView则需要借助RecyclerView.ItemDecoration* Item Click : listview可以通过AdapterView.OnItemClickListener来实现，而RecyclerView则只提供了RecyclerView.OnItemTouchListener### CardView![image](/assets/images/md7.png)两个属性：```app:cardCornerRadiusapp:cardBackgroundColor```### Toolbar用来替代ActionBar，可以当做一个普通的ViewGroup来使用，所以来说比前者更灵活### AppBarLayout常作为Toolbar和其他View的父View配合CoordinatorLayout使用来实现Scrolling Animation### FloatingActionButton浮动Button,也可以加入二级菜单### Snackbar带有动作的Toast### TabLayout常和ViewPager搭配使用，比较方便### CoordinatorLayout.BehaviorCoordinatorLayout是一个比较重要的类，大致主要分这几点：* 一个抽象内部类* 利用泛型是指定我们应用这个Behavior的view的类型* 自定义Behavior：某个View监听另一个view的状态变化，例如大小、位置、显示状态等：layoutDependendsOn和onDependentViewChanged方法；* 某个view监听CoordinatorLayout里的滑动状态：onStartNestedScroll和onNestedPreScroll方法。* CoordinatorLayout 所做的事情就是当成一个通信的 桥梁 ，连接不同的view。使用 Behavior 对象进行通信。两个常见用例：* CoordinatorLayout与悬浮操作按钮1. CoordinatorLayout是用来协调其子view们之间动作的一个父view，而Behavior就是用来给CoordinatorLayout的子view们实现交互的。2. FloatingActionButton作为一个子View添加进CoordinatorLayout并且将CoordinatorLayout传递给 Snackbar.make()* CoordinatorLayout与app bar1. 使用AppBarLayout可以让你的Toolbar与其他view（比如TabLayout的选项卡）能响应被标记了ScrollingViewBehavior的View的滚动事件2. 这里使用了CollapsingToolbarLayout的app:layout_collapseMode=\"pin\"来确保Toolbar在view折叠的时候仍然被固定在屏幕的顶部。借助app:layout_collapseMode=\"parallax\"（以及使用app:layout_collapseParallaxMultiplier=\"0.7\"来设置视差因子）来实现视差滚动效果（比如CollapsingToolbarLayout里面的一个ImageView），这种情况和CollapsingToolbarLayout的app:contentScrim=\"?attr/colorPrimary\"属性一起配合更完美。总结：* CoordinatorLayout必须作为整个布局的父布局容器。* 给需要滑动的组件设置 app:layout_scrollFlags=”scroll|enterAlways” 属性。* 给你的可滑动的组件，也就是RecyclerView 或者 NestedScrollView 设置如下属性:app:layout_behavior = @string/appbar_scrolling_view_behavior* 给需要有折叠效果的组件设置 layout_collapseMode属性。### Chris Banesandroid.support:design库作者github: https://github.com/chrisbanesgoogle+: https://plus.google.com/+ChrisBanestwitter: https://twitter.com/chrisbanesblog: http://chris.banes.me/## 总结* 阴影：android:elevation 和 android:translationZ* 调色：通过android:colorPrimary 和 android:colorAccent、Palette萃取等* 图标：使用遵循material design spec的icon* 尺寸：注意8dp的整数倍* 动效：波纹动画、循环揭示、共享元素转场、滑动、SVG动画等* 组件：FAB、Appbar、Tabs、Cards、Lists等## 兼容### 样式与布局兼容> 可以写对应的样式文件和布局文件  * res/values/styles.xml.  * res/values-v21/styles.xml.  * res/layout/my_activity.xml  * res/layout-v21/my_activity.xml### 使用支持库提供的组件### 使用兼容的主题：Theme.AppCompat> 以下组件可以借助兼容主题来实现已有样式* EditText* Spinner* CheckBox* RadioButton* SwitchCompat* CheckedTextView### 调色板![image](/assets/images/md8.png)``` ```### 使用第三方组件库### 自己造轮子先[熟悉API](http://developer.android.com/design/material/index.html )，再查看官方设计指南，利用现有API进行封装## Best-In-Class Android DesignMaterial Design团队整理的Google Play上比较好的MD风格的App![image](/assets/images/md9.png)https://play.google.com/store/apps/collection/promotion_3001769_io_awards## 附录这次的PPT[下载地址](https://pan.baidu.com/s/1dFLqrs9)"
  },
  
  {
    "title": "西安GDG上关于主题[当Android遇上RxJava]的分享总结",
    "url": "/posts/xian-gdg-share/",
    "categories": "Android",
    "tags": "RxJava",
    "date": "2016-01-10 00:00:00 +0800",
    





    "snippet": "## 前言1月10号这一天，也是值得高兴的日子，一大早起来打开手机看到《RxJava Essentials》一书的作者Ivan.Morgillo给我在推特上发的消息点赞并转发后关注了我，这让我激动不已，可能对于我这种没见过大世面的人来说，这点小事或许就足以让我自己心里乐上三天。然后就是昨天下午在西安GDG做了关于RxJava的分享，下面是分享内容的总结。##分享内容总结大致分为以下三个主题线：* 1.介绍了ReactiveX、RxJava* 2.Android开发中遇到的常见场景* 3.关于RxJava与Android的学习### ReactiveX的介绍我把它总结为以下三点：* 1.扩展的观察者模式：通过订阅可观测对象的序列流然后做出反应。* 2.迭代器模式：对对象序列进行迭代输出从而使订阅者可以依次对其处理。* 3.函数式编程思想：简化问题的解决的步骤，让你的代码更优雅和简洁然后介绍了ReactiveX在各个语言和平台上的实现,[官方地址](http://reactivex.io/languages.html)最后对上面三点展开进行详细介绍：* 1.先介绍GoF书中的观察者模式，被观察者发出事件，然后观察者（事件源）订阅然后进行处理。并指出其中的不足：比如观察者不知道是否出错与完成，还有就是整个过程是同步，会阻塞线程，从而引出所谓的“扩展”的观察者模式，除了提到的不足作为补充外，另外还有一点：如果没有观察者，被观察者是不会发出任何事件的。* 2.迭代器模式：提供一种方法顺序访问一个聚合对象中的各种元素,而又不暴露该对象的内部表示，用《RxJava Essentials》一书做的的对比：迭代器模式在事件处理上采用的是“同步/拉式”的方式，而被观察者采用的是“异步/推式”的方式，而对观察者而言，显然后者更灵活。* 3.对于函数式编程举例展示了代码风格的不同。### RxJava的介绍我也按照三点作为介绍* 1.RxJava的核心* 2.RxJava操作符* 3.RxJava的扩展然后对这三点展开来讲，其中最花时间的也是这一部分。#### RxJava的核心对象先是通过一个`Hello World`的例子介绍了几个容易混淆的类/接口：* Observable* OnSubscribe* Observer* Subscription* Subscriber代码展示如下：```javaObservable myObservable = Observable        .create(new Observable.OnSubscribe() {            @Override            public void call(Subscriber subscriber) {                subscriber.onNext(\"Hello World!\");                subscriber.onCompleted();            }        });Subscriber mySubscriber = new Subscriber() {    @Override    public void onCompleted() {}    @Override    public void onError(Throwable e) {}    @Override    public void onNext(String s) {        Log.i(\"基础写法：\", s);    }};myObservable.subscribe(mySubscriber);```简化一下：```javaObservable myObservable = Observable.just(\"Hello World!\");Action1 onNextAction = new Action1() {    @Override    public void call(String s) {        Log.v(\"Action1简化后:\", s);    }};myObservable.subscribe(onNextAction);```匿名函数写法：```javaObservable.just(\"Hello World!\").subscribe(new Action1() {            @Override            public void call(String s) {                Log.v(\"匿名函数写法：\",s);            }        });```最后用Java 8 lambdas(Retrolambda)表达式：```javaObservable.just(\"Hello World!\").subscribe(s -> Log.v(\"lambdas写法\",s));```其中这一部分从源码角度简单概括了从被观察者创建，到观察者创建，最后再订阅的过程，并顺便指出了上面几个易混淆的类/接口之间的关系。第二部分是关于异步的话题：先是介绍这几种调度器：* 1.Schedulers.immediate()* 2.Schedulers.newThread()* 3.Schedulers.trampoline()* 4.Schedulers.io()* 5.Schedulers.computation()* 6.AndroidSchedulers.mainThread()然后就是两个操作符：* subscribeOn()：指定 subscribe() 所发生的线程，事件产生的线程* observeOn()：指定 Subscriber 所运行在的线程，事件消费的线程#### RxJava操作符在讲操作符之前，先是介绍了直观有趣的宝石图：这里引用了一张官方的[图片](http://reactivex.io/documentation/observable.html),另外再附上一个国外程序员创建的动态的宝石图[网站](http://rxmarbles.com/)，虽然不全，但是作者一直在更新，相信后面会有更多，这有助于我们来理解操作符。大致分为这几类展开介绍：* 创建操作符：Create, Defer, From, Interval, Just, Range, Repeat, Timer等。* 变换操作符：Map、FlatMap、ConcatMap等。* 过滤操作符：Debounce, Distinct, ElementAt, Filter, First, Last, Sample, Skip, SkipLast, Take, TakeLast等。* 合买操作符以及自定义操作符。最后用一个例子做了下总结，需求如下：* 将一个为数字的字符串数组元素转换为数字* 过滤掉大于10的数字* 去重* 取最后面3个元素* 累计求和用代码实现就是：```javaString[] numbers = {\"11\", \"2\", \"2\", \"13\", \"4\", \"5\",\"7\"};Observable.from(numbers)        .map(s -> Integer.parseInt(s))        .filter(i -> i  number1 + number2)        .subscribe(i -> System.out.println(i));```其中创建操作符例子如下：```javaString[] strings = {\"张三\",\"李四\",\"王五\",\"赵六\"};Observable.from(strings)        .subscribe(new Action1() {            @Override            public void call(String s) {                Log.i(\"name\", s);            }        });```变换操作符例子：```javapublic void showUserName(String userName){    textView.setText(userName);}``````javapublic void showUserName(String userName){    Observable.just(userName).subscribe( new  Action1(){             @Override             public void call(String s){                textView.setText(s);            }    });}```如果需要在显示前对这个字符串做处理，然后再展示，比如加“张三，你好”* 方法1：我们可以对字符串本身操作   (不合适)* 方法2：我们可以放到Action1.call()方法里做处理   （不合适）* 方法3：使用操作符做变换：map    （RxJava的做法）```javapublic void showUserName(String userName){    Observable.just(userName).map(new Func1(){          public String call(String text){             return handleUserName(text);           }    }).subscribe( new Action1(){        public void call(String s){            textView.setText(s);          }    });}```关于flatMap()```java//打印出中国的所有省份名称。List  provinceList = …Observable.from(provinceList)    .map(new Func1(){        @Override        public String call(Province province){            return province.getName();        }    }).subscribe(new Action1(){         @Override         public void call(String s){            Log.i(“省份名称”,s)         }    });``````java//打印出中国每个省份的所有城市  (不合适)List  provinceList = …Observable.from(provinceList)    .subscribe(new Action1(){        @Override        public void call(Province province){            List cities = province.getCities();            for (int i = 0; i   provinceList = …Observable.from(provinceList)    .flatMap(new Func1>(){        @Override        public Observable call(Province province){                 return Observable.from(province.getCities());        }    })    .subscribe(new Action1(){            @Override            public void call(City city){               Log.i(“城市”, city.getName());            }    });```关于flatMap的应用扩展```java//介绍回调地狱restAdapter.getApiService().getToken(new Callback(){    @Override    public void success(String token) {        restAdapter.getApiService().getUserInfo(token,new Callback(){            @Override            public void success(UserInfo userInfo) {                     showMessage(userInfo.getUser);            }            @Override            public void failure(RetrofitError error) {                //处理错误                ...            }        });    }    @Override    public void failure(RetrofitError error) {        // Error handling        ...    }});```如何用RxJava来解决：```javarestAdapter.getApiService()    .getToken()    .flatMap(new Func1>(){            @Override            public Observable call(String token){                     return restAdapter.getApiService().getUserInfo(token);            }    })    .subscribe(new Action1(){            @Override            public void call(UserInfo userInfo){                     showMessage(userInfo.getUser);            }    })```加入线程切换```javarestAdapter.getApiService().getToken()    .flatMap(new Func1>(){            @Override            public Observable call(String token){                     return restAdapter.getApiService().getUserInfo(token);            }    })    .subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程    .observeOn(AndroidSchedulers.mainThread())// 指定 Subscriber 的回调发生在主线程    .subscribe(new Action1(){            @Override            public void call(UserInfo userInfo){                     showMessage(userInfo.getUser);            }    })```#####操作符复用：先介绍不合适的做法：```java Observable applySchedulers(Observable observable) {    return observable.subscribeOn(Schedulers.io())     .observeOn(AndroidSchedulers.mainThread());}```应用后，破坏了链式调用```javaapplySchedulers(restAdapter.getApiService().getToken()    .flatMap(new Func1>(){            @Override            public Observable call(String token){                     return restAdapter.getApiService().getUserInfo(token);            }    })    ).subscribe(new Action1(){            @Override            public void call(UserInfo userInfo){                     showMessage(userInfo.getUser);            }    })```##### 我们加入转换器与Compose()Transformer：继承Func1, Observable>的一个接口，其实是将一个Observable转换为另一个Observable```java Transformer applySchedulers() {     return new Transformer() {       @Override       public Observable call(Observable observable) {         return observable.subscribeOn(Schedulers.io())             .observeOn(AndroidSchedulers.mainThread());       }     };}```用compose操作符做法：```javarestAdapter.getApiService().getToken()    .flatMap(new Func1>(){            @Override            public Observable call(String token){                     return restAdapter.getApiService().getUserInfo(token);            }    })    .compose(applySchedulers())    .subscribe(new Action1(){            @Override            public void call(UserInfo userInfo){                     showMessage(userInfo.getUser);            }    })```#### RxJava的扩展主要是针对以下几个开源库展开来说：* 1.Rxbinding：用RxJava实现onClick,TextWatcher,check等事件绑定。* 2.RxBus：用RxJava实现EventBus或者Otto。* 3.RxPreferences：用RxJava实现Android中的SharedPreferences。* 4.RxLifecycle：用来严格控制由于发布了一个订阅后，由于没有及时取消，导致Activity/Fragment无法销毁导致的内存泄露。* 5.ReactiveNetwork：使用RxJava来监听网络连接状态和wifi信号强度变化。* 6.RxPermissions：针对 Android 6.0 权限管理进行一个 Rx 封装的一个类库。* 7.rxloader：用RxJava对loader的一个封装。* 还有更多...### Android应用场景* 1.避免嵌套回调地狱问题。* 2.使用debounce减少频繁的网络请求。避免每输入（删除）一个字就做一次联想。* 3.使用combineLatest合并最近N个结点,注册的时候所有输入信息（邮箱、密码、电话号码等）合法才点亮注册按钮。* 4.使用merge合并两个数据源,最后做统一处理。* 5.使用concat和first做缓存，依次检查memory、disk和network中是否存在数据，任何一步一旦发现数据后面的操作都不执行。* 6.使用timer做定时操作。* 7.使用interval做周期性操作。* 8.使用throttleFirst防止按钮重复点击* 9.做响应式的界面。* 更多...部分例子代码：```javaRxTextView.textChanges(searchEditText)     .debounce(150, MILLISECONDS)     .switchMap(Api::searchItems)     .subscribe(this::updateList, t->showError());``````javaObservable.merge(getNews(), getHotNews(),    new Func2, MyResponse, Boolean>() {        @Override        public Boolean call(Response response, Response response2) {            mData.clear();            mData.addAll(response);            mData.addAll(response2.msg);            return true;        }    })    .subscribeOn(Schedulers.io())    .observeOn(AndroidSchedulers.mainThread())    .subscribe(new Subscriber() {        @Override        public void onCompleted() {}        @Override        public void onError(Throwable e) {}        @Override        public void onNext(Boolean o) {               mAdapter.notifyDataSetChanged();        }    });``````javaRxView.clicks(button)      .throttleFirst(1, TimeUnit.SECONDS)      .subscribe(new Observer() {          @Override          public void onCompleted() {                log.d (\"completed\");          }          @Override          public void onError(Throwable e) {                log.e(\"error\");          }          @Override          public void onNext(Object o) {               log.d(\"button clicked\");          }      });``````javaSharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(this);RxSharedPreferences rxPreferences = RxSharedPreferences.create(preferences);Preference checked = rxPreferences.getBoolean(\"checked\", true);CheckBox checkBox = (CheckBox) findViewById(R.id.cb_test);RxCompoundButton.checkedChanges(checkBox)        .subscribe(checked.asAction());``````javaObservable memory = Observable    .create(new Observable.OnSubscribe() {        @Override        public void call(Subscriber subscriber) {            if (memoryCache != null) {                subscriber.onNext(memoryCache);            } else {                subscriber.onCompleted();            }        }    });Observable disk = Observable    .create(new Observable.OnSubscribe() {        @Override        public void call(Subscriber subscriber) {            String cachePref = rxPreferences.getString(\"cache\").get();            if (!TextUtils.isEmpty(cachePref)) {                subscriber.onNext(cachePref);            } else {                subscriber.onCompleted();            }        }    });Observable network = Observable.just(\"network\");//依次检查memory、disk、networkObservable.concat(memory, disk, network)    .first()    .subscribeOn(Schedulers.newThread())    .subscribe(s -> {        memoryCache = \"memory\";        System.out.println(\"subscribe: \" + s);    });```#### 感谢/参考感谢Jake大神的启蒙，感谢Ivan.Morgillo的书《RxJava Essentials》,感谢扔物线的文章和大头鬼的翻译文章，同时也是一路看他们的文章走过来的，最后感谢所有分享RxJava的小伙伴们。* http://gank.io/post/560e15be2dca930e00da1083* http://blog.csdn.net/lzyzsd/article/details/41833541* http://blog.csdn.net/theone10211024/article/details/50435325* 《RxJava Essentials》* http://reactivex.io### 关于RxJava和Android的学习主要从渠道，知识点和资源几方面介绍了下学习，提到[MobDevGroup](http://mobdevgroup.com)这个资源站。## GDG总结由于时间上的问题，没有对一些原理进行讲解，尤其是变换等，大部分是在讲应用，总之呢除了对自己知识点一次不错的总结外，也是对自己的一次历练，接下来再接再厉。最后附上这次的PPT下载地址：* Mac [keynote](http://vdisk.weibo.com/s/CeH3i0tfvuvLU)* Windows [PowerPoint](http://vdisk.weibo.com/s/CeH3i0tfvuvMd)"
  },
  
  {
    "title": "RxJava Essentials翻译总结",
    "url": "/posts/rxjava-essentials/",
    "categories": "Android",
    "tags": "RxJava",
    "date": "2016-01-08 00:00:00 +0800",
    





    "snippet": "##前言在前年的时候，一直忙于工作，偶尔关注下开源社区，平时在使用retrofit的库时一直采用传统的回调，当时看官网发现也可以Observable对象，很好奇，但是一直不知道这是什么？慢慢的，关注Jake大神，才知道是RxJava，当时并没有引起我对RxJava 的好奇，也就没有太在意，但是我的心里一直有个梗就是在使用回调时如何让嵌套回调的代码看起来不是那么槽糕，用今天的话说就是回调地狱，直到去年，国内一些积极推动RxJava的大神们才真正让我认识了它，可能最让我印象深刻的一点就是它解决了我这么多年的那个梗，从大头鬼的深入浅出系列到扔物线的给Android开发者的RxJava详解，我决定想系统的学一下它，一直想找本中文书，可是没找到，直到有一天发现国外的这本《RxJava Essentials》，看了一下之后，欣喜之余，决定把它翻译出来，算是巩固学习。##书内容介绍全书分了八章，前两章介绍Rx，并引出Rx在Android中的引用，三四五六章着重讲RxJava的操作符，从创建、过滤一直讲到变换、组合，最后一张结合Android开源库Retrofit来一起使用，总之对于Android开发者来讲是本不错的基础书。### **1.RX-from .NET to RxJava**> 本章带你进入reactive的世界。我们会比较reactive 方法和传统方法，进而探索它们之间的相似和不同的地方。### **2.Why Observables?**> 本章会对观察者模式做一个概述，如何实现它以及怎样用RxJava来进行扩展，被观察者是什么，以及被观察者如何与迭代联系到一起的。### **3.Hello Reactive World**> 本章会利用我们所学的知识来创建第一个reactive Android应用。### **4.Filtering Observables**> 本章我们会研究Observable序列的本质:filtering.我们也将学到如何从一个发出的Observable中选取我们想要的值，如何获得一个有限的数值，如何处理溢出的场景，以及更多有用的技巧。### **5.Transforming Observables**> 本章将讲述如何通过变换Observable序列来创建出我们所需要的序列。### **6.Combining Observables**> 本章将研究与函数结合，同时也会学到当创建我们想要的Observable时又如何与多个Observable协同工作。### **7.Schedulers-Defeating the Android MainThread Issue**> 本章将介绍如何使用RxJava Schedulers 来处理多线程和并发编程。我们也将用reactive的方式来创建网络操作、内存访问、耗时处理。### **8.REST in peace-RxJava and Retrofit**> 本章教会你如何让Square公司的Retrofit和RxJava结合来一起使用，来创建一个更高效的REST客户端程序。## 后续Rx给了我们一种新的学习扩展和并发的方式，它和面向对象一样是一种新的思想，熟练的使用它可以很容易的帮助我们处理日常繁杂的业务逻辑，同时又不会搞乱你的代码，建议开发者都可以学习下，另外这里也推荐另外一本《Learning Reactive Programming》，是它的姊妹篇，介绍响应式编程，同样推荐看看。![RxJava](/assets/images/rxjava.jpg)【RxJava Essentials】![Learning Reactive Programming](/assets/images/reactive.jpg)【Learning Reactive Programming】《RxJava Essentials》[翻译中文版电子书下载地址](https://www.gitbook.com/book/yuxingxin/rxjava-essentials-cn/)《RxJava Essentials》[英文版下载地址](http://vdisk.weibo.com/s/CeH3i0tfvZMVq)《Learning Reactive Programming》[英文版下载地址](http://vdisk.weibo.com/s/CeH3i0tfvZMfT)"
  },
  
  {
    "title": "Android磁盘缓存",
    "url": "/posts/disk-lru-cache/",
    "categories": "Android",
    "tags": "cache",
    "date": "2015-11-24 00:00:00 +0800",
    





    "snippet": "### 1.概述在上一篇文章中简单介绍了[内存缓存](http://www.yuxingxin.com/2015/11/23/LruCache/)，其核心就是LruCache这个类，我们知道它的优点就是直接可以读取内存，当然速度就会很快，但是它同时也有下面不足的地方：1. 手机内存空间十分有限，所以我们不能随意的设置内存缓存大小。2. 内存紧张时可能会优先被GC回收掉。3. 退出应用时就回收掉，不能离线存储数据基于以上原因，于是就有了磁盘缓存，Android开源届Jake大神为我们提供了一种解决方案:[DiskLruCache](https://github.com/JakeWharton/DiskLruCache),也是现在应用的最广泛的一种，并且已经获得谷歌官方认可。### 2.使用#### 打开缓存通过源码我们可以看到DiskLruCache的构造方法时私有的，所以不能通过new的方法来获取到它的实例，但是作者给我们提供了一种方式来创建实例，通过调用open方法，其中的四个参数刚好与构造函数中的四个参数相吻合:1. directory指定缓存的目录2. appVersion指定应用程序的版本号3. valueCount指定一个key可以对应多少个缓存文件，一般情况下我们都指定这个参数为14. maxSize指定我们最多可以缓存多大的字节数```  private DiskLruCache(File directory, int appVersion, int valueCount, long maxSize) {    this.directory = directory;    this.appVersion = appVersion;    this.journalFile = new File(directory, JOURNAL_FILE);    this.journalFileTmp = new File(directory, JOURNAL_FILE_TEMP);    this.journalFileBackup = new File(directory, JOURNAL_FILE_BACKUP);    this.valueCount = valueCount;    this.maxSize = maxSize;  }    /**   * Opens the cache in {@code directory}, creating a cache if none exists   * there.   *   * @param directory a writable directory   * @param valueCount the number of values per cache entry. Must be positive.   * @param maxSize the maximum number of bytes this cache should use to store   * @throws IOException if reading or writing the cache directory fails   */  public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize)      throws IOException {    if (maxSize /cache 这个路径下面，但这里我们通常的做法就是判断是否有SD卡，没有的话就放在内部存储里面，缓存路径为：/data/data//cache ```public File getDiskCacheDir(Context context, String uniqueName) {      String cachePath;      if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())              || !Environment.isExternalStorageRemovable()) {          cachePath = context.getExternalCacheDir().getPath();      } else {          cachePath = context.getCacheDir().getPath();      }      return new File(cachePath + File.separator + uniqueName);  }  ```这里的uniqueName值作为我们区分不同的数据的一个唯一值，如存放图片的缓存文件夹（images），存放视频的缓存文件夹(videos)，存放文本文件的缓存文件夹（txt）。第二个参数获取版本号就很简单了```public int getAppVersion(Context context) {      try {          PackageInfo info = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);          return info.versionCode;      } catch (NameNotFoundException e) {          e.printStackTrace();      }      return 1;  }  ```第三个参数上面提到了为1，第四个参数假定我们设为10M，那么就有了：```DiskLruCache mDiskLruCache = null;  try {      File cacheDir = getDiskCacheDir(context, \"images\");      if (!cacheDir.exists()) {          cacheDir.mkdirs();      }      mDiskLruCache = DiskLruCache.open(cacheDir, getAppVersion(context), 1, 10 * 1024 * 1024);  } catch (IOException e) {      e.printStackTrace();  }  ```#### 存缓存到磁盘这点类似SharePreferences,DiskLruCache给我们提供了一个内部类Editor，它用来完成针对缓存文件的读取、储存、删除、修改等等操作：通过调用实例的edit方法传入key值来把文件缓存到磁盘，然后针对函数返回的Editor实例调用commit方法完成最后的提交。```mDiskLruCache.edit(key).commit();  mDiskLruCache.flush();  ```这里的key值我们一般使用MD5加密后的字符串来做唯一处理，当然也可以调用abort来放弃提交。#### 读取缓存文件读取缓存文件通过get(key)方法来进行：```InputStream is = mDiskLruCache.get(key).getInputStream(0);//TODO 然后再对流做进一步的处理```#### 移除缓存移除缓存调用remove(key)方法：```mDiskLruCache.remove(key);```#### 获取缓存大小通过size()方法返回当前缓存路径下面所有缓存数据的字节数，以byte为单位。#### 关闭缓存调用close()方法，通常在界面销毁的时候调用#### 删除缓存调用delete()方法,即可清除缓存"
  },
  
  {
    "title": "Android内存缓存",
    "url": "/posts/lru-cache/",
    "categories": "Android",
    "tags": "cache",
    "date": "2015-11-23 00:00:00 +0800",
    





    "snippet": "### 1.概述通常情况下，我们为了实现更好的用户体验从而引入了缓存的概念，这在Android应用于图片列表加载上显得更为重要。我们为了让内存维护在一个合理的范围，通常会把移除屏幕的图片进行回收处理，让GC去操作这些不在持有图片的引用，为了App有更流畅的体验，比如在界面上更加流畅的加载图片，而不得不考虑的一个问题就是图片回收之后，这时候用户又将刚刚回收的图片重新滑入屏幕内，这时候又回去加载一遍刚刚回收的图片，这无疑给性能带来了诸多问题，因此我们引入内存缓存。### 2.原理内存缓存对于那些大量占用程序宝贵内存资源的图片来说很好用，它提供了快速访问内存的方法，在过去，我们经常通过软引用或者弱引用(SoftReference or WeakReference)的方式，但是现在已经不推荐使用，自从Android 2.3（API Level 9）开始，JVM做了调整，使得垃圾回收器更容易倾向于回收持有软引用或者是弱引用的对象，折让弱引用或者软引用就变得不可靠，另外，Android3.0（API Level 11）中，图片的数据会存储在本地的内存中，也没有一个可预见的方式来释放它，这就给应用程序的崩溃或内存溢出埋下了隐患。因此在谷歌官方给我们在v4包中提供了LruCache类，它主要算法原理是将对象用强引用存储在LinkedHashMap中，并且把最近最少使用的对象在缓存值达到预设值之前从内存中移除，来释放它。```    /**     * @param maxSize for caches that do not override {@link #sizeOf}, this is     *     the maximum number of entries in the cache. For all other caches,     *     this is the maximum sum of the sizes of the entries in this cache.     */    public LruCache(int maxSize) {        if (maxSize (0, 0.75f, true);    }```#### 关于LinkedHashMap的介绍LinkedHashMap是HashMap的子类，它保留了插入的顺序，并维护者运行所有元素的一个双重链表，默认是按插入顺序排序(即构造函数最后一个参数false)，如果指定按访问顺序排序（最近最少使用，构造函数最后一个为true），那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。### 3.使用1. 初始化```    // 获取到可用内存的最大值，使用内存超出这个值会引起OutOfMemory异常。     // LruCache通过构造函数传入缓存值，以KB为单位。     int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);     // 使用最大可用内存值的1/8作为缓存的大小。     int cacheSize = maxMemory / 8;     mMemoryCache = new LruCache(cacheSize) {         @Override        protected int sizeOf(String key, Bitmap bitmap) {             // 重写此方法来衡量每张图片的大小，默认返回图片数量。             return bitmap.getByteCount() / 1024;         }     };  ```2. 提供访问方法```public void addBitmapToMemoryCache(String key, Bitmap bitmap) {     if (getBitmapFromMemCache(key) == null) {         mMemoryCache.put(key, bitmap);     } }     public Bitmap getBitmapFromMemCache(String key) {     return mMemoryCache.get(key); }```上面使用了系统分配给应用程序的八分之一作为缓存大小，在一些手机上大概是4M的内存空间，通常我们在加载图片的时候会先去缓存中取，如果取不到，则会开启一个后台线程去加载图片```public void loadBitmap(String url ,ImageView iv){    String key = md5(url);    Bitmap bitmap = getBitmapFromMemCache(key);    if(bitmap != null){        iv.setImageBitmap(bitmap);    }else{        //TODO 开启线程去下载    }}//在下载完图片后还需要保存在缓存中class ImageDownLoaderTask extends AsyncTask{    @Override    protected Bitmap doInBackground(Integer... params) {         //取到Bitmap        …        …        addBitmapToMemoryCache(String.valueOf(params[0]), bitmap);         return bitmap;     } }```### 4.源码解析1. 成员变量```    private final LinkedHashMap map;            /** Size of this cache in units. Not necessarily the number of elements. */      private int size; //已经存储的大小    private int maxSize; //规定的最大存储空间    private int putCount;  //put的次数    private int createCount;  //create的次数    private int evictionCount;  //回收的次数    private int hitCount;  //命中的次数    private int missCount;  //丢失的次数    /**     * For caches that do not override {@link #sizeOf}, this returns the number     * of entries in the cache. For all other caches, this returns the sum of     * the sizes of the entries in this cache.     */    public synchronized final int size() {        return size;    }    /**     * For caches that do not override {@link #sizeOf}, this returns the maximum     * number of entries in the cache. For all other caches, this returns the     * maximum sum of the sizes of the entries in this cache.     */    public synchronized final int maxSize() {        return maxSize;    }    /**     * Returns the number of times {@link #get} returned a value that was     * already present in the cache.     */    public synchronized final int hitCount() {        return hitCount;    }    /**     * Returns the number of times {@link #get} returned null or required a new     * value to be created.     */    public synchronized final int missCount() {        return missCount;    }    /**     * Returns the number of times {@link #create(Object)} returned a value.     */    public synchronized final int createCount() {        return createCount;    }    /**     * Returns the number of times {@link #put} was called.     */    public synchronized final int putCount() {        return putCount;    }    /**     * Returns the number of values that have been evicted.     */    public synchronized final int evictionCount() {        return evictionCount;    }```2. 取缓存```    /**     * Returns the value for {@code key} if it exists in the cache or can be     * created by {@code #create}. If a value was returned, it is moved to the     * head of the queue. This returns null if a value is not cached and cannot     * be created.     * 通过key来取对应的元素，或者返回新创建的元素，相应的这个元素会移动到队列的头部，如果这个元     * 素没有被缓存，也不能创建，则会返回null     */    public final V get(K key) {        if (key == null) {            throw new NullPointerException(\"key == null\");        }        V mapValue;        synchronized (this) {            mapValue = map.get(key);            if (mapValue != null) {                hitCount++; //命中  找到了                return mapValue;            }            missCount++;  //丢失，没有命中        }        /*         * Attempt to create a value. This may take a long time, and the map         * may be different when create() returns. If a conflicting value was         * added to the map while create() was working, we leave that value in         * the map and release the created value.         */        V createdValue = create(key);        if (createdValue == null) {            return null;        }        synchronized (this) {            createCount++;            mapValue = map.put(key, createdValue);            if (mapValue != null) {                // There was a conflict so undo that last put                map.put(key, mapValue);// 如果前面存在oldValue,那么就撤销最后一次的put            } else {                size += safeSizeOf(key, createdValue);            }        }        if (mapValue != null) {            entryRemoved(false, key, createdValue, mapValue);            return mapValue;        } else {            trimToSize(maxSize);            return createdValue;        }    }```3. 存缓存```    /**     * Caches {@code value} for {@code key}. The value is moved to the head of     * the queue.     *     * @return the previous value mapped by {@code key}.     */    public final V put(K key, V value) {        if (key == null || value == null) {            throw new NullPointerException(\"key == null || value == null\");        }        V previous;        synchronized (this) {            putCount++;            size += safeSizeOf(key, value);            previous = map.put(key, value);//返回的先前的value值            if (previous != null) {                 size -= safeSizeOf(key, previous);            }        }        if (previous != null) {            entryRemoved(false, key, previous, value);        }        trimToSize(maxSize);        return previous;    }```4. 清掉占用的内存空间```    /**     * Remove the eldest entries until the total of remaining entries is at or     * below the requested size.     *     * @param maxSize the maximum size of the cache before returning. May be -1     *            to evict even 0-sized elements.     */    public void trimToSize(int maxSize) {        while (true) {            K key;            V value;            synchronized (this) {                if (size  toEvict = map.entrySet().iterator().next();                key = toEvict.getKey();                value = toEvict.getValue();                map.remove(key);                size -= safeSizeOf(key, value);                evictionCount++;            }            entryRemoved(true, key, value, null);        }    }    /**     * Removes the entry for {@code key} if it exists.     * 删除key相应的cache项，返回相应的value     * @return the previous value mapped by {@code key}.     */    public final V remove(K key) {        if (key == null) {            throw new NullPointerException(\"key == null\");        }        V previous;        synchronized (this) {            previous = map.remove(key);            if (previous != null) {                size -= safeSizeOf(key, previous);            }        }        if (previous != null) {            entryRemoved(false, key, previous, null);        }        return previous;    }    /**     * Called for entries that have been evicted or removed. This method is     * invoked when a value is evicted to make space, removed by a call to     * {@link #remove}, or replaced by a call to {@link #put}. The default     * implementation does nothing.     *     * The method is called without synchronization: other threads may     * access the cache while this method is executing.     *     * @param evicted true if the entry is being removed to make space, false     *     if the removal was caused by a {@link #put} or {@link #remove}.     * @param newValue the new value for {@code key}, if it exists. If non-null,     *     this removal was caused by a {@link #put}. Otherwise it was caused by     *     an eviction or a {@link #remove}.     */    protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {}    /**     * Called after a cache miss to compute a value for the corresponding key.     * Returns the computed value or null if no value can be computed. The     * default implementation returns null.     *     * The method is called without synchronization: other threads may     * access the cache while this method is executing.     *     * If a value for {@code key} exists in the cache when this method     * returns, the created value will be released with {@link #entryRemoved}     * and discarded. This can occur when multiple threads request the same key     * at the same time (causing multiple values to be created), or when one     * thread calls {@link #put} while another is creating a value for the same     * key.     */    protected V create(K key) {        return null;    }    private int safeSizeOf(K key, V value) {        int result = sizeOf(key, value);        if (result An entry's size must not change while it is in the cache.     */    protected int sizeOf(K key, V value) {        return 1;    }    /**     * Clear the cache, calling {@link #entryRemoved} on each removed entry.     * 清空cache     */    public final void evictAll() {        trimToSize(-1); // -1 will evict 0-sized elements    }```"
  }
  
]

